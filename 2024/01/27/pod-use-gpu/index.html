<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <base href="http://mospany.github.io/">
  <title>K8S项目实践(11): Pod 是如何使用到 GPU 的及源码分析 - 墨斯潘園</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
  <meta name="keywords" content="K8S,GPU,">
  <meta name="description" content="本文主要分析了在 K8s 中创建一个 Pod 并申请 GPU 资源，最终该 Pod 时怎么能够使用 GPU 的，具体的实现原理，以及 device plugin、nvidia-container">
  <meta name="author" content="mospan">
  <meta itemprop="name" content="K8S项目实践(11): Pod 是如何使用到 GPU 的及源码分析 - 墨斯潘園">
  <meta itemprop="description" content="本文主要分析了在 K8s 中创建一个 Pod 并申请 GPU 资源，最终该 Pod 时怎么能够使用 GPU 的，具体的实现原理，以及 device plugin、nvidia-container">
  <meta itemprop="image" content="http://mospany.github.io/img/author.jpg">
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@mospan" />
  <meta name="twitter:title" content="K8S项目实践(11): Pod 是如何使用到 GPU 的及源码分析 - 墨斯潘園" />
  
  <meta name="twitter:description" content="">
  <link rel="shortcut icon" href="img/favicon.ico"/>
  <link rel="apple-touch-icon" href="apple-touch-icon.png" />
  <link rel="apple-touch-icon-precomposed" href="apple-touch-icon.png" />
  <link rel="stylesheet" href="highlight/styles/github.css">
  <script src="highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <link rel="stylesheet" href="font/hack/css/hack.min.css">
  <link rel="stylesheet" href="css/style.css">
</head>

<body>
  <header>
    <div>
  
  <div id="imglogo">
    <a href="http://mospany.github.io/"><img src="http://mospany.github.io/img/logo.jpg" alt="墨斯潘園" title="墨斯潘園"/></a>
  </div>
  
  <div id="textlogo">
    <h1 class="site-name"><a href="http://mospany.github.io/" title="墨斯潘園">墨斯潘園</a></h1>
    <h2 class="blog-motto">技术改变生活，学习成就未来</h2>
  </div>
  <div class="navbar"><a class="navbutton navmobile" href="#" title="menu"></a></div>
  <nav class="animated">
    <ul>
      
      <li><a href="/">首页</a></li> 
      
      <li><a href="/about">关于</a></li> 
      
      <li>
        <form class="search" method="get" action="https://www.google.com/search">
          <div>
            <input type="text" id="search" name="q" placeholder="搜索">
          </div>
        </form>
      </li>
    </ul>
  </nav>
</div>

  </header>
  <div id="container">
    <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody">
    <header class="article-info clearfix">
  <h1 itemprop="name">
      <a href="http://mospany.github.io/2024/01/27/pod-use-gpu/" title="K8S项目实践(11): Pod 是如何使用到 GPU 的及源码分析" itemprop="url">K8S项目实践(11): Pod 是如何使用到 GPU 的及源码分析</a>
  </h1>
  <p class="article-author">By 
    
      <a href="http://blog.mospan.cn" title="mospan">mospan</a>
    
  </p>
  <p class="article-time">
    <time datetime="2024-01-27 19:31:10 &#43;0800 CST" itemprop="datePublished">2024年01月27日</time>
  </p>
</header>

	<div class="article-content">
    
    

<p>本文主要分析了在 K8s 中创建一个 Pod 并申请 GPU 资源，最终该 Pod 时怎么能够使用 GPU 的，具体的实现原理，以及 device plugin、nvidia-container-toolkit 相关源码分析。</p>

<h1 id="1-概述">1. 概述</h1>

<p>这篇文章则是将整个流程连起来做一个简单分析，即：宿主机上的 GPU 是怎么能够被 K8s 中的 Pod 使用的。</p>

<p>可以分为以下两部分：</p>

<ol>
<li>k8s 是如何感知到 GPU 的</li>
<li>GPU 是如何分配给 Pod 的</li>
</ol>

<h1 id="2-工作流程">2. 工作流程</h1>

<p>这部分主要分享一下 NVIDIA 的 device-plugin 以及 nvidia-container-toolkit 的工作流程，以及二者是怎么配合的。</p>

<h2 id="2-1-k8s-是如何感知到-gpu-的">2.1. k8s 是如何感知到 GPU 的</h2>

<p>NVIDIA 实现了<a href="https://github.com/NVIDIA/k8s-device-plugin">NVIDIA/k8s-device-plugin</a> 来使得节点上的 GPU 能够被 k8s 感知到。</p>

<p>这个 device plugin 主要做两件事：</p>

<ul>
<li>1）检测节点上的 GPU 设备并上报给 Kubelet，再由 Kubelet 更新节点信息时提交到 kube-apiserver。

<ul>
<li>这样 k8s 就知道每个节点上有多少 GPU 了，后续 Pod 申请 GPU 时就会往有 GPU 资源的节点上调度。</li>
</ul></li>
<li>2）Pod 申请 GPU 时，为对应容器添加一个NVIDIA_VISIBLE_DEVICES环境变量，后续底层 Runtime 在真正创建容器时就能根据这些信息把 GPU 挂载到容器中

<ul>
<li>例如添加环境变量：NVIDIA_VISIBLE_DEVICES=GPU-03f69c50-207a-2038-9b45-23cac89cb67d
<br /></li>
</ul></li>
</ul>

<p>NVIDIA 这个 device plugin 比较复杂，支持多种策略，device plugin 提供的 env、mounts、device 以及 annotations 等方式它都做了支持，在部署时可以通过 DEVICE_LIST_STRATEGY 环境变量进行指定，不过默认还是用的 env。</p>

<p>另外DEVICE_ID_STRATEGY 默认也是 uuid，因此在 Pod 中看到的 NVIDIA_VISIBLE_DEVICES 就不是 Docker 环境中常见的 0,1,2 这种编号了，而是 GPU 设备对应的 UUID。</p>

<h2 id="2-2-gpu-是如何分配给-pod-的">2.2. GPU 是如何分配给 Pod 的</h2>

<p>NVIDIA 提供了 nvidia-container-toolkit 来处理如何将 GPU 分配给容器的问题。</p>

<p>核心组件有以下三个：</p>

<ul>
<li>nvidia-container-runtime</li>
<li>nvidia-container-runtime-hook</li>
<li>nvidia-container-cli</li>
</ul>

<p>首先需要将 docker/containerd 的 runtime 设置为nvidia-container-runtime，此后整个调用链就变成这样了：</p>

<p><img src="post/2024/images/2024-01-27-pod-use-gpu/IMG_20250127-192425835.png" alt="picture 0" /></p>

<p>接下来就具体分析每个组件的作用。</p>

<h3 id="2-2-1-nvidia-container-runtime">2.2.1. nvidia-container-runtime</h3>

<p>nvidia-container-runtime 的作用就是负责在容器启动之前，将 nvidia-container-runtime-hook 注入到 prestart hook。
&gt; 小知识：docker/containerd 都是高级 Runtime，runC 则是低级 Runtime。不同层级 Runtime 通过 OCI Spec 进行交互。</p>

<p>也就是说 docker 调用 runC 创建容器时，会把 docker 收到的信息解析，组装成 OCI Spec，然后在往下传递。</p>

<p><strong>而 nvidia-container-runtime 的作用就是修改容器 Spec，往里面添加一个 prestart hook，这个 hook 就是 nvidia-container-runtime-hook 。</strong></p>

<p>这样 runC 根据 Spec 启动容器时就会执行该 hook，即执行 nvidia-container-runtime-hook。</p>

<p>也就是说 nvidia-container-runtime 其实没有任何逻辑，真正的逻辑都在 nvidia-container-runtime-hook 中。</p>

<h3 id="2-2-2-nvidia-container-runtime-hook">2.2.2. nvidia-container-runtime-hook</h3>

<p>nvidia-container-runtime-hook 包含了给容器分配 GPU 的核心逻辑，主要分为两部分：</p>

<ul>
<li>1）从容器 Spec 的 mounts 和 env 中解析 GPU 信息

<ul>
<li>mounts 对应前面 device plugin 中设置的 Mount 和 Device，env 则对应 Env</li>
</ul></li>
<li>2）调用 nvidia-container-cli configure 命令，保证容器内可以使用被指定的 GPU 以及对应能力

<ul>
<li>也就是说nvidia-container-runtime-hook 最终还是调用 nvidia-container-cli 来实现的给容器分配 GPU 能力的。
<br /></li>
</ul></li>
</ul>

<h3 id="2-2-3-nvidia-container-cli">2.2.3. nvidia-container-cli</h3>

<p>nvidia-container-cli 是一个命令行工具，用于配置 Linux 容器对 GPU 硬件的使用。</p>

<p>提供了三个命令</p>

<ul>
<li>list: 打印 nvidia 驱动库及路径</li>
<li>info: 打印所有Nvidia GPU设备</li>
<li>configure： 进入给定进程的命名空间，执行必要操作保证容器内可以使用被指定的 GPU 以及对应能力（指定 NVIDIA 驱动库）
<img src="post/2024/images/2024-01-27-pod-use-gpu/IMG_20250130-215950804.png" alt="picture 3" /><br /></li>
</ul>

<p>一般主要使用 configure 命令，它将 NVIDIA GPU Driver、CUDA Driver 等 驱动库的 so 文件 和 GPU 设备信息， 通过文件挂载的方式映射到容器中。</p>

<h2 id="2-3-小结">2.3. 小结</h2>

<p>整个流程如下：</p>

<ul>
<li>1）device plugin 上报节点上的 GPU 信息</li>
<li>2）用户创建 Pod，在 resources.rquest 中申请 GPU，Scheduler 根据各节点 GPU 资源情况，将 Pod 调度到一个有足够 GPU 的节点</li>
<li>3）DevicePlugin 根据 Pod 中申请的 GPU 资源，为容器添加 Env 和 Devices 配置

<ul>
<li>例如添加环境变量：NVIDIA_VISIBLE_DEVICES=GPU-03f69c50-207a-2038-9b45-23cac89cb67d</li>
</ul></li>

<li><p>4）docker / containerd 启动容器</p>

<ul>
<li>由于配置了 nvidia-container-runtime,因此会使用 nvidia-container-runtime 来创建容器</li>
<li>nvidia-container-runtime 额外做了一件事：将 nvidia-container-runtime-hook 作为 prestart hook 添加到容器 spec 中，然后就将容器 spec 信息往后传给 runC 了。</li>
<li>runC 创建容器前会调用 prestart hook，其中就包括了上一步添加的 nvidia-container-runtime-hook，该 hook 主要做两件事：

<ul>
<li>从容器 Spec 的 mounts 或者 env 中解析 GPU 信息</li>
<li>调用 nvidia-container-cli configure 命令，将 NVIDIA 的 GPU Driver、CUDA Driver 等库文件挂载进容器，保证容器内可以使用被指定的 GPU以及对应能力
以上就是在 k8s 中使用 NVIDIA GPU 的流程，简单来说就是：</li>
</ul></li>
</ul></li>

<li><p>1）device plugin 中根据 pod 申请的 GPU 资源分配 GPU，并以 ENV 环境变量方式添加到容器上。</p></li>

<li><p>2）nvidia-container-toolkit 则根据该 Env 拿到要分配给该容器的 GPU 最终把相关文件挂载到容器里
当然并不是只有这一种实现方法，比如天数的 ix-device-plugin 实现中就没有提供自己的 container-toolkit，只在 device plugin 中通过 Device 指定要挂载哪些设备,这样容器启动时也会把这些设备挂载到容器中：</p></li>
</ul>

<pre><code class="language-go">func (p *iluvatarDevicePlugin) allocateDevicesByDeviceID(hostminor uint, num int) *pluginapi.DeviceSpec {
	var device pluginapi.DeviceSpec

	hostPathPrefix := &quot;/dev/&quot;
	containerPathPrefix := &quot;/dev/&quot;

	// Expose the device node for iluvatar pod.
	device.HostPath = hostPathPrefix + deviceName + strconv.Itoa(int(hostminor))
	device.ContainerPath = containerPathPrefix + deviceName + strconv.Itoa(num)
	device.Permissions = &quot;rw&quot;

	return &amp;device
}
</code></pre>

<p>不过由于没有挂载驱动进去，因此需要容器内自带驱动才行。</p>

<p>至此，已经分析了 k8s 创建 Pod 使用 GPU 的整个流程及大致原理，接下来简单分析下相关组件源码。</p>

<h1 id="3-device-plugin-源码分析">3. device plugin 源码分析</h1>

<p>NVIDIA GPU 对应的 device plugin 叫做：<a href="https://github.com/NVIDIA/k8s-device-plugin">NVIDIA/k8s-device-plugin</a></p>

<h2 id="3-1-allocate-方法">3.1. Allocate 方法</h2>

<p>主要看为容器分配资源的 Allocate 方法</p>

<pre><code class="language-go">// https://github.com/NVIDIA/k8s-device-plugin/blob/main/internal/plugin/server.go#L319-L332

// Allocate which return list of devices.
func (plugin *NvidiaDevicePlugin) Allocate(ctx context.Context, reqs *pluginapi.AllocateRequest) (*pluginapi.AllocateResponse, error) {
        responses := pluginapi.AllocateResponse{}
        for _, req := range reqs.ContainerRequests {
                if err := plugin.rm.ValidateRequest(req.DevicesIDs); err != nil {
                        return nil, fmt.Errorf(&quot;invalid allocation request for %q: %w&quot;, plugin.rm.Resource(), err)
                }
                response, err := plugin.getAllocateResponse(req.DevicesIDs)
                if err != nil {
                        return nil, fmt.Errorf(&quot;failed to get allocate response: %v&quot;, err)
                }
                responses.ContainerResponses = append(responses.ContainerResponses, response)
        }

        return &amp;responses, nil
}
</code></pre>

<p>核心逻辑在 getAllocateResponse 中：</p>

<pre><code class="language-go">func (plugin *NvidiaDevicePlugin) getAllocateResponse(requestIds []string) (*pluginapi.ContainerAllocateResponse, error) {
	deviceIDs := plugin.deviceIDsFromAnnotatedDeviceIDs(requestIds)

	// Create an empty response that will be updated as required below.
	response := &amp;pluginapi.ContainerAllocateResponse{
		Envs: make(map[string]string),
	}
	if plugin.deviceListStrategies.AnyCDIEnabled() {
		responseID := uuid.New().String()
		if err := plugin.updateResponseForCDI(response, responseID, deviceIDs...); err != nil {
			return nil, fmt.Errorf(&quot;failed to get allocate response for CDI: %v&quot;, err)
		}
	}
	if plugin.config.Sharing.SharingStrategy() == spec.SharingStrategyMPS {
		plugin.updateResponseForMPS(response)
	}

	// The following modifications are only made if at least one non-CDI device
	// list strategy is selected.
	if plugin.deviceListStrategies.AllCDIEnabled() {
		return response, nil
	}

	if plugin.deviceListStrategies.Includes(spec.DeviceListStrategyEnvvar) {
		plugin.updateResponseForDeviceListEnvvar(response, deviceIDs...)
	}
	if plugin.deviceListStrategies.Includes(spec.DeviceListStrategyVolumeMounts) {
		plugin.updateResponseForDeviceMounts(response, deviceIDs...)
	}
	if *plugin.config.Flags.Plugin.PassDeviceSpecs {
		response.Devices = append(response.Devices, plugin.apiDeviceSpecs(*plugin.config.Flags.NvidiaDevRoot, requestIds)...)
	}
	if *plugin.config.Flags.GDSEnabled {
		response.Envs[&quot;NVIDIA_GDS&quot;] = &quot;enabled&quot;
	}
	if *plugin.config.Flags.MOFEDEnabled {
		response.Envs[&quot;NVIDIA_MOFED&quot;] = &quot;enabled&quot;
	}
	return response, nil
}
</code></pre>

<p>可以看到，根据不同 flag 以及策略分为不同的设置方式</p>

<pre><code class="language-go">// Constants to represent the various device list strategies
const (
	DeviceListStrategyEnvvar         = &quot;envvar&quot;
	DeviceListStrategyVolumeMounts   = &quot;volume-mounts&quot;
	DeviceListStrategyCDIAnnotations = &quot;cdi-annotations&quot;
	DeviceListStrategyCDICRI         = &quot;cdi-cri&quot;
)
</code></pre>

<p>东西比较多，我们主要看设置 Env 的策略</p>

<pre><code class="language-go">if plugin.deviceListStrategies.Includes(spec.DeviceListStrategyEnvvar) {
    plugin.updateResponseForDeviceListEnvvar(response, deviceIDs...)
}
</code></pre>

<p>核心如下：</p>

<pre><code class="language-go">// updateResponseForDeviceListEnvvar sets the environment variable for the requested devices.
func (plugin *NvidiaDevicePlugin) updateResponseForDeviceListEnvvar(response *pluginapi.ContainerAllocateResponse, deviceIDs ...string) {
        response.Envs[plugin.deviceListEnvvar] = strings.Join(deviceIDs, &quot;,&quot;)
}
</code></pre>

<p>可以看到，逻辑很简单，就是给容器添加了一个环境变量，value 为设备 id，具体 deviceID 提供了两种策略，可以是编号或者 uuid</p>

<pre><code class="language-go">const (
        DeviceIDStrategyUUID  = &quot;uuid&quot;
        DeviceIDStrategyIndex = &quot;index&quot;
)
</code></pre>

<p>key 是一个变量 plugin.deviceListEnvvar，初始化如下:</p>

<pre><code class="language-go">        plugin := NvidiaDevicePlugin{
                deviceListEnvvar:     &quot;NVIDIA_VISIBLE_DEVICES&quot;,
                socket:               pluginPath + &quot;.sock&quot;,
          // ...
        }
</code></pre>

<p>也就是说 NVIDIA 这个 device plugin 实现 Allocate 主要就是给容器增加了环境变量，例如：</p>

<pre><code class="language-go">NVIDIA_VISIBLE_DEVICES=GPU-03f69c50-207a-2038-9b45-23cac89cb67d
</code></pre>

<p>或者</p>

<pre><code class="language-go">NVIDIA_VISIBLE_DEVICES=1,2
</code></pre>

<h2 id="3-2-小结">3.2. 小结</h2>

<p>NVIDIA device plugin 核心逻辑就是给容器添加NVIDIA_VISIBLE_DEVICES 环境变量，告知后续组件，需要给该组件分配 GPU。</p>

<p>比如当我们仅使用 Docker 时就可以在启动容器时指定 GPU，&ndash;gpus flag 和 NVIDIA_VISIBLE_DEVICES 环境变量效果一致。</p>

<pre><code class="language-bash"># --gpus
docker run --gpus device=0 -it tensorflow/tensorflow:latest-gpu bash
# 或者环境变量 NVIDIA_VISIBLE_DEVICES
docker run -e NVIDIA_VISIBLE_DEVICES=0 -it tensorflow/tensorflow:latest-gpu bash
</code></pre>

<p>至于为什么添加了NVIDIA_VISIBLE_DEVICES 环境变量就会给该容器分配 GPU，就是接下来的 nvidi-container-toolkit 组件实现的。</p>

<blockquote>
<p>nvidia 在 device plugin 中也使用NVIDIA_VISIBLE_DEVICES 环境变量正好能够兼容 nvidia-container-toolkit。</p>
</blockquote>

<h1 id="4-nvidia-container-toolkit-源码分析">4. nvidia-container-toolkit 源码分析</h1>

<p>这部分我们主要分析，为什么添加了NVIDIA_VISIBLE_DEVICES 环境变量就会给该容器分配 GPU，nvidia-container-toolkit 中做了哪些处理。</p>

<p>nvidia-container-toolkit 包含以下 3 个部分：</p>

<ul>
<li>1）<a href="https://github.com/NVIDIA/nvidia-container-toolkit/tree/main/cmd/nvidia-container-runtime">nvidia-container-runtime</a></li>
<li>2）<a href="https://github.com/NVIDIA/nvidia-container-toolkit/tree/main/cmd/nvidia-container-runtime-hook">nvidia-container-runtime-hook</a></li>
<li>3）<a href="https://github.com/NVIDIA/libnvidia-container/tree/master/src/cli">nvidia-container-cli</a></li>
</ul>

<h2 id="4-1-nvidia-container-runtime">4.1. nvidia-container-runtime</h2>

<p>nvidia-container-runtime 可以看做是一个 docker/containerd 的底层 runtime（类似 runC），在模块在创建容器的整个调用链中处在如下位置：
<img src="post/2024/images/2024-01-27-pod-use-gpu/IMG_20250128-155337940.png" alt="picture 1" /></p>

<p>它只做一件事，就是在容器启动之前，将 nvidia-container-runtime-hook 注入到 prestart hook。
&gt; 以修改容器 Spec 的方式添加一个 prestart hook 进去</p>

<p>这样，后续 runC 使用容器 Spec 创建容器时就会执行该 prestart hook。</p>

<p>简单分析下源码，首先是启动命令：<a href="https://github.com/NVIDIA/nvidia-container-toolkit/blob/main/cmd/nvidia-container-runtime/main.go">nvidia-container-runtime/main.go</a></p>

<p>就是 New 了一个 nvidia runtime 对象，并执行其 Run 方法。</p>

<pre><code class="language-go">// https://github.com/NVIDIA/nvidia-container-toolkit/blob/main/cmd/nvidia-container-runtime/main.go#L9-L15

import (
    &quot;os&quot;

    &quot;github.com/NVIDIA/nvidia-container-toolkit/internal/runtime&quot;
)

func main() {
    r := runtime.New()
    err := r.Run(os.Args)
    if err != nil {
       os.Exit(1)
    }
}
</code></pre>

<p>具体的 New 方法也很简单，返回的是一个名为 Interface 的 Interface，包含一个 Run 方法</p>

<pre><code class="language-go">// https://github.com/NVIDIA/nvidia-containertoolkit/blob/main/internal/runtime/api.go#L17-L26

type rt struct {
    logger       *Logger
    modeOverride string
}

// Interface is the interface for the runtime library.
type Interface interface {
    Run([]string) error
}
func New(opts ...Option) Interface {
    r := rt{}
    for _, opt := range opts {
       opt(&amp;r)
    }
    if r.logger == nil {
       r.logger = NewLogger()
    }
    return &amp;r
}
</code></pre>

<p>Run 方法具体实现如下：</p>

<pre><code class="language-go">// https://github.com/NVIDIA/nvidia-container-toolkit/blob/main/internal/runtime/runtime.go#L34-L91

// Run is an entry point that allows for idiomatic handling of errors
// when calling from the main function.
func (r rt) Run(argv []string) (rerr error) {
    defer func() {
       if rerr != nil {
          r.logger.Errorf(&quot;%v&quot;, rerr)
       }
    }()

    printVersion := hasVersionFlag(argv)
    if printVersion {
       fmt.Printf(&quot;%v version %v\n&quot;, &quot;NVIDIA Container Runtime&quot;, info.GetVersionString(fmt.Sprintf(&quot;spec: %v&quot;, specs.Version)))
    }

    cfg, err := config.GetConfig()
    if err != nil {
       return fmt.Errorf(&quot;error loading config: %v&quot;, err)
    }
    r.logger.Update(
       cfg.NVIDIAContainerRuntimeConfig.DebugFilePath,
       cfg.NVIDIAContainerRuntimeConfig.LogLevel,
       argv,
    )
    defer func() {
       if rerr != nil {
          r.logger.Errorf(&quot;%v&quot;, rerr)
       }
       if err := r.logger.Reset(); err != nil {
          rerr = errors.Join(rerr, fmt.Errorf(&quot;failed to reset logger: %v&quot;, err))
       }
    }()

    // We apply some config updates here to ensure that the config is valid in
    // all cases.
    if r.modeOverride != &quot;&quot; {
       cfg.NVIDIAContainerRuntimeConfig.Mode = r.modeOverride
    }
    //nolint:staticcheck  // TODO(elezar): We should swith the nvidia-container-runtime from using nvidia-ctk to using nvidia-cdi-hook.
    cfg.NVIDIACTKConfig.Path = config.ResolveNVIDIACTKPath(&amp;logger.NullLogger{}, cfg.NVIDIACTKConfig.Path)
    cfg.NVIDIAContainerRuntimeHookConfig.Path = config.ResolveNVIDIAContainerRuntimeHookPath(&amp;logger.NullLogger{}, cfg.NVIDIAContainerRuntimeHookConfig.Path)

    // Log the config at Trace to allow for debugging if required.
    r.logger.Tracef(&quot;Running with config: %+v&quot;, cfg)

    driver := root.New(
       root.WithLogger(r.logger),
       root.WithDriverRoot(cfg.NVIDIAContainerCLIConfig.Root),
    )

    r.logger.Tracef(&quot;Command line arguments: %v&quot;, argv)
    runtime, err := newNVIDIAContainerRuntime(r.logger, cfg, argv, driver)
    if err != nil {
       return fmt.Errorf(&quot;failed to create NVIDIA Container Runtime: %v&quot;, err)
    }

    if printVersion {
       fmt.Print(&quot;\n&quot;)
    }
    return runtime.Exec(argv)
}
</code></pre>

<p>核心部分：</p>

<pre><code class="language-go">runtime, err := newNVIDIAContainerRuntime(r.logger, cfg, argv, driver)
if err != nil {
   return fmt.Errorf(&quot;failed to create NVIDIA Container Runtime: %v&quot;, err)
}

if printVersion {
   fmt.Print(&quot;\n&quot;)
}
return runtime.Exec(argv)
</code></pre>

<p>继续查看 newNVIDIAContainerRuntime 实现</p>

<pre><code class="language-go">// https://github.com/NVIDIA/nvidia-container-toolkit/blob/main/internal/runtime/runtime_factory.go#L32-L62

// newNVIDIAContainerRuntime is a factory method that constructs a runtime based on the selected configuration and specified logger
func newNVIDIAContainerRuntime(logger logger.Interface, cfg *config.Config, argv []string, driver *root.Driver) (oci.Runtime, error) {
    lowLevelRuntime, err := oci.NewLowLevelRuntime(logger, cfg.NVIDIAContainerRuntimeConfig.Runtimes)
    if err != nil {
       return nil, fmt.Errorf(&quot;error constructing low-level runtime: %v&quot;, err)
    }

    logger.Tracef(&quot;Using low-level runtime %v&quot;, lowLevelRuntime.String())
    if !oci.HasCreateSubcommand(argv) {
       logger.Tracef(&quot;Skipping modifier for non-create subcommand&quot;)
       return lowLevelRuntime, nil
    }

    ociSpec, err := oci.NewSpec(logger, argv)
    if err != nil {
       return nil, fmt.Errorf(&quot;error constructing OCI specification: %v&quot;, err)
    }

    specModifier, err := newSpecModifier(logger, cfg, ociSpec, driver)
    if err != nil {
       return nil, fmt.Errorf(&quot;failed to construct OCI spec modifier: %v&quot;, err)
    }

    // Create the wrapping runtime with the specified modifier.
    r := oci.NewModifyingRuntimeWrapper(
       logger,
       lowLevelRuntime,
       ociSpec,
       specModifier,
    )

    return r, nil
}
</code></pre>

<p>暂时只需要关注 specModifier 这个对象,就是它在修改容器的 spec 以添加 hook</p>

<pre><code class="language-go">// newSpecModifier is a factory method that creates constructs an OCI spec modifer based on the provided config.
func newSpecModifier(logger logger.Interface, cfg *config.Config, ociSpec oci.Spec, driver *root.Driver) (oci.SpecModifier, error) {
    rawSpec, err := ociSpec.Load()
    if err != nil {
       return nil, fmt.Errorf(&quot;failed to load OCI spec: %v&quot;, err)
    }

    image, err := image.NewCUDAImageFromSpec(rawSpec)
    if err != nil {
       return nil, err
    }

    mode := info.ResolveAutoMode(logger, cfg.NVIDIAContainerRuntimeConfig.Mode, image)
    modeModifier, err := newModeModifier(logger, mode, cfg, ociSpec, image)
    if err != nil {
       return nil, err
    }
    // For CDI mode we make no additional modifications.
    if mode == &quot;cdi&quot; {
       return modeModifier, nil
    }

    graphicsModifier, err := modifier.NewGraphicsModifier(logger, cfg, image, driver)
    if err != nil {
       return nil, err
    }

    featureModifier, err := modifier.NewFeatureGatedModifier(logger, cfg, image)
    if err != nil {
       return nil, err
    }

    modifiers := modifier.Merge(
       modeModifier,
       graphicsModifier,
       featureModifier,
    )
    return modifiers, nil
}
</code></pre>

<p>修改 hook 的 modifier 在 newModeModifier 里面</p>

<pre><code class="language-go">func newModeModifier(logger logger.Interface, mode string, cfg *config.Config, ociSpec oci.Spec, image image.CUDA) (oci.SpecModifier, error) {
    switch mode {
    case &quot;legacy&quot;:
       return modifier.NewStableRuntimeModifier(logger, cfg.NVIDIAContainerRuntimeHookConfig.Path), nil
    case &quot;csv&quot;:
       return modifier.NewCSVModifier(logger, cfg, image)
    case &quot;cdi&quot;:
       return modifier.NewCDIModifier(logger, cfg, ociSpec)
    }

    return nil, fmt.Errorf(&quot;invalid runtime mode: %v&quot;, cfg.NVIDIAContainerRuntimeConfig.Mode)
}
</code></pre>

<p>具体为 stableRuntimeModifier：</p>

<pre><code class="language-go">func (m stableRuntimeModifier) Modify(spec *specs.Spec) error {
    // If an NVIDIA Container Runtime Hook already exists, we don't make any modifications to the spec.
    if spec.Hooks != nil {
       for _, hook := range spec.Hooks.Prestart {
          hook := hook
          if isNVIDIAContainerRuntimeHook(&amp;hook) {
             m.logger.Infof(&quot;Existing nvidia prestart hook (%v) found in OCI spec&quot;, hook.Path)
             return nil
          }
       }
    }

    path := m.nvidiaContainerRuntimeHookPath
    m.logger.Infof(&quot;Using prestart hook path: %v&quot;, path)
    args := []string{filepath.Base(path)}
    if spec.Hooks == nil {
       spec.Hooks = &amp;specs.Hooks{}
    }
    spec.Hooks.Prestart = append(spec.Hooks.Prestart, specs.Hook{
       Path: path,
       Args: append(args, &quot;prestart&quot;),
    })

    return nil
}
</code></pre>

<p>核心部分：</p>

<pre><code class="language-go">path := m.nvidiaContainerRuntimeHookPath
spec.Hooks.Prestart = append(spec.Hooks.Prestart, specs.Hook{
   Path: path,
   Args: append(args, &quot;prestart&quot;),
})
</code></pre>

<p>可以看到，最终就是添加了一个 prestart hook，hook 的 path 就是 nvidia-container-runtime-hook 这个二进制文件的位置。</p>

<p>至此，nvidia-container-runtime 的工作就完成了，容器真正启动时，底层 runtime（比如 runC）检测到容器的 Spec 中有这个 hook 就会去执行了，最终 nvidia-container-runtime-hook 就会被运行了。</p>

<h2 id="4-2-nvidia-container-runtime-hook">4.2. nvidia-container-runtime-hook</h2>

<p>该组件则是 nvidia-container-toolkit 中的核心，所有的逻辑都在这里面实现。</p>

<p>主要做两件事：</p>

<ul>
<li>1）从容器的 env 中解析 GPU 信息</li>
<li>2）调用 nvidia-container-cli configure 命令，挂载相关文件，保证容器内可以使用被指定的GPU以及对应能力
也是先从启动命令看起：<a href="https://github.com/NVIDIA/nvidia-container-toolkit/blob/main/cmd/nvidia-container-runtime-hook/main.go">nvidia-container-runtime-hook/main.go</a></li>
</ul>

<pre><code class="language-go">switch args[0] {
case &quot;prestart&quot;:
    doPrestart()
    os.Exit(0)
case &quot;poststart&quot;:
    fallthrough
case &quot;poststop&quot;:
    os.Exit(0)
default:
    flag.Usage()
    os.Exit(2)
}
</code></pre>

<p>我们是添加的 prestart hook，因此会走 prestart 分支 执行doPrestart()方法。</p>

<pre><code class="language-go">func doPrestart() {
    var err error

    defer exit()
    log.SetFlags(0)

    hook, err := getHookConfig()
    if err != nil || hook == nil {
       log.Panicln(&quot;error getting hook config:&quot;, err)
    }
    cli := hook.NVIDIAContainerCLIConfig

    container := getContainerConfig(*hook)
    nvidia := container.Nvidia
    if nvidia == nil {
       // Not a GPU container, nothing to do.
       return
    }

    if !hook.NVIDIAContainerRuntimeHookConfig.SkipModeDetection &amp;&amp; info.ResolveAutoMode(&amp;logInterceptor{}, hook.NVIDIAContainerRuntimeConfig.Mode, container.Image) != &quot;legacy&quot; {
       log.Panicln(&quot;invoking the NVIDIA Container Runtime Hook directly (e.g. specifying the docker --gpus flag) is not supported. Please use the NVIDIA Container Runtime (e.g. specify the --runtime=nvidia flag) instead.&quot;)
    }

    rootfs := getRootfsPath(container)

    args := []string{getCLIPath(cli)}
    if cli.Root != &quot;&quot; {
       args = append(args, fmt.Sprintf(&quot;--root=%s&quot;, cli.Root))
    }
    if cli.LoadKmods {
       args = append(args, &quot;--load-kmods&quot;)
    }
    if cli.NoPivot {
       args = append(args, &quot;--no-pivot&quot;)
    }
    if *debugflag {
       args = append(args, &quot;--debug=/dev/stderr&quot;)
    } else if cli.Debug != &quot;&quot; {
       args = append(args, fmt.Sprintf(&quot;--debug=%s&quot;, cli.Debug))
    }
    if cli.Ldcache != &quot;&quot; {
       args = append(args, fmt.Sprintf(&quot;--ldcache=%s&quot;, cli.Ldcache))
    }
    if cli.User != &quot;&quot; {
       args = append(args, fmt.Sprintf(&quot;--user=%s&quot;, cli.User))
    }
    args = append(args, &quot;configure&quot;)

    if ldconfigPath := cli.NormalizeLDConfigPath(); ldconfigPath != &quot;&quot; {
       args = append(args, fmt.Sprintf(&quot;--ldconfig=%s&quot;, ldconfigPath))
    }
    if cli.NoCgroups {
       args = append(args, &quot;--no-cgroups&quot;)
    }
    if len(nvidia.Devices) &gt; 0 {
       args = append(args, fmt.Sprintf(&quot;--device=%s&quot;, nvidia.Devices))
    }
    if len(nvidia.MigConfigDevices) &gt; 0 {
       args = append(args, fmt.Sprintf(&quot;--mig-config=%s&quot;, nvidia.MigConfigDevices))
    }
    if len(nvidia.MigMonitorDevices) &gt; 0 {
       args = append(args, fmt.Sprintf(&quot;--mig-monitor=%s&quot;, nvidia.MigMonitorDevices))
    }
    if len(nvidia.ImexChannels) &gt; 0 {
       args = append(args, fmt.Sprintf(&quot;--imex-channel=%s&quot;, nvidia.ImexChannels))
    }

    for _, cap := range strings.Split(nvidia.DriverCapabilities, &quot;,&quot;) {
       if len(cap) == 0 {
          break
       }
       args = append(args, capabilityToCLI(cap))
    }

    for _, req := range nvidia.Requirements {
       args = append(args, fmt.Sprintf(&quot;--require=%s&quot;, req))
    }

    args = append(args, fmt.Sprintf(&quot;--pid=%s&quot;, strconv.FormatUint(uint64(container.Pid), 10)))
    args = append(args, rootfs)

    env := append(os.Environ(), cli.Environment...)
    //nolint:gosec // TODO: Can we harden this so that there is less risk of command injection?
    err = syscall.Exec(args[0], args, env)
    log.Panicln(&quot;exec failed:&quot;, err)
}
</code></pre>

<p>我们只需要关注下面这个就行</p>

<pre><code class="language-go">args := []string{getCLIPath(cli)}
container := getContainerConfig(*hook)
err = syscall.Exec(args[0], args, env)
</code></pre>

<p>一个是 getContainerConfig 解析容器配置 ，另一个就是 exec 真正开始执行命令。</p>

<blockquote>
<p>这里执行的命令其实就是 nvidia-container-cli</p>
</blockquote>

<h3 id="4-2-1-getcontainerconfig">4.2.1. getContainerConfig</h3>

<p>这部分就是解析 Env 拿到要分配给该容器的 GPU，如果没有 NVIDIA_VISIBLE_DEVICES 环境变量就不会做任何事情。</p>

<pre><code class="language-go">func getContainerConfig(hook HookConfig) (config containerConfig) {
    var h HookState
    d := json.NewDecoder(os.Stdin)
    if err := d.Decode(&amp;h); err != nil {
       log.Panicln(&quot;could not decode container state:&quot;, err)
    }

    b := h.Bundle
    if len(b) == 0 {
       b = h.BundlePath
    }

    s := loadSpec(path.Join(b, &quot;config.json&quot;))

    image, err := image.New(
       image.WithEnv(s.Process.Env),
       image.WithDisableRequire(hook.DisableRequire),
    )
    if err != nil {
       log.Panicln(err)
    }

    privileged := isPrivileged(s)
    return containerConfig{
       Pid:    h.Pid,
       Rootfs: s.Root.Path,
       Image:  image,
       Nvidia: getNvidiaConfig(&amp;hook, image, s.Mounts, privileged),
    }
}
</code></pre>

<p>构建了一个 image 对象，注意这里把 ENV 也传进去了</p>

<blockquote>
<p>之前说了需要给容器分配什么 GPU 是通过 NVIDIA_VISIBLE_DEVICES 环境变量指定的</p>
</blockquote>

<pre><code class="language-go">image, err := image.New(
    image.WithEnv(s.Process.Env),
    image.WithDisableRequire(hook.DisableRequire),
)
</code></pre>

<p>然后解析配置</p>

<pre><code class="language-go">func getNvidiaConfig(hookConfig *HookConfig, image image.CUDA, mounts []Mount, privileged bool) *nvidiaConfig {
    legacyImage := image.IsLegacy()

    var devices string
    if d := getDevices(hookConfig, image, mounts, privileged); d != nil {
       devices = *d
    } else {
       // 'nil' devices means this is not a GPU container.
       return nil
    }

    var migConfigDevices string
    if d := getMigConfigDevices(image); d != nil {
       migConfigDevices = *d
    }
    if !privileged &amp;&amp; migConfigDevices != &quot;&quot; {
       log.Panicln(&quot;cannot set MIG_CONFIG_DEVICES in non privileged container&quot;)
    }

    var migMonitorDevices string
    if d := getMigMonitorDevices(image); d != nil {
       migMonitorDevices = *d
    }
    if !privileged &amp;&amp; migMonitorDevices != &quot;&quot; {
       log.Panicln(&quot;cannot set MIG_MONITOR_DEVICES in non privileged container&quot;)
    }

    var imexChannels string
    if c := getImexChannels(image); c != nil {
       imexChannels = *c
    }

    driverCapabilities := hookConfig.getDriverCapabilities(image, legacyImage).String()

    requirements, err := image.GetRequirements()
    if err != nil {
       log.Panicln(&quot;failed to get requirements&quot;, err)
    }

    return &amp;nvidiaConfig{
       Devices:            devices,
       MigConfigDevices:   migConfigDevices,
       MigMonitorDevices:  migMonitorDevices,
       ImexChannels:       imexChannels,
       DriverCapabilities: driverCapabilities,
       Requirements:       requirements,
    }
}
</code></pre>

<p>核心是 getDevice，就是根据 Mounts 信息或者 Env 解析要分配给该容器的 GPU</p>

<pre><code class="language-go">func getDevices(hookConfig *HookConfig, image image.CUDA, mounts []Mount, privileged bool) *string {
    // If enabled, try and get the device list from volume mounts first
    if hookConfig.AcceptDeviceListAsVolumeMounts {
       devices := getDevicesFromMounts(mounts)
       if devices != nil {
          return devices
       }
    }

    // Fallback to reading from the environment variable if privileges are correct
    devices := getDevicesFromEnvvar(image, hookConfig.getSwarmResourceEnvvars())
    if devices == nil {
       return nil
    }
    if privileged || hookConfig.AcceptEnvvarUnprivileged {
       return devices
    }

    configName := hookConfig.getConfigOption(&quot;AcceptEnvvarUnprivileged&quot;)
    log.Printf(&quot;Ignoring devices specified in NVIDIA_VISIBLE_DEVICES (privileged=%v, %v=%v) &quot;, privileged, configName, hookConfig.AcceptEnvvarUnprivileged)

    return nil
}
</code></pre>

<p>可以看到这里根据配置不同，提供了两种解析 devices 的方法：</p>

<ul>
<li>getDevicesFromMounts</li>
<li>getDevicesFromEnvvar
这也就是为什么 nvidia device plugin 除了实现 Env 之外还实现了另外的方式，二者配置应该要对应才行。</li>
</ul>

<p>这里我们只关注 getDevicesFromEnvvar，从环境变量里解析 Device：</p>

<pre><code class="language-go">envNVVisibleDevices     = &quot;NVIDIA_VISIBLE_DEVICES&quot;

func getDevicesFromEnvvar(image image.CUDA, swarmResourceEnvvars []string) *string {
	// We check if the image has at least one of the Swarm resource envvars defined and use this
	// if specified.
	var hasSwarmEnvvar bool
	for _, envvar := range swarmResourceEnvvars {
		if image.HasEnvvar(envvar) {
			hasSwarmEnvvar = true
			break
		}
	}

	var devices []string
	if hasSwarmEnvvar {
		devices = image.DevicesFromEnvvars(swarmResourceEnvvars...).List()
	} else {
		devices = image.DevicesFromEnvvars(envNVVisibleDevices).List()
	}

	if len(devices) == 0 {
		return nil
	}

	devicesString := strings.Join(devices, &quot;,&quot;)

	return &amp;devicesString
}
</code></pre>

<p>核心如下：</p>

<pre><code class="language-go">devices = image.DevicesFromEnvvars(envNVVisibleDevices).List()
</code></pre>

<p>从 image 里面提取NVIDIA_VISIBLE_DEVICES环境变量，至于这个 Env 是哪里来的，也是容器 Spec 中定义的，之前 image 是这样初始化的：</p>

<pre><code class="language-go">s := loadSpec(path.Join(b, &quot;config.json&quot;))

	image, err := image.New(
		image.WithEnv(s.Process.Env), // 这里把容器 env 传给了 image 对象
		image.WithDisableRequire(hook.DisableRequire),
	)
</code></pre>

<p>实际这里还有一个特殊逻辑：<em>如果没有设置 NVIDIA_VISIBLE_DEVICES环境变量，也没通过其他方式解析到 device 并且还是是一个 legacy image，那么默认使用全部 GPU。</em></p>

<pre><code class="language-go">// Environment variable unset with legacy image: default to &quot;all&quot;.
if !isSet &amp;&amp; len(devices) == 0 &amp;&amp; i.IsLegacy() {
  return NewVisibleDevices(&quot;all&quot;)
}
</code></pre>

<p>那么什么算是 legacy image 呢：</p>

<pre><code class="language-go">// IsLegacy returns whether the associated CUDA image is a &quot;legacy&quot; image. An
// image is considered legacy if it has a CUDA_VERSION environment variable defined
// and no NVIDIA_REQUIRE_CUDA environment variable defined.
func (i CUDA) IsLegacy() bool {
	legacyCudaVersion := i.env[envCUDAVersion]
	cudaRequire := i.env[envNVRequireCUDA]
	return len(legacyCudaVersion) &gt; 0 &amp;&amp; len(cudaRequire) == 0
}
</code></pre>

<p>这也就是为什么，有时候启动 Pod 并没有申请 GPU，但是 Pod 里面依旧可以看到所有 GPU，就是走了这个 legacy image 的分支逻辑。</p>

<p>至此，我们知道了这边 runtime 是怎么指定要把哪些 GPU 分配给容器了，接下来进入 Exec 逻辑。</p>

<h3 id="4-2-2-exec">4.2.2. Exec</h3>

<p>Exec 部分比较短，就是这两行代码：</p>

<pre><code class="language-go">args := []string{getCLIPath(cli)}
err = syscall.Exec(args[0], args, env)
</code></pre>

<p>首先是 getCLIPath，用于寻找 nvidia-container-cli 工具的位置并作为第一个参数。</p>

<pre><code class="language-go">func getCLIPath(config config.ContainerCLIConfig) string {
    if config.Path != &quot;&quot; {
       return config.Path
    }

    if err := os.Setenv(&quot;PATH&quot;, lookup.GetPath(config.Root)); err != nil {
       log.Panicln(&quot;couldn't set PATH variable:&quot;, err)
    }

    path, err := exec.LookPath(&quot;nvidia-container-cli&quot;)
    if err != nil {
       log.Panicln(&quot;couldn't find binary nvidia-container-cli in&quot;, os.Getenv(&quot;PATH&quot;), &quot;:&quot;, err)
    }
    return path
}
</code></pre>

<p>可以看到，如果单独配置了 cli 的位置参数就使用配置的位置，否则使用 LookPath 根据名字寻找。</p>

<p>然后是相关的参数</p>

<pre><code class="language-go">    args := []string{getCLIPath(cli)}
    if cli.Root != &quot;&quot; {
       args = append(args, fmt.Sprintf(&quot;--root=%s&quot;, cli.Root))
    }
    if cli.LoadKmods {
       args = append(args, &quot;--load-kmods&quot;)
    }
    if cli.NoPivot {
       args = append(args, &quot;--no-pivot&quot;)
    }
    if *debugflag {
       args = append(args, &quot;--debug=/dev/stderr&quot;)
    } else if cli.Debug != &quot;&quot; {
       args = append(args, fmt.Sprintf(&quot;--debug=%s&quot;, cli.Debug))
    }
    if cli.Ldcache != &quot;&quot; {
       args = append(args, fmt.Sprintf(&quot;--ldcache=%s&quot;, cli.Ldcache))
    }
    if cli.User != &quot;&quot; {
       args = append(args, fmt.Sprintf(&quot;--user=%s&quot;, cli.User))
    }
    args = append(args, &quot;configure&quot;)

    if ldconfigPath := cli.NormalizeLDConfigPath(); ldconfigPath != &quot;&quot; {
       args = append(args, fmt.Sprintf(&quot;--ldconfig=%s&quot;, ldconfigPath))
    }
    if cli.NoCgroups {
       args = append(args, &quot;--no-cgroups&quot;)
    }
    if len(nvidia.Devices) &gt; 0 {
       args = append(args, fmt.Sprintf(&quot;--device=%s&quot;, nvidia.Devices))
    }
    if len(nvidia.MigConfigDevices) &gt; 0 {
       args = append(args, fmt.Sprintf(&quot;--mig-config=%s&quot;, nvidia.MigConfigDevices))
    }
    if len(nvidia.MigMonitorDevices) &gt; 0 {
       args = append(args, fmt.Sprintf(&quot;--mig-monitor=%s&quot;, nvidia.MigMonitorDevices))
    }
    if len(nvidia.ImexChannels) &gt; 0 {
       args = append(args, fmt.Sprintf(&quot;--imex-channel=%s&quot;, nvidia.ImexChannels))
    }

    for _, cap := range strings.Split(nvidia.DriverCapabilities, &quot;,&quot;) {
       if len(cap) == 0 {
          break
       }
       args = append(args, capabilityToCLI(cap))
    }

    for _, req := range nvidia.Requirements {
       args = append(args, fmt.Sprintf(&quot;--require=%s&quot;, req))
    }

    args = append(args, fmt.Sprintf(&quot;--pid=%s&quot;, strconv.FormatUint(uint64(container.Pid), 10)))
    args = append(args, rootfs)

    env := append(os.Environ(), cli.Environment...)
</code></pre>

<p>其中</p>

<pre><code class="language-go">args = append(args, &quot;configure&quot;)
</code></pre>

<p>表示执行的是nvidia-container-cli configure 命令。</p>

<p>最后则是调用 syscall.Exec 真正开始执行命令</p>

<pre><code class="language-go">err = syscall.Exec(args[0], args, env)
</code></pre>

<p>该命令具体在做什么呢，接着分析 nvidia-container-cli 实现。</p>

<h2 id="4-3-nvidia-container-cli">4.3. nvidia-container-cli</h2>

<p><a href="https://github.com/NVIDIA/libnvidia-container/tree/master/src/cli">nvidia-container-cli</a> 是一个 C 写的小工具，主要作用就是根据上执行命令时传递的参数，把GPU 设备及其相关依赖库挂载到容器中，使得容器能够正常使用 GPU 能力。</p>

<p>简单看下部分代码。</p>

<p>首先是驱动信息：</p>

<pre><code class="language-c">// https://github.com/NVIDIA/libnvidia-container/blob/master/src/cli/configure.c#L279-L288

/* Query the driver and device information. */
if (perm_set_capabilities(&amp;err, CAP_EFFECTIVE, ecaps[NVC_INFO], ecaps_size(NVC_INFO)) &lt; 0) {
        warnx(&quot;permission error: %s&quot;, err.msg);
        goto fail;
}
if ((drv = libnvc.driver_info_new(nvc, NULL)) == NULL ||
    (dev = libnvc.device_info_new(nvc, NULL)) == NULL) {
        warnx(&quot;detection error: %s&quot;, libnvc.error(nvc));
        goto fail;
}
</code></pre>

<ul>
<li>nvc_driver_info_new()：获取 CUDA Driver 信息</li>
<li>nvc_device_info_new()：获取 GPU Drvier 信息
<br /></li>
</ul>

<p>然后获取容器中可见的 GPU 列表</p>

<pre><code class="language-c">// https://github.com/NVIDIA/libnvidia-container/blob/master/src/cli/configure.c#L308-L314

        /* Select the visible GPU devices. */
        if (dev-&gt;ngpus &gt; 0) {
                if (select_devices(&amp;err, ctx-&gt;devices, dev, &amp;devices) &lt; 0) {
                        warnx(&quot;device error: %s&quot;, err.msg);
                        goto fail;
                }
        }
</code></pre>

<p>最后则是将相关驱动挂载到容器里去：</p>

<pre><code class="language-c">// https://github.com/NVIDIA/libnvidia-container/blob/master/src/cli/configure.c#L362-L408

/* Mount the driver, visible devices, mig-configs and mig-monitors. */
if (perm_set_capabilities(&amp;err, CAP_EFFECTIVE, ecaps[NVC_MOUNT], ecaps_size(NVC_MOUNT)) &lt; 0) {
        warnx(&quot;permission error: %s&quot;, err.msg);
        goto fail;
}
if (libnvc.driver_mount(nvc, cnt, drv) &lt; 0) {
        warnx(&quot;mount error: %s&quot;, libnvc.error(nvc));
        goto fail;
}
for (size_t i = 0; i &lt; devices.ngpus; ++i) {
        if (libnvc.device_mount(nvc, cnt, devices.gpus[i]) &lt; 0) {
                warnx(&quot;mount error: %s&quot;, libnvc.error(nvc));
                goto fail;
        }
}
</code></pre>

<p>libnvidia-container是采用 linux c mount &ndash;bind功能将 CUDA Driver Libraries/Binaries一个个挂载到容器里，而不是将整个目录挂载到容器中。</p>

<p>可通过NVIDIA_DRIVER_CAPABILITIES环境变量指定要挂载的 driver libraries/binaries。</p>

<p>例如：</p>

<pre><code class="language-bash">docker run -e NVIDIA_VISIBLE_DEVICES=0,1 -e NVIDIA_DRIVER_CAPABILITIES=compute,utility -it tensorflow/tensorflow:latest-gpu bash
</code></pre>

<p>指定NVIDIA_DRIVER_CAPABILITIES=compute,utility 就会把 compute 和 utility 相关的库挂载进去。</p>

<p>这样容器里就可以使用 GPU 了。</p>

<p>至此，相关源码就分析完成了。</p>

<h1 id="5-小结">5. 小结</h1>

<p>整个流程如下：</p>

<ul>
<li>1）device plugin 上报节点上的 GPU 信息</li>
<li>2）用户创建 Pod，在 resources.rquest 中申请 GPU，Scheduler 根据各节点 GPU 资源情况，将 Pod 调度到一个有足够 GPU 的节点</li>
<li>3）DevicePlugin 根据 Pod 中申请的 GPU 资源，为容器添加NVIDIA_VISIBLE_DEVICES环境变量
 &gt; 例如：NVIDIA_VISIBLE_DEVICES=GPU-03f69c50-207a-2038-9b45-23cac89cb67d</li>

<li><p>4）docker / containerd 启动容器</p>

<ul>
<li>由于配置了 nvidia-container-runtime,因此会使用 nvidia-container-runtime 来创建容器</li>
<li>nvidia-container-runtime 额外做了一件事：将 nvidia-container-runtime-hook 作为 prestart hook 添加到容器 spec 中，然后就将容器 spec 信息往后传给 runC 了。</li>
<li>runC 创建容器前会调用 prestart hook，其中就包括了上一步添加的 nvidia-container-runtime-hook，该 hook 主要做两件事：

<ul>
<li>从容器 Spec 的 mounts 或者 env 中解析 GPU 信息</li>
<li>调用 nvidia-container-cli 命令，将 NVIDIA 的 GPU Driver、CUDA Driver 等库文件挂载进容器，保证容器内可以使用被指定的 GPU以及对应能力
核心就是两个部分：</li>
</ul></li>
</ul></li>

<li><p>device plugin 根据 GPU 资源申请为容器添加 NVIDIA_VISIBLE_DEVICES环境变量</p></li>

<li><p>nvidia-container-toolkit 则是根据 NVIDIA_VISIBLE_DEVICES环境变量将 GPU、驱动等相关文件挂载到容器里。
看源码同时顺带解决了一个，之前遇到过的问题：<em>为什么 Pod 明明没有申请 GPU，启动后也能看到所有 GPU？</em></p></li>
</ul>

<p>这是因为 nvidia-container-toolkit 中存在特殊逻辑，没有设置 NVIDIA_VISIBLE_DEVICES环境变量，也没通过其他方式解析到 device 并且还是一个 legacy image，那么默认会返回all，即：NVIDIA_VISIBLE_DEVICES=all ，因此该 Pod 能看到全部 GPU。</p>

    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
  <div style="float:right;margin-top:0px;">
    <img src="/img/qrcode.jpg" width="129px" height="129px"/>
    <div style="text-align:center;">微信扫一扫</div>
  </div>
  <div style="float:left;margin-top:0px;">
    <img src="/img/rewardcode.jpg" width="129px" height="129px"/>
  </div>
  <div>
    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.mospan.cn/">mospan</a>
      <br />微信关注：墨斯潘園
      <br />本文出处：<a target="_blank" href="http://mospany.github.io/2024/01/27/pod-use-gpu/">http://mospany.github.io/2024/01/27/pod-use-gpu/</a>
      <br />
      文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
  </div>
</div>


	</div>
  <footer class="article-footer clearfix">
  

<div class="article-tags">
  <span></span>
  
  <a href="/tags/k8s">K8S</a>
  
  <a href="/tags/gpu">GPU</a>
  
</div>



<div class="article-categories">
  <span></span>
  
  <a class="article-category-link" href="/categories/k8s">K8S</a>
  
  <a class="article-category-link" href="/categories/gpu">GPU</a>
  
</div>



  <div class="article-share" id="share">
    <div data-url="http://mospany.github.io/2024/01/27/pod-use-gpu/" data-title="K8S项目实践(11): Pod 是如何使用到 GPU 的及源码分析" data-tsina="3833537679" class="share clearfix">
    </div>
  </div>
</footer>

	</article>
  





<div id="git-comments"></div>
<link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
<script src="https://billts.site/js/gitment.js"></script>
<script>
var gitment = new Gitment({
  id: '<%= page.date %>',
  owner: 'mospany',
  repo: 'mospan-hugo-blog-gitment',
  oauth: {
    client_id: '0cafe299c964f0af2d1e',
    client_secret: 'ec47ee9481210935a662298791c31da203694a8f',
  },
})
gitment.render('git-comments')
</script>    


</div>

    <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>
<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">
  

<div class="categorieslist">
  <p class="asidetitle">分类</p>
  <ul>
    
    <li><a href="http://mospany.github.io/categories/%e4%ba%91%e8%ae%a1%e7%ae%97" title="云计算">云计算<sup>6</sup></a></li>
    
    <li><a href="http://mospany.github.io/categories/%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd" title="人工智能">人工智能<sup>6</sup></a></li>
    
    <li><a href="http://mospany.github.io/categories/%e5%b7%a5%e5%85%b7%e4%bd%bf%e7%94%a8" title="工具使用">工具使用<sup>3</sup></a></li>
    
    <li><a href="http://mospany.github.io/categories/%e6%8a%80%e6%9c%af%e6%96%87%e7%ab%a0" title="技术文章">技术文章<sup>42</sup></a></li>
    
    <li><a href="http://mospany.github.io/categories/%e7%94%9f%e6%b4%bb%e8%ae%b0%e5%bd%95" title="生活记录">生活记录<sup>1</sup></a></li>
    
    <li><a href="http://mospany.github.io/categories/%e8%81%8c%e5%9c%ba%e4%ba%ba%e7%94%9f" title="职场人生">职场人生<sup>1</sup></a></li>
    
    <li><a href="http://mospany.github.io/categories/%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0" title="读书笔记">读书笔记<sup>2</sup></a></li>
    
  </ul>
</div>



  

<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
      
			<li><a href="http://mospany.github.io/tags/" title=""><sup>6</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/dns" title="dns">dns<sup>2</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/dpdk" title="dpdk">dpdk<sup>2</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/emacs" title="emacs">emacs<sup>5</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/gpu" title="gpu">gpu<sup>5</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/hugo" title="hugo">hugo<sup>3</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/ipv6" title="ipv6">ipv6<sup>2</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/k8s" title="k8s">k8s<sup>19</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/linux" title="linux">linux<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/openresty" title="openresty">openresty<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/org-mode" title="org-mode">org-mode<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/pango" title="pango">pango<sup>2</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/redis" title="redis">redis<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/spacemacs" title="spacemacs">spacemacs<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/vim" title="vim">vim<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/vue" title="vue">vue<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/xns" title="xns">xns<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/yaml" title="yaml">yaml<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/%e4%ba%91%e8%ae%a1%e7%ae%97" title="云计算">云计算<sup>6</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/%e4%ba%92%e8%81%94%e7%bd%91" title="互联网">互联网<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/%e5%89%8d%e7%ab%af" title="前端">前端<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/%e5%8d%9a%e5%ae%a2" title="博客">博客<sup>7</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/%e5%ad%98%e5%82%a8" title="存储">存储<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/%e5%b7%a5%e5%85%b7" title="工具">工具<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/%e5%be%ae%e4%bf%a1" title="微信">微信<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/%e6%8a%80%e6%9c%af%e6%96%87%e7%ab%a0" title="技术文章">技术文章<sup>2</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/%e6%9e%b6%e6%9e%84" title="架构">架构<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/%e7%8b%ac%e7%ab%8b" title="独立">独立<sup>3</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/%e7%94%9f%e6%b4%bb%e8%ae%b0%e5%bd%95" title="生活记录">生活记录<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/%e8%81%8c%e5%9c%ba%e4%ba%ba%e7%94%9f" title="职场人生">职场人生<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0" title="读书笔记">读书笔记<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/%e9%82%ae%e7%ae%b1" title="邮箱">邮箱<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/%e9%9d%a2%e8%af%95" title="面试">面试<sup>1</sup></a></li>
      
			<li><a href="http://mospany.github.io/tags/%e9%a1%b9%e7%9b%ae%e5%ae%9e%e8%b7%b5" title="项目实践">项目实践<sup>4</sup></a></li>
      
		</ul>
</div>



    <div class="linkslist">
  <p class="asidetitle">我的关注</p>
    <ul>
          <li>
            	<a href="http://www.csdn.net/" target="_blank" title="中国软件开发网(CSDN)">中国软件开发网(CSDN)</a>
          </li>
          <li>
            	<a href="http://www.golangtc.com/" target="_blank" title="Golang中国">Golang中国</a>
          </li>
          <li>
            	<a href="http://blog.qiniu.com/" target="_blank" title="七牛团队博客">七牛团队博客</a>
          </li>
          <li>
            	<a href="http://csrd.aliapp.com/" target="_blank" title="阿里核心系统团队博客">阿里核心系统团队博客</a>
          </li>
          <li>
            	<a href="http://coolshell.cn/" target="_blank" title="酷壳－陈浩">酷壳－陈浩</a>
          </li>
          <li>
            	<a href="http://www.ruanyifeng.com/blog/" target="_blank" title="阮一峰的网络日志">阮一峰的网络日志</a>
          </li>
          <li>
            	<a href="https://blog.dandyweng.com/" target="_blank" title="homeschooler－翁天信的博客">homeschooler－翁天信的博客</a>
          </li>
          <li>
            	<a href="http://www.jeffjade.com/" target="_blank" title="晚晴幽草轩">晚晴幽草轩</a>
          </li>
          <li>
            	<a href="https://nicejade.github.io/index.html" target="_blank" title="天意人间舫">天意人间舫</a>
          </li>
    </ul>
</div>

    <div class="linkslist">
  <p class="asidetitle">在线书籍</p>
    <ul>
          <li>
            	<a href="https://docs.ruanjiadeng.com/gopl-zh/index.html" target="_blank" title="Go语言圣经（中文版）">Go语言圣经（中文版）</a>
          </li>
          <li>
            	<a href="http://studygolang.com/pkgdoc" target="_blank" title="Go语言标准库">Go语言标准库</a>
          </li>
          <li>
            	<a href="http://www.w3school.com.cn/" target="_blank" title="w3school 在线教程">w3school 在线教程</a>
          </li>
    </ul>
</div>

    <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
          <li>
            	<a href="http://www.cloudxns.net/" target="_blank" title="CloudXNS官网">CloudXNS官网</a>
          </li>
          <li>
            	<a href="http://www.chinatesters.com/" target="_blank" title="华夏评测师家园">华夏评测师家园</a>
          </li>
    </ul>
</div>

  
  <div class="archiveslist">
    <p class="asidetitle">归档</p>
    <ul class="archive-list">
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2024-01">2024年01月</a><span class="archive-list-count">16</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2023-06">2023年06月</a><span class="archive-list-count">2</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2023-03">2023年03月</a><span class="archive-list-count">2</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2023-01">2023年01月</a><span class="archive-list-count">3</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2022-12">2022年12月</a><span class="archive-list-count">3</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2022-11">2022年11月</a><span class="archive-list-count">2</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2022-10">2022年10月</a><span class="archive-list-count">2</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2022-09">2022年09月</a><span class="archive-list-count">7</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2019-11">2019年11月</a><span class="archive-list-count">3</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2019-10">2019年10月</a><span class="archive-list-count">8</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2019-08">2019年08月</a><span class="archive-list-count">4</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2019-02">2019年02月</a><span class="archive-list-count">3</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2018-02">2018年02月</a><span class="archive-list-count">3</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2017-08">2017年08月</a><span class="archive-list-count">4</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2017-07">2017年07月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2017-03">2017年03月</a><span class="archive-list-count">8</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2016-09">2016年09月</a><span class="archive-list-count">2</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2016-05">2016年05月</a><span class="archive-list-count">4</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2016-03">2016年03月</a><span class="archive-list-count">5</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2016-02">2016年02月</a><span class="archive-list-count">11</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#2016-01">2016年01月</a><span class="archive-list-count">6</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="http://mospany.github.io/post/#0001-01">0001年01月</a><span class="archive-list-count">1</span>
      </li>
      
    </ul>

  </div>


  

<div class="tagcloudlist">
  <p class="asidetitle">标签云</p>
  <div class="tagcloudlist clearfix">
    
    <a href="http://mospany.github.io/tags/" style="font-size: 12px;"></a>
    
    <a href="http://mospany.github.io/tags/dns" style="font-size: 12px;">dns</a>
    
    <a href="http://mospany.github.io/tags/dpdk" style="font-size: 12px;">dpdk</a>
    
    <a href="http://mospany.github.io/tags/emacs" style="font-size: 12px;">emacs</a>
    
    <a href="http://mospany.github.io/tags/gpu" style="font-size: 12px;">gpu</a>
    
    <a href="http://mospany.github.io/tags/hugo" style="font-size: 12px;">hugo</a>
    
    <a href="http://mospany.github.io/tags/ipv6" style="font-size: 12px;">ipv6</a>
    
    <a href="http://mospany.github.io/tags/k8s" style="font-size: 12px;">k8s</a>
    
    <a href="http://mospany.github.io/tags/linux" style="font-size: 12px;">linux</a>
    
    <a href="http://mospany.github.io/tags/openresty" style="font-size: 12px;">openresty</a>
    
    <a href="http://mospany.github.io/tags/org-mode" style="font-size: 12px;">org-mode</a>
    
    <a href="http://mospany.github.io/tags/pango" style="font-size: 12px;">pango</a>
    
    <a href="http://mospany.github.io/tags/redis" style="font-size: 12px;">redis</a>
    
    <a href="http://mospany.github.io/tags/spacemacs" style="font-size: 12px;">spacemacs</a>
    
    <a href="http://mospany.github.io/tags/vim" style="font-size: 12px;">vim</a>
    
    <a href="http://mospany.github.io/tags/vue" style="font-size: 12px;">vue</a>
    
    <a href="http://mospany.github.io/tags/xns" style="font-size: 12px;">xns</a>
    
    <a href="http://mospany.github.io/tags/yaml" style="font-size: 12px;">yaml</a>
    
    <a href="http://mospany.github.io/tags/%e4%ba%91%e8%ae%a1%e7%ae%97" style="font-size: 12px;">云计算</a>
    
    <a href="http://mospany.github.io/tags/%e4%ba%92%e8%81%94%e7%bd%91" style="font-size: 12px;">互联网</a>
    
    <a href="http://mospany.github.io/tags/%e5%89%8d%e7%ab%af" style="font-size: 12px;">前端</a>
    
    <a href="http://mospany.github.io/tags/%e5%8d%9a%e5%ae%a2" style="font-size: 12px;">博客</a>
    
    <a href="http://mospany.github.io/tags/%e5%ad%98%e5%82%a8" style="font-size: 12px;">存储</a>
    
    <a href="http://mospany.github.io/tags/%e5%b7%a5%e5%85%b7" style="font-size: 12px;">工具</a>
    
    <a href="http://mospany.github.io/tags/%e5%be%ae%e4%bf%a1" style="font-size: 12px;">微信</a>
    
    <a href="http://mospany.github.io/tags/%e6%8a%80%e6%9c%af%e6%96%87%e7%ab%a0" style="font-size: 12px;">技术文章</a>
    
    <a href="http://mospany.github.io/tags/%e6%9e%b6%e6%9e%84" style="font-size: 12px;">架构</a>
    
    <a href="http://mospany.github.io/tags/%e7%8b%ac%e7%ab%8b" style="font-size: 12px;">独立</a>
    
    <a href="http://mospany.github.io/tags/%e7%94%9f%e6%b4%bb%e8%ae%b0%e5%bd%95" style="font-size: 12px;">生活记录</a>
    
    <a href="http://mospany.github.io/tags/%e8%81%8c%e5%9c%ba%e4%ba%ba%e7%94%9f" style="font-size: 12px;">职场人生</a>
    
    <a href="http://mospany.github.io/tags/%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0" style="font-size: 12px;">读书笔记</a>
    
    <a href="http://mospany.github.io/tags/%e9%82%ae%e7%ae%b1" style="font-size: 12px;">邮箱</a>
    
    <a href="http://mospany.github.io/tags/%e9%9d%a2%e8%af%95" style="font-size: 12px;">面试</a>
    
    <a href="http://mospany.github.io/tags/%e9%a1%b9%e7%9b%ae%e5%ae%9e%e8%b7%b5" style="font-size: 12px;">项目实践</a>
    
  </div>
</div>



  
</aside>
</div>

  </div>
  <footer><div id="footer" >
  
  <div class="line">
    <span></span>
    <div style='background:no-repeat url("http://mospany.github.io/img/author.jpg") left top;-webkit-background-size:6.875em 6.875em;-moz-background-size:6.875em 6.875em;background-size:6.875em 6.875em;' class="author" ></div>
  </div>
  <div class="line">
    <div style='background:no-repeat url("http://mospany.github.io/img/qiniu_logo.jpg") left top;-webkit-background-size:6.875em 6.875em;-moz-background-size:6.875em 6.875em;background-size:6.875em 6.875em;' class="author" ></div>
  </div>
  <div class="line">
    <div style='background:no-repeat url("http://mospany.github.io/img/fastweb_logo.jpg") left top;-webkit-background-size:6.875em 6.875em;-moz-background-size:6.875em 6.875em;background-size:6.875em 6.875em;' class="author" ></div>
  </div>
  <div class="line">
    <div style='background:no-repeat url("http://mospany.github.io/img/leadsec_logo.jpg") left top;-webkit-background-size:6.875em 6.875em;-moz-background-size:6.875em 6.875em;background-size:6.875em 6.875em;' class="author" ></div>
  </div>
  <div class="line">
    <div style='background:no-repeat url("http://mospany.github.io/img/raisecom_logo.jpg") left top;-webkit-background-size:6.875em 6.875em;-moz-background-size:6.875em 6.875em;background-size:6.875em 6.875em;' class="author" ></div>
  </div>
  <div class="line">
    <div style='background:no-repeat url("http://mospany.github.io/img/jbt_logo.jpg") left top;-webkit-background-size:6.875em 6.875em;-moz-background-size:6.875em 6.875em;background-size:6.875em 6.875em;' class="author" ></div>
  </div>
  
  
  <div class="social-font clearfix">
    
    <a href="http://weibo.com/mospan" target="_blank" title="weibo"></a>
    
    
    <a href="https://twitter.com/mospan" target="_blank" title="twitter"></a>
    
    
    <a href="https://github.com/mospany" target="_blank" title="github"></a>
    
    
    <a href="https://www.facebook.com/mospan" target="_blank" title="facebook"></a>
    
    
    <a href="https://www.linkedin.com/mospan" target="_blank" title="linkedin"></a>
    
  </div>
  <p class="copyright">Powered by <a href="http://gohugo.io" target="_blank" title="hugo">hugo</a> and Theme by <a href="https://github.com/mospany/mospan-hugo-blog/tree/master/themes/hugo-panman-theme" target="_blank" title="hugo-panman-theme">hugo-panman-theme</a> © 2025
    
    <a href="http://mospany.github.io/" target="_blank" title="mospan">mospan</a>
    
  </p>
</div>
</footer>
  <script src="http://mospany.github.io/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
done = false;
$(document).ready(function(){
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize();
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  $('form.search').on('submit', function (event) {
    if (false === done) {
      event.preventDefault();
      var orgVal = $(this).find('#search').val();
      $(this).find('#search').val('site:http:\/\/mospany.github.io\/ ' + orgVal);
      done = true;
      $(this).submit();
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>

<script type="text/javascript">
$(document).ready(function(){
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});
</script>


<link rel="stylesheet" href="http://mospany.github.io/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="http://mospany.github.io/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
});
</script>




</body>
</html>
