<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Openresty on 墨斯潘園</title>
        <link>http://yanwushuang.github.io/tags/openresty/feed/index.xml</link>
        <language>zh-CN</language>
        <author>Mospan</author>
        <rights>Copyright (c) 2016, mospan; all rights reserved.</rights>
        <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
        
        <item>
            <title>openresty&#43;redis practices</title>
            <link>http://yanwushuang.github.io/2017/03/02/openresty&#43;redis-practices/</link>
            <pubDate>Thu, 02 Mar 2017 11:14:08 HKT</pubDate>
            <author>Mospan</author>
            <guid>http://yanwushuang.github.io/2017/03/02/openresty&#43;redis-practices/</guid>
            <description>&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;

&lt;h2 id=&#34;openresty安装&#34;&gt;openresty安装&lt;/h2&gt;

&lt;p&gt;详见 &lt;a href=&#34;https://openresty.org/cn/installation.html&#34; title=&#34;openresty安装&#34;&gt;openresty安装&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;redis安装&#34;&gt;redis安装&lt;/h2&gt;

&lt;p&gt;执行如下命令：&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC sh&lt;/p&gt;

&lt;p&gt;sudo apt-get update&lt;/p&gt;

&lt;p&gt;sudo apt-get install redis-server&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;详见 &lt;a href=&#34;http://www.jianshu.com/p/c8723b677304&#34; title=&#34;Ubuntu安装配置Redis&#34;&gt;Ubuntu安装配置Redis&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;编写api&#34;&gt;编写API&lt;/h1&gt;

&lt;p&gt;根据项目要求编写openresty+lua的增删改查API接口。&lt;/p&gt;

&lt;h1 id=&#34;测试&#34;&gt;测试&lt;/h1&gt;

&lt;h2 id=&#34;发送请求&#34;&gt;发送请求&lt;/h2&gt;

&lt;p&gt;使用curl命令发送http json请求:&lt;/p&gt;

&lt;p&gt;#+BEGIN_QUOTE&lt;/p&gt;

&lt;p&gt;root@bj94:~/dr302client# cat add.json&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;先写请求json&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&#34;www.example.com&#34;: {&lt;/p&gt;

&lt;p&gt;&#34;sub_domain&#34;: &#34;@&#34;,&lt;/p&gt;

&lt;p&gt;&#34;record_type&#34;: &#34;CNAME&#34;,&lt;/p&gt;

&lt;p&gt;&#34;record_line&#34;: &#34;all&#34;,&lt;/p&gt;

&lt;p&gt;&#34;record_line_id&#34;: &#34;00000000&#34;,&lt;/p&gt;

&lt;p&gt;&#34;value&#34;: &#34;all.china.qiniu.qnydns.com&#34;,&lt;/p&gt;

&lt;p&gt;&#34;mx&#34;: 1,&lt;/p&gt;

&lt;p&gt;&#34;ttl&#34;: 86400,&lt;/p&gt;

&lt;p&gt;&#34;status&#34;: &#34;enable&#34;,&lt;/p&gt;

&lt;p&gt;&#34;weight&#34;: 100&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;#+END_QUOTE&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC sh&lt;/p&gt;

&lt;p&gt;curl -i -H &#39;content-type: application/json&#39; -X POST -d @add.json http://dev.mgrconfig.api.qiniudns.com/qiniu/dr302/records/add&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;h2 id=&#34;回复响应&#34;&gt;回复响应&lt;/h2&gt;

&lt;p&gt;根据不同返回码表示操作结果。&lt;/p&gt;

&lt;p&gt;#+BEGIN_QUOTE -t&lt;/p&gt;

&lt;p&gt;root@bj94:~/dr302client# curl -i -H &#39;content-type: application/json&#39; -X POST -d @addA.json http://dev.mgrconfig.api.qiniudns.com/qiniu/dr302/records/add&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;执行命令：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;HTTP/1.1 200 OK&lt;/p&gt;

&lt;p&gt;Date: Thu, 09 Mar 2017 03:01:17 GMT&lt;/p&gt;

&lt;p&gt;Content-Type: text/plain&lt;/p&gt;

&lt;p&gt;Transfer-Encoding: chunked&lt;/p&gt;

&lt;p&gt;Connection: keep-alive&lt;/p&gt;

&lt;p&gt;Server: DR302-MGR&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;p&gt;&#34;status&#34;:{&lt;/p&gt;

&lt;p&gt;&#34;created_at&#34;:&#34;2017-03-09 11:01:17&#34;,&lt;/p&gt;

&lt;p&gt;&#34;code&#34;:0,&lt;/p&gt;

&lt;p&gt;&#34;message&#34;:&#34;success&#34;&lt;/p&gt;

&lt;p&gt;},&lt;/p&gt;

&lt;p&gt;&#34;record&#34;:{&lt;/p&gt;

&lt;p&gt;&#34;status&#34;:&#34;enable&#34;,&lt;/p&gt;

&lt;p&gt;&#34;key&#34;:&#34;www.example.com#all&#34;,&lt;/p&gt;

&lt;p&gt;&#34;name&#34;:&#34;@&#34;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;#+END_QUOTE&lt;/p&gt;

&lt;h2 id=&#34;查看存储&#34;&gt;查看存储&lt;/h2&gt;

&lt;p&gt;执行命令:&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC sh&lt;/p&gt;

&lt;p&gt;(echo  &#34;select 10&#34;; echo &#34;hgetall www.example.com#all&#34;) | redis-cli -a cdnfusion -p 7648&#34;&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;避免中文乱码，加--raw选项：&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC sh&lt;/p&gt;

&lt;p&gt;(echo  &#34;select 10&#34;; echo &#34;hgetall www.example.com#all&#34;) | redis-cli -a cdnfusion -p 7648 --raw&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;显示如下:&lt;/p&gt;

&lt;p&gt;#+BEGIN_QUOTE&lt;/p&gt;

&lt;p&gt;root@bj94:~/dr302client# (echo  &#34;select 10&#34;; echo &#34;hgetall www.example.com#all&#34;) | redis-cli -a cdnfusion -p 7648&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;1) &#34;weight&#34;&lt;/p&gt;

&lt;p&gt;2) &#34;20&#34;&lt;/p&gt;

&lt;p&gt;3) &#34;record_type&#34;&lt;/p&gt;

&lt;p&gt;4) &#34;A&#34;&lt;/p&gt;

&lt;p&gt;5) &#34;record_line&#34;&lt;/p&gt;

&lt;p&gt;6) &#34;all&#34;&lt;/p&gt;

&lt;p&gt;7) &#34;status&#34;&lt;/p&gt;

&lt;p&gt;8) &#34;enable&#34;&lt;/p&gt;

&lt;p&gt;9) &#34;mx&#34;&lt;/p&gt;

&lt;p&gt;10) &#34;1&#34;&lt;/p&gt;

&lt;p&gt;11) &#34;value&#34;&lt;/p&gt;

&lt;p&gt;12) &#34;1.1.1.1#10|2.2.2.2#20&#34;&lt;/p&gt;

&lt;p&gt;13) &#34;ttl&#34;&lt;/p&gt;

&lt;p&gt;14) &#34;86400&#34;&lt;/p&gt;

&lt;p&gt;15) &#34;record_line_id&#34;&lt;/p&gt;

&lt;p&gt;16) &#34;00000000&#34;&lt;/p&gt;

&lt;p&gt;17) &#34;sub_domain&#34;&lt;/p&gt;

&lt;p&gt;18) &#34;@&#34;&lt;/p&gt;

&lt;p&gt;#+END_QUOTE&lt;/p&gt;

&lt;h2 id=&#34;踩过的坑&#34;&gt;踩过的坑&lt;/h2&gt;

&lt;h3 id=&#34;table的深度与浅度拷贝&#34;&gt;table的深度与浅度拷贝&lt;/h3&gt;

&lt;h4 id=&#34;现象&#34;&gt;现象&lt;/h4&gt;

&lt;p&gt;当通过API批量获取配置列表时，发现不同的key获取的值是一样的， 但通过redis-cli获取是不一样且正确的。&lt;/p&gt;

&lt;h4 id=&#34;分析&#34;&gt;分析&lt;/h4&gt;

&lt;p&gt;redis存储是正确的，很有可能是中间临时存储存在覆盖的问题， 如果table每次赋值都相当于内存拷贝那样Lua的性能就会大大降低，&lt;/p&gt;

&lt;p&gt;会不会table之间赋值就像C语言一样只赋值地址或指针。经网上查找发现table存在深度与浅度拷贝的区别。&lt;/p&gt;

&lt;p&gt;详见:&lt;a href=&#34;https://my.oschina.net/hqc17/blog/748709&#34; title=&#34;Lua实现深度拷贝&#34;&gt;Lua实现深度拷贝&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;解决措施&#34;&gt;解决措施&lt;/h4&gt;

&lt;p&gt;把中间的临时table变量放入当前语句块中并加local标识，猜测在当前语句块临时table可能会随时被释放掉，&lt;/p&gt;

&lt;p&gt;因此它赋值给其他作用域更大的变量时使用深拷贝。&lt;/p&gt;

&lt;h3 id=&#34;hgetall结果与lua-table转换&#34;&gt;hgetall结果与Lua table转换&lt;/h3&gt;

&lt;p&gt;使用hgetall获取redis的内容需经转换后才能被Lua table使用。&lt;/p&gt;

&lt;p&gt;转换关键代码如下:&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC lua -n&lt;/p&gt;

&lt;p&gt;local v = red:hgetall(innerk)&lt;/p&gt;

&lt;p&gt;if v == nil then&lt;/p&gt;

&lt;p&gt;log(ERR, &#34;get redis empty key: &#34;, innerk)&lt;/p&gt;

&lt;p&gt;return nil&lt;/p&gt;

&lt;p&gt;end&lt;/p&gt;

&lt;p&gt;for key,val in pairs(v) do&lt;/p&gt;

&lt;p&gt;if key%2 ~= 0 then&lt;/p&gt;

&lt;p&gt;result[v[key]] = v[key+1];&lt;/p&gt;

&lt;p&gt;end&lt;/p&gt;

&lt;p&gt;end&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;h3 id=&#34;nginx-worker权限问题&#34;&gt;nginx worker权限问题&lt;/h3&gt;

&lt;h4 id=&#34;现象-1&#34;&gt;现象&lt;/h4&gt;

&lt;p&gt;当使用init_worker_by_lua_file进行定时器任务时，发现不能打开或写入/usr/local/openresty/子目录下的文件， 而init_by_lua_file调用则正常。&lt;/p&gt;

&lt;h4 id=&#34;分析-1&#34;&gt;分析&lt;/h4&gt;

&lt;p&gt;当把路径改为/tmp/目录下则运行都正常，经定位发现nginx master以root身份运行， 而nginx worker以nobody身份运行。&lt;/p&gt;

&lt;p&gt;查看需要读写的文件路径， 发现只有root权限才能写。&lt;/p&gt;

&lt;h4 id=&#34;解决措施-1&#34;&gt;解决措施&lt;/h4&gt;

&lt;p&gt;1） 发现代码以&#34;r+&#34;(更新模式,保存之前的数据)模式进行读文件，需改成&#34;r&#34;只读模式。&lt;/p&gt;

&lt;p&gt;2） 把要写的文件路径改成其他可写，例如: chmod 777 data&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
