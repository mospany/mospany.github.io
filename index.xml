<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>墨斯潘園 on 墨斯潘園</title>
        <link>http://mospany.github.io/</link>
        <language>zh-CN</language>
        <author>Mospan</author>
        <rights>Copyright (c) 2016, mospan; all rights reserved.</rights>
        <updated>Wed, 28 Sep 2022 20:10:36 CST</updated>
        
        <item>
            <title>K8S学习笔记(06): 资源</title>
            <link>http://mospany.github.io/2022/09/28/resource/</link>
            <pubDate>Wed, 28 Sep 2022 20:10:36 CST</pubDate>
            <author>Mospan</author>
            <guid>http://mospany.github.io/2022/09/28/resource/</guid>
            <description>

&lt;p&gt;&lt;a id=&#34;org660c89a&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;

&lt;p&gt;k8s中所有的内容都抽象为资源， 资源实例化之后，叫做对象。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org85b310d&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;资源类型介绍&#34;&gt;资源类型介绍&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;工作负载型资源对象（workload）：Pod，ReplicaSet，Deployment，StatefulSet，DaemonSet，Job，Cronjob &amp;#x2026;&lt;/li&gt;
&lt;li&gt;服务发现及均衡资源对象：Service，Ingress &amp;#x2026;&lt;/li&gt;
&lt;li&gt;配置与存储资源对象：Volume(存储卷)，CSI(容器存储接口,可以扩展各种各样的第三方存储卷)，ConfigMap，Secret，DownwardAPI&lt;/li&gt;
&lt;li&gt;集群级资源：Namespace，Node，Role，ClusterRole，RoleBinding，ClusterRoleBinding&lt;/li&gt;
&lt;li&gt;元数据型资源：HPA，PodTemplate，LimitRange&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;org6bacf92&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;工作负载资源&#34;&gt;工作负载资源&lt;/h1&gt;

&lt;p&gt;&lt;a id=&#34;org82a2012&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;deployment&#34;&gt;Deployment&lt;/h2&gt;

&lt;p&gt;为了更好地解决服务编排的问题，k8s在V1.2版本开始，引入了deployment控制器，值得一提的是，这种控制器并不直接管理pod，&lt;br /&gt;
而是通过管理replicaset来间接管理pod，即：deployment管理replicaset，replicaset管理pod。所以deployment比replicaset的功能更强大。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/k8s/resource/deploy.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;deployment的主要功能有下面几个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持replicaset的所有功能&lt;/li&gt;
&lt;li&gt;支持发布的停止、继续&lt;/li&gt;
&lt;li&gt;支持版本的滚动更新和版本回退&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;org53fb6bd&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;编写资源清单&#34;&gt;编写资源清单&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ cat test-deploy.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-deployment
  namespace: dev
spec:
  replicas: 3
  selector:
    matchLabels:
     app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.17.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;org97f8964&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;运行清单&#34;&gt;运行清单&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ k apply -f test-deploy.yaml
deployment.apps/test-deployment created 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;org947b655&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;查看效果&#34;&gt;查看效果&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ k get deploy -A
  NAMESPACE              NAME                           READY   UP-TO-DATE   AVAILABLE   AGE
  dev                    test-deployment                3/3     3            3           94s
  guestbook-system       guestbook-controller-manager   1/1     1            1           59d
  kube-system            coredns                        2/2     2            2           63d
  kubernetes-dashboard   dashboard-metrics-scraper      1/1     1            1           14d
  kubernetes-dashboard   kubernetes-dashboard           1/1     1            1           14d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出deploy已经运行成功，3副本已处于READY状态。&lt;/p&gt;

&lt;p&gt;再查看它运行中的清单:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ k get deploy -n dev test-deployment -o yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    deployment.kubernetes.io/revision: &amp;quot;1&amp;quot;
    kubectl.kubernetes.io/last-applied-configuration: |
      {&amp;quot;apiVersion&amp;quot;:&amp;quot;apps/v1&amp;quot;,&amp;quot;kind&amp;quot;:&amp;quot;Deployment&amp;quot;,&amp;quot;metadata&amp;quot;:{&amp;quot;annotations&amp;quot;:{},&amp;quot;name&amp;quot;:&amp;quot;test-deployment&amp;quot;,&amp;quot;namespace&amp;quot;:&amp;quot;dev&amp;quot;},&amp;quot;spec&amp;quot;:{&amp;quot;replicas&amp;quot;:3,&amp;quot;selector&amp;quot;:{&amp;quot;matchLabels&amp;quot;:{&amp;quot;app&amp;quot;:&amp;quot;nginx-pod&amp;quot;}},&amp;quot;template&amp;quot;:{&amp;quot;metadata&amp;quot;:{&amp;quot;labels&amp;quot;:{&amp;quot;app&amp;quot;:&amp;quot;nginx-pod&amp;quot;}},&amp;quot;spec&amp;quot;:{&amp;quot;containers&amp;quot;:[{&amp;quot;image&amp;quot;:&amp;quot;nginx:1.17.1&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;nginx&amp;quot;}]}}}}
  creationTimestamp: &amp;quot;2022-09-28T12:35:22Z&amp;quot;
  generation: 1
  name: test-deployment
  namespace: dev
  resourceVersion: &amp;quot;5045809&amp;quot;
  uid: 40feb568-1343-4046-8708-7e1bf5e5c384
spec:
  #spec.progressDeadlineSeconds 是可选配置项，用来指定在系统报告Deployment的failed progressing一一表现为resource的状态中 type=Progressing 、 Status=False 、 Reason=ProgressDeadlineExceeded 前可以等待的Deployment进行的秒数。Deployment controller会继续重试该Deployment。未来，在实现了自动回滚后， deployment controller在观察到这种状态时就会自动回滚。
  progressDeadlineSeconds: 600
  #.spec.replicas 是可以选字段，指定期望的pod数量，默认是1。
  replicas: 3
  revisionHistoryLimit: 10
  #.spec.selector是可选字段，用来指定 label selector ，圈定Deployment管理的pod范围。如果被指定， .spec.selector 必须匹配 .spec.template.metadata.labels，否则它将被API拒绝。如果.spec.selector 没有被指定， .spec.selector.matchLabels 默认是.spec.template.metadata.labels。在Pod的template跟.spec.template不同或者数量超过了.spec.replicas规定的数量的情况下，Deployment会杀掉label跟selector不同的Pod。
  selector:
    matchLabels:
      app: nginx-pod
  #.spec.strategy 指定新的Pod替换旧的Pod的策略。 .spec.strategy.type 可以是&amp;quot;Recreate&amp;quot;或者是&amp;quot;RollingUpdate&amp;quot;。&amp;quot;RollingUpdate&amp;quot;是默认值。
  strategy:
    rollingUpdate:
      #spec.strategy.rollingUpdate.maxSurge 是可选配置项，用来指定可以超过期望的Pod数量的最大个数。该值可以是一个绝对值（例如5）或者是期望的Pod数量的百分比（例如10%）。当 MaxUnavailable 为0时该值不可以为0。通过百分比计算的绝对值向上取整。默认值是1。
      maxSurge: 25%
      #.spec.strategy.rollingUpdate.maxUnavailable 是可选配置项，用来指定在升级过程中不可用Pod的最大数量。该值可以是一个绝对值（例如5），也可以是期望Pod数量的百分比（例如10%）。通过计算百分比的绝对值向下取整。 如 果 .spec.strategy.rollingUpdate.maxSurge 为0时，这个值不可以为0。默认值是1。例如，该值设置成30%，启动rolling update后旧的ReplicatSet将会立即缩容到期望的Pod数量的70%。新的Pod ready后，随着新的ReplicaSet的扩容，旧的ReplicaSet会进一步缩容确保在升级的所有时刻可以用的Pod数量至少是期望Pod数量的70%。
      maxUnavailable: 25%
    #滚动更新，简单定义 更新期间pod最多有几个等。可以指定 maxUnavailable 和 maxSurge 来控制 rolling update 进程。
    type: RollingUpdate
  #.spec.template 是 .spec中唯一要求的字段。.spec.template 是 pod template. 它跟 Pod有一模一样的schema，除了它是嵌套的并且不需要apiVersion 和 kind字段。另外为了划分Pod的范围，Deployment中的pod template必须指定适当的label（不要跟其他controller重复了，参考selector）和适当的重启策略。.spec.template.spec.restartPolicy 可以设置为 Always , 如果不指定的话这就是默认配置。
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: nginx-pod
    spec:
      containers:
      - image: nginx:1.17.1
        imagePullPolicy: IfNotPresent
        name: nginx
        resources: {}
        #terminationMessagePath 表示容器的异常终止消息的路径，默认在 /dev/termination-log 下。当容器退出时，可以通过容器的状态看到退出信息。
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
      #“ClusterFirst“:如果DNS查询与配置好的默认集群域名前缀不匹配，则将查询请求转发到从节点继承而来，作为查询的上游服务器。
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      #spec:schedulername参数指定调度器的名字，可以为 pod 选择某个调度器进行调度
      schedulerName: default-scheduler
      #安全上下文（Security Context）定义 Pod 或 Container 的特权与访问控制设置。
      securityContext: {}
      terminationGracePeriodSeconds: 30
status:
  availableReplicas: 3
  conditions:
  - lastTransitionTime: &amp;quot;2022-09-28T12:35:25Z&amp;quot;
    lastUpdateTime: &amp;quot;2022-09-28T12:35:25Z&amp;quot;
    message: Deployment has minimum availability.
    reason: MinimumReplicasAvailable
    status: &amp;quot;True&amp;quot;
    type: Available
  - lastTransitionTime: &amp;quot;2022-09-28T12:35:22Z&amp;quot;
    lastUpdateTime: &amp;quot;2022-09-28T12:35:25Z&amp;quot;
    message: ReplicaSet &amp;quot;test-deployment-5d9c9b97bb&amp;quot; has successfully progressed.
    reason: NewReplicaSetAvailable
    status: &amp;quot;True&amp;quot;
    type: Progressing
  observedGeneration: 1
  readyReplicas: 3
  replicas: 3
  updatedReplicas: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;org9fc5244&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;

&lt;p&gt;1.&lt;a href=&#34;https://blog.51cto.com/u_15155091/2723613&#34;&gt;k8s之terminationMessagePath&lt;/a&gt;&lt;br /&gt;
2.&lt;a href=&#34;https://blog.csdn.net/dkfajsldfsdfsd/article/details/81209150&#34;&gt;Kubernetes之DNS&lt;/a&gt;&lt;br /&gt;
3.&lt;a href=&#34;https://www.jianshu.com/p/1f64a4694ace&#34;&gt;Kubernetes——调度器Scheduler&lt;/a&gt;&lt;br /&gt;
4.&lt;a href=&#34;https://cloud.tencent.com/developer/article/1748675&#34;&gt;k8s之securityContext&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>K8S学习笔记(05): yaml语法</title>
            <link>http://mospany.github.io/2022/09/27/k8s-yaml/</link>
            <pubDate>Tue, 27 Sep 2022 19:58:47 CST</pubDate>
            <author>Mospan</author>
            <guid>http://mospany.github.io/2022/09/27/k8s-yaml/</guid>
            <description>

&lt;p&gt;&lt;a id=&#34;orgfba5ff2&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;k8s支持的文件格式&#34;&gt;k8s支持的文件格式&lt;/h1&gt;

&lt;p&gt;Kubernetes支持YAML和JSON格式管理资源对象&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JSON格式：主要用于api接口之间消息的传递&lt;/li&gt;
&lt;li&gt;YAML格式：用于配置和管理，YAML是一种简洁的非标记性语言，内容格式人性化，较易读&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;org3c21164&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;yaml语言格式&#34;&gt;YAML语言格式&lt;/h1&gt;

&lt;p&gt;● 大小写敏感&lt;br /&gt;
● 使用缩进表示层级关系&lt;br /&gt;
● 不支持Tab键制表符缩进，只使用空格缩进&lt;br /&gt;
● 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可，通常开头缩进两个空格&lt;br /&gt;
● 符号字符后缩进一个空格，如冒号，逗号，短横杠（-）等&lt;br /&gt;
● “&amp;#x2014;”表示YAML格式，一个文件的开始，用于分隔文件&lt;br /&gt;
● “#”表示注释&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgd843414&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;编写资源配置清单&#34;&gt;编写资源配置清单&lt;/h1&gt;

&lt;p&gt;[root@master test]# vim nginx-test.yaml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#指定api版本标签
apiVersion: apps/v1
#定义资源的类型/角色，deployment为副本控制器
#此处资源类型可以是Deployment、Job、Ingress、Service等
kind: Deployment
#定义资源的元数据信息，比如资源的名称、namespace、标签等信息
metadata:
  #定义资源的名称，在同一个namespace空间中必须是唯一的
  name: nginx-test
  lables:
    app: nginx
#定义deployment资源需要的参数属性，诸如是否在容器失败时重新启动容器的属性
spec:
  #定义副本数量
  replicas: 3
  #定义标签选择器
  selector:
    #定义匹配标签
    matchLabels:
      #需与后面的.spec.template.metadata.labels定义的标签保持一致
      app: nginx
  #定义业务模板，如果有多个副本，所有副本的属性会按照模板的相关配置进行匹配
  template:
    metadata:
      #定义Pod副本将使用的标签，需与前面的.spec.selector.matchLabels定义的标签保持一致
      labels:
        app: nginx
    spec:
      #定义容器属性
      containers:
      #定义一个容器名，一个-name:定义一个容器
      - name: nginx
        #定义容器使用的镜像以及版本
        image: nginx:1.15.4
        ports:
        #定义容器对外的端口
        - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;org32111ee&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;创建service服务对外提供访问并测试&#34;&gt;创建service服务对外提供访问并测试&lt;/h1&gt;

&lt;p&gt;[root@master test]# vim nginx-svc-test.yaml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: nginx-svc
  labels:
    app: nginx
spec:
  type: NodePort
  ports:
  - port: 80
    targetPort: 80
  selector:
    #此处定义的selector要与deployment所定义的selector相同
    #service依靠标签选择器来检索提供服务的nodes
    app: nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;org7f24d32&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;详解k8s中的port&#34;&gt;详解k8s中的port&lt;/h1&gt;

&lt;p&gt;port是k8s集群内部访问service的端口，即通过clusterIP:port可以从Pod所在的Node上访问到service&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;nodePort&lt;br /&gt;
nodePort是外部访问k8s集群中service的端口，通过nodeIP:nodePort可以从外部访问到某个service&lt;/li&gt;
&lt;li&gt;targetPort&lt;br /&gt;
targetPort是Pod的端口，从port或nodePort来的流量经过kube-proxy反向代理负载均衡转发到后端Pod的targetPort上，最后进入容器。&lt;/li&gt;
&lt;li&gt;containerPort&lt;br /&gt;
containerPort是Pod内部容器的端口，targetPort映射到containerPort。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;orgbae1b9d&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;获取资源配置清单的总结&#34;&gt;获取资源配置清单的总结&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;没有相关资源，使用run命令&amp;#x2013;dry-run选项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl run dryrun-test --image=nginx --port=80 --replicas=3 --dry-run -o yaml &amp;gt; dryrun-test.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;已有相关资源，使用get命令&amp;#x2013;export选项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get deploy dryrun-test --export -o yaml &amp;gt; export-test.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt; ：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;现在不推荐使用“ export”（从1.14版本开始，通常应该在1.18版本中消失（在changelog中找不到））&lt;/li&gt;
&lt;li&gt;&amp;#x2013;dry-run is deprecated and can be replaced with &amp;#x2013;dry-run=client.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;org86e8206&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.escapelife.site/posts/8032061c.html&#34;&gt;Kubernetes之YAML语法&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>K8S学习笔记(04): kubectl命令技巧大全</title>
            <link>http://mospany.github.io/2022/09/21/k8s-kubectl-all-cmd/</link>
            <pubDate>Wed, 21 Sep 2022 21:01:59 CST</pubDate>
            <author>Mospan</author>
            <guid>http://mospany.github.io/2022/09/21/k8s-kubectl-all-cmd/</guid>
            <description>

&lt;p&gt;&lt;a id=&#34;org8c37926&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kubectl-命令技巧大全&#34;&gt;kubectl 命令技巧大全&lt;/h1&gt;

&lt;p&gt;kubectl 命令是操作 Kubernetes 集群的最直接和最高效的途径，这个60多 MB 大小的二进制文件，到底有啥能耐呢？&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org42fef24&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kubectl-自动补全&#34;&gt;Kubectl 自动补全&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ source &amp;lt;(kubectl completion bash) # setup autocomplete in bash, bash-completion package should be installed first.
$ source &amp;lt;(kubectl completion zsh)  # setup autocomplete in zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;org27c704f&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kubectl-上下文和配置&#34;&gt;Kubectl 上下文和配置&lt;/h1&gt;

&lt;p&gt;设置 kubectl 命令交互的 kubernetes 集群并修改配置信息。参阅 使用 kubeconfig 文件进行跨集群验证 获取关于配置文件的详细信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl config view # 显示合并后的 kubeconfig 配置

# 同时使用多个 kubeconfig 文件并查看合并后的配置
$ KUBECONFIG=~/.kube/config:~/.kube/kubconfig2 kubectl config view

# 获取 e2e 用户的密码
$ kubectl config view -o jsonpath=&#39;{.users[?(@.name == &amp;quot;e2e&amp;quot;)].user.password}&#39;

$ kubectl config current-context              # 显示当前的上下文
$ kubectl config use-context my-cluster-name  # 设置默认上下文为 my-cluster-name

# 向 kubeconf 中增加支持基本认证的新集群
$ kubectl config set-credentials kubeuser/foo.kubernetes.com --username=kubeuser --password=kubepassword

# 使用指定的用户名和 namespace 设置上下文
$ kubectl config set-context gce --user=cluster-admin --namespace=foo \
  &amp;amp;&amp;amp; kubectl config use-context gce
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;orgaa430dd&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;创建对象&#34;&gt;创建对象&lt;/h1&gt;

&lt;p&gt;Kubernetes 的清单文件可以使用 json 或 yaml 格式定义。可以以 .yaml、.yml、或者 .json 为扩展名。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create -f ./my-manifest.yaml           # 创建资源
$ kubectl create -f ./my1.yaml -f ./my2.yaml     # 使用多个文件创建资源
$ kubectl create -f ./dir                        # 使用目录下的所有清单文件来创建资源
$ kubectl create -f https://git.io/vPieo         # 使用 url 来创建资源
$ kubectl run nginx --image=nginx                # 启动一个 nginx 实例
$ kubectl explain pods,svc                       # 获取 pod 和 svc 的文档

# 从 stdin 输入中创建多个 YAML 对象
$ cat &amp;lt;&amp;lt;EOF | kubectl create -f -
apiVersion: v1
kind: Pod
metadata:
  name: busybox-sleep
spec:
  containers:
  - name: busybox
    image: busybox
    args:
    - sleep
    - &amp;quot;1000000&amp;quot;
---
apiVersion: v1
kind: Pod
metadata:
  name: busybox-sleep-less
spec:
  containers:
  - name: busybox
    image: busybox
    args:
    - sleep
    - &amp;quot;1000&amp;quot;
EOF

# 创建包含几个 key 的 Secret
$ cat &amp;lt;&amp;lt;EOF | kubectl create -f -
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  password: $(echo &amp;quot;s33msi4&amp;quot; | base64)
  username: $(echo &amp;quot;jane&amp;quot; | base64)
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;org62782f5&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;显示和查找资源&#34;&gt;显示和查找资源&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# Get commands with basic output
$ kubectl get services                          # 列出所有 namespace 中的所有 service
$ kubectl get pods --all-namespaces             # 列出所有 namespace 中的所有 pod
$ kubectl get pods -o wide                      # 列出所有 pod 并显示详细信息
$ kubectl get deployment my-dep                 # 列出指定 deployment

# 使用详细输出来描述命令
$ kubectl describe nodes my-node
$ kubectl describe pods my-pod

$ kubectl get services --sort-by=.metadata.name # List Services Sorted by Name

# 根据重启次数排序列出 pod
$ kubectl get pods --sort-by=&#39;.status.containerStatuses[0].restartCount&#39;

# 获取所有具有 app=cassandra 的 pod 中的 version 标签
$ kubectl get pods --selector=app=cassandra rc -o \
  jsonpath=&#39;{.items[*].metadata.labels.version}&#39;

# 获取所有节点的 ExternalIP
$ kubectl get nodes -o jsonpath=&#39;{.items[*].status.addresses[?(@.type==&amp;quot;ExternalIP&amp;quot;)].address}&#39;

# 列出属于某个 PC 的 Pod 的名字
# “jq”命令用于转换复杂的 jsonpath，参考 https://stedolan.github.io/jq/
$ sel=${$(kubectl get rc my-rc --output=json | jq -j &#39;.spec.selector | to_entries | .[] | &amp;quot;\(.key)=\(.value),&amp;quot;&#39;)%?}
$ echo $(kubectl get pods --selector=$sel --output=jsonpath={.items..metadata.name})

# 查看哪些节点已就绪
$ JSONPATH=&#39;{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}&#39; \
 &amp;amp;&amp;amp; kubectl get nodes -o jsonpath=&amp;quot;$JSONPATH&amp;quot; | grep &amp;quot;Ready=True&amp;quot;

# 列出当前 Pod 中使用的 Secret
$ kubectl get pods -o json | jq &#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39; | grep -v null | sort | uniq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;orgc7a7c88&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;更新资源&#34;&gt;更新资源&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl rolling-update frontend-v1 -f frontend-v2.json           # 滚动更新 pod frontend-v1
$ kubectl rolling-update frontend-v1 frontend-v2 --image=image:v2  # 更新资源名称并更新镜像
$ kubectl rolling-update frontend --image=image:v2                 # 更新 frontend pod 中的镜像
$ kubectl rolling-update frontend-v1 frontend-v2 --rollback        # 退出已存在的进行中的滚动更新
$ cat pod.json | kubectl replace -f -                              # 基于 stdin 输入的 JSON 替换 pod

# 强制替换，删除后重新创建资源。会导致服务中断。
$ kubectl replace --force -f ./pod.json

# 为 nginx RC 创建服务，启用本地 80 端口连接到容器上的 8000 端口
$ kubectl expose rc nginx --port=80 --target-port=8000

# 更新单容器 pod 的镜像版本（tag）到 v4
$ kubectl get pod mypod -o yaml | sed &#39;s/\(image: myimage\):.*$/\1:v4/&#39; | kubectl replace -f -

$ kubectl label pods my-pod new-label=awesome                      # 添加标签
$ kubectl annotate pods my-pod icon-url=http://goo.gl/XXBTWq       # 添加注解
$ kubectl autoscale deployment foo --min=2 --max=10                # 自动扩展 deployment “foo”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;orga04178c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;修补资源&#34;&gt;修补资源&lt;/h1&gt;

&lt;p&gt;使用策略合并补丁并修补资源。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl patch node k8s-node-1 -p &#39;{&amp;quot;spec&amp;quot;:{&amp;quot;unschedulable&amp;quot;:true}}&#39; # 部分更新节点

# 更新容器镜像； spec.containers[*].name 是必须的，因为这是合并的关键字
$ kubectl patch pod valid-pod -p &#39;{&amp;quot;spec&amp;quot;:{&amp;quot;containers&amp;quot;:[{&amp;quot;name&amp;quot;:&amp;quot;kubernetes-serve-hostname&amp;quot;,&amp;quot;image&amp;quot;:&amp;quot;new image&amp;quot;}]}}&#39;

# 使用具有位置数组的 json 补丁更新容器镜像
$ kubectl patch pod valid-pod --type=&#39;json&#39; -p=&#39;[{&amp;quot;op&amp;quot;: &amp;quot;replace&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;/spec/containers/0/image&amp;quot;, &amp;quot;value&amp;quot;:&amp;quot;new image&amp;quot;}]&#39;

# 使用具有位置数组的 json 补丁禁用 deployment 的 livenessProbe
$ kubectl patch deployment valid-deployment  --type json   -p=&#39;[{&amp;quot;op&amp;quot;: &amp;quot;remove&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;/spec/template/spec/containers/0/livenessProbe&amp;quot;}]&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;org4b6db63&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;编辑资源&#34;&gt;编辑资源&lt;/h1&gt;

&lt;p&gt;在编辑器中编辑任何 API 资源。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl edit svc/docker-registry                      # 编辑名为 docker-registry 的 service
$ KUBE_EDITOR=&amp;quot;nano&amp;quot; kubectl edit svc/docker-registry   # 使用其它编辑器
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;org43c4654&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;scale-资源&#34;&gt;Scale 资源&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl scale --replicas=3 rs/foo                                 # Scale a replicaset named &#39;foo&#39; to 3
$ kubectl scale --replicas=3 -f foo.yaml                            # Scale a resource specified in &amp;quot;foo.yaml&amp;quot; to 3
$ kubectl scale --current-replicas=2 --replicas=3 deployment/mysql  # If the deployment named mysql&#39;s current size is 2, scale mysql to 3
$ kubectl scale --replicas=5 rc/foo rc/bar rc/baz                   # Scale multiple replication controllers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;orgc4b94c3&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;删除资源&#34;&gt;删除资源&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl delete -f ./pod.json                                              # 删除 pod.json 文件中定义的类型和名称的 pod
$ kubectl delete pod,service baz foo                                        # 删除名为“baz”的 pod 和名为“foo”的 service
$ kubectl delete pods,services -l name=myLabel                              # 删除具有 name=myLabel 标签的 pod 和 serivce
$ kubectl delete pods,services -l name=myLabel --include-uninitialized      # 删除具有 name=myLabel 标签的 pod 和 service，包括尚未初始化的
$ kubectl -n my-ns delete po,svc --all                                      # 删除 my-ns namespace 下的所有 pod 和 serivce，包括尚未初始化的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;org2dfd797&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;与运行中的-pod-交互&#34;&gt;与运行中的 Pod 交互&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl logs my-pod                                 # dump 输出 pod 的日志（stdout）
$ kubectl logs my-pod -c my-container                 # dump 输出 pod 中容器的日志（stdout，pod 中有多个容器的情况下使用）
$ kubectl logs -f my-pod                              # 流式输出 pod 的日志（stdout）
$ kubectl logs -f my-pod -c my-container              # 流式输出 pod 中容器的日志（stdout，pod 中有多个容器的情况下使用）
$ kubectl run -i --tty busybox --image=busybox -- sh  # 交互式 shell 的方式运行 pod
$ kubectl attach my-pod -i                            # 连接到运行中的容器
$ kubectl port-forward my-pod 5000:6000               # 转发 pod 中的 6000 端口到本地的 5000 端口
$ kubectl exec my-pod -- ls /                         # 在已存在的容器中执行命令（只有一个容器的情况下）
$ kubectl exec my-pod -c my-container -- ls /         # 在已存在的容器中执行命令（pod 中有多个容器的情况下）
$ kubectl top pod POD_NAME --containers               # 显示指定 pod 和容器的指标度量
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;org293bbe3&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;与节点和集群交互&#34;&gt;与节点和集群交互&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl cordon my-node                                                # 标记 my-node 不可调度
$ kubectl drain my-node                                                 # 清空 my-node 以待维护
$ kubectl uncordon my-node                                              # 标记 my-node 可调度
$ kubectl top node my-node                                              # 显示 my-node 的指标度量
$ kubectl cluster-info                                                  # 显示 master 和服务的地址
$ kubectl cluster-info dump                                             # 将当前集群状态输出到 stdout                                    
$ kubectl cluster-info dump --output-directory=/path/to/cluster-state   # 将当前集群状态输出到 /path/to/cluster-state

# 如果该键和影响的污点（taint）已存在，则使用指定的值替换
$ kubectl taint nodes foo dedicated=special-user:NoSchedule
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;orgef08c6d&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;资源类型&#34;&gt;资源类型&lt;/h1&gt;

&lt;p&gt;下表列出的是 kubernetes 中所有支持的类型和缩写的别名。&lt;/p&gt;

&lt;table border=&#34;2&#34; cellspacing=&#34;0&#34; cellpadding=&#34;6&#34; rules=&#34;groups&#34; frame=&#34;hsides&#34;&gt;


&lt;colgroup&gt;
&lt;col  class=&#34;org-left&#34; /&gt;

&lt;col  class=&#34;org-left&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope=&#34;col&#34; class=&#34;org-left&#34;&gt;资源类型&lt;/th&gt;
&lt;th scope=&#34;col&#34; class=&#34;org-left&#34;&gt;缩写别名&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;clusters&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;componentstatuses&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;cs&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;configmaps&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;cm&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;daemonsets&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;ds&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;deployments&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;deploy&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;endpoints&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;ep&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;event&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;ev&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;horizontalpodautoscalers&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;hpa&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;ingresses&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;ing&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;jobs&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;limitranges&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;limits&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;namespaces&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;ns&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;networkpolicies&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;nodes&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;statefulsets&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;persistentvolumeclaims&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;pvc&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;persistentvolumes&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;pv&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;pods&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;po&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;podsecuritypolicies&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;psp&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;podtemplates&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;replicasets&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;rs&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;replicationcontrollers&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;rc&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;resourcequotas&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;quota&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;cronjob&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;secrets&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;serviceaccount&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;sa&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;services&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;svc&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;storageclasses&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;thirdpartyresources&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&#34;orgb32a4c5&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;格式化输出&#34;&gt;格式化输出&lt;/h1&gt;

&lt;p&gt;要以特定的格式向终端窗口输出详细信息，可以在 kubectl 命令中添加 -o 或者 -output 标志。&lt;/p&gt;

&lt;table border=&#34;2&#34; cellspacing=&#34;0&#34; cellpadding=&#34;6&#34; rules=&#34;groups&#34; frame=&#34;hsides&#34;&gt;


&lt;colgroup&gt;
&lt;col  class=&#34;org-left&#34; /&gt;

&lt;col  class=&#34;org-left&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope=&#34;col&#34; class=&#34;org-left&#34;&gt;输出格式&lt;/th&gt;
&lt;th scope=&#34;col&#34; class=&#34;org-left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;-o=json&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;输出 JSON 格式的 API 对象&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;-o=jsonpath=template&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;打印 jsonpath 表达式中定义的字段&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;-o=jsonpath-file=filename&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;打印由 文件中的 jsonpath 表达式定义的字段&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;-o=name&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;仅打印资源名称&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;-o=wide&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;以纯文本格式输出任何附加信息，对于 Pod ，包含节点名称&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;-o=yaml&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;输出 YAML 格式的 API 对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&#34;org8e6aac4&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kubectl-详细输出和调试&#34;&gt;Kubectl 详细输出和调试&lt;/h1&gt;

&lt;p&gt;使用 -v 或 &amp;#x2013;v 标志跟着一个整数来指定日志级别。&lt;/p&gt;

&lt;table border=&#34;2&#34; cellspacing=&#34;0&#34; cellpadding=&#34;6&#34; rules=&#34;groups&#34; frame=&#34;hsides&#34;&gt;


&lt;colgroup&gt;
&lt;col  class=&#34;org-left&#34; /&gt;

&lt;col  class=&#34;org-left&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope=&#34;col&#34; class=&#34;org-left&#34;&gt;详细等级&lt;/th&gt;
&lt;th scope=&#34;col&#34; class=&#34;org-left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#x2013;v=0&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;总是对操作人员可见。&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#x2013;v=1&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;合理的默认日志级别，如果您不需要详细输出。&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#x2013;v=2&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;可能与系统的重大变化相关的，有关稳定状态的信息和重要的日志信息。这是对大多数系统推荐的日志级别。&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#x2013;v=3&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;有关更改的扩展信息。&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#x2013;v=4&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;调试级别详细输出。&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#x2013;v=6&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;显示请求的资源。&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#x2013;v=7&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;显示HTTP请求的header。&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td class=&#34;org-left&#34;&gt;&amp;#x2013;v=8&lt;/td&gt;
&lt;td class=&#34;org-left&#34;&gt;显示HTTP请求的内容。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&#34;org0f9fe33&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;p&gt;【01】&lt;a href=&#34;https://kubernetes.io/docs/reference/kubectl/&#34;&gt;Kubectl 概览&lt;/a&gt;&lt;br /&gt;
【02】&lt;a href=&#34;https://kubernetes.io/docs/reference/kubectl/jsonpath/&#34;&gt;JsonPath 手册&lt;/a&gt;&lt;br /&gt;
【03】&lt;a href=&#34;https://kubernetes.io/docs/reference/kubectl/cheatsheet/&#34;&gt;Cheatsheet&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>K8S学习笔记(03): Mac系统安装k8s集群</title>
            <link>http://mospany.github.io/2022/09/13/k8s-study-install-for-mac/</link>
            <pubDate>Tue, 13 Sep 2022 19:48:30 CST</pubDate>
            <author>Mospan</author>
            <guid>http://mospany.github.io/2022/09/13/k8s-study-install-for-mac/</guid>
            <description>

&lt;p&gt;&lt;a id=&#34;orgba0078b&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;版本介绍&#34;&gt;版本介绍&lt;/h1&gt;

&lt;p&gt;&lt;a id=&#34;org21778c4&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;mac系统版本&#34;&gt;Mac系统版本&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/k8s/k8s-install-for-mac/macos-version.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgfd3ff14&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;docker-desktop-版本&#34;&gt;Docker Desktop 版本&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/k8s/k8s-install-for-mac/docker-version.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org75f453a&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;k8s-版本&#34;&gt;K8S 版本&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/k8s/k8s-install-for-mac/k8s-version.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org5708814&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;

&lt;p&gt;&lt;a id=&#34;orge5e2699&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;docker安装&#34;&gt;Docker安装&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;brew install -cask docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;org42bc861&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;开机自启动k8s&#34;&gt;开机自启动K8S&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/k8s/k8s-install-for-mac/docker-startup-k8s.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;重启成功后查看K8S集群。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgd262c8d&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装kubernetes-dashboard&#34;&gt;安装Kubernetes Dashboard&lt;/h2&gt;

&lt;p&gt;命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.1/aio/deploy/recommended.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/k8s/k8s-install-for-mac/k8s-dashboard-install.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最新版本参考：&lt;a href=&#34;https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/&#34;&gt;https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/&lt;/a&gt;​&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgb628b73&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;创建sa登录token&#34;&gt;创建SA登录Token&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# vim dashboard-adminuser.yaml

apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kubernetes-dashboard
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-user
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kubernetes-dashboard

# kubectl create -f dashboard-adminuser.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;orgca914fe&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;绑定资源并获取登录token&#34;&gt;绑定资源并获取登录Token&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;kubectl create sa dashboard-admin -n kube-system
kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin
ADMIN_SECRET=$(kubectl get secrets -n kube-system | grep dashboard-admin | awk &#39;{print $1}&#39;)
DASHBOARD_LOGIN_TOKEN=$(kubectl describe secret -n kube-system ${ADMIN_SECRET} | grep -E &#39;^token&#39; | awk &#39;{print $2}&#39;)
echo $DASHBOARD_LOGIN_TOKEN
kubectl proxy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/k8s/k8s-install-for-mac/k8s-dashboard-rbac.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;1、先创建服务账号dashboard-admin&lt;br /&gt;
2、再把账号dashboard-admin绑定到集群角色cluster-admin上使其拥有集群的管理权限，cluster-admin 超级管理员，对集群所有权限,和linux下面root一样（在部署dashboard的时候，先创建sa，然后将sa绑定到角色cluster-admin，最后获取到token，这就使用了内置的cluster-admin ）。&lt;br /&gt;
3、最后再获取该账号的secrets里的token做为登录。观察serviceAccount的创建，并创建一个相应的Secret 来允许API访问。&lt;br /&gt;
4、使用kubectl proxy命令就可以使API server监听在本地的8001端口上，作用是建立一条通往API服务器的隧道，可以方便查看API服务器上的资源。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org498919d&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;登录dashbaord&#34;&gt;登录dashbaord&lt;/h3&gt;

&lt;p&gt;登录地址：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/configmap?namespace=default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：上面URL的#号后面configmap为锚点，&lt;a href=&#34;https:kubernetes-dashboard&#34;&gt;https:kubernetes-dashboard&lt;/a&gt;: 为普通字符串&lt;/p&gt;

&lt;p&gt;输入上面生成的token:&lt;br /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/k8s/k8s-install-for-mac/k8s-dashboard-login.png&#34; alt=&#34;img&#34; /&gt;&lt;br /&gt;
登录成功界面如下：&lt;br /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/k8s/k8s-install-for-mac/k8s-dashboard-main.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考资料&lt;br /&gt;
【01】 &lt;a href=&#34;https://blog.csdn.net/a772304419/article/details/125482351&#34;&gt;k8s 内置cluster role（集群角色） cluster-admin、admin、 edit、 view的作用范围及区别&lt;/a&gt;&lt;br /&gt;
【02】 &lt;a href=&#34;https://blog.csdn.net/m0_45406092/article/details/119890156&#34;&gt;kubectl proxy&lt;/a&gt;&lt;br /&gt;
【03】 &lt;a href=&#34;https://blog.csdn.net/marvel__dead/article/details/78833921&#34;&gt;URL中“#”号的作用&lt;/a&gt;&lt;br /&gt;
【04】 &lt;a href=&#34;https://blog.csdn.net/afz8572/article/details/101745100/&#34;&gt;mac上k8s学习踩坑&lt;/a&gt;&lt;br /&gt;
【05】 &lt;a href=&#34;https://javajgs.com/archives/8386&#34;&gt;mac下安装kubeneters及zsh下配置自动补全&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>K8S学习笔记(02): 架构</title>
            <link>http://mospany.github.io/2022/09/12/k8s-arch/</link>
            <pubDate>Mon, 12 Sep 2022 19:34:12 CST</pubDate>
            <author>Mospan</author>
            <guid>http://mospany.github.io/2022/09/12/k8s-arch/</guid>
            <description>

&lt;p&gt;&lt;a id=&#34;org2f48c43&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;

&lt;p&gt;Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。&lt;/p&gt;

&lt;p&gt;Kubernetes 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。Kubernetes 建立在 Google 在大规模运行生产工作负载方面拥有十几年的经验 的基础上，结合了社区中最好的想法和实践。&lt;/p&gt;

&lt;p&gt;Kubernetes 最初源于谷歌内部的 Borg，提供了面向应用的容器集群部署和管理系统。Kubernetes 的目标旨在消除编排物理 / 虚拟计算，网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原语上进行自助运营。Kubernetes 也提供稳定、兼容的基础（平台），用于构建定制化的 workflows 和更高级的自动化任务。 Kubernetes 具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。Kubernetes 还提供完善的管理工具，涵盖开发、部署测试、运维监控等各个环节。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org895d7b5&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;时光回溯&#34;&gt;时光回溯&lt;/h1&gt;

&lt;p&gt;让我们回顾一下为什么 Kubernetes 如此有用。&lt;br /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/k8s/k8s-arch/k8s-develop.svg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org54684e8&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;传统部署时代&#34;&gt;传统部署时代&lt;/h2&gt;

&lt;p&gt;早期，各个组织机构在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。 例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且维护许多物理服务器的成本很高。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orga38329f&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;虚拟化部署时代&#34;&gt;虚拟化部署时代&lt;/h2&gt;

&lt;p&gt;作为解决方案，引入了虚拟化。虚拟化技术允许你在单个物理服务器的 CPU 上运行多个虚拟机（VM）。 虚拟化允许应用程序在 VM 之间隔离，并提供一定程度的安全，因为一个应用程序的信息 不能被另一应用程序随意访问。&lt;/p&gt;

&lt;p&gt;虚拟化技术能够更好地利用物理服务器上的资源，并且因为可轻松地添加或更新应用程序 而可以实现更好的可伸缩性，降低硬件成本等等。&lt;/p&gt;

&lt;p&gt;每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgb581bb2&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;容器部署时代&#34;&gt;容器部署时代&lt;/h2&gt;

&lt;p&gt;容器类似于 VM，但是它们具有被放宽的隔离属性，可以在应用程序之间共享操作系统（OS）。 因此，容器被认为是轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。&lt;/p&gt;

&lt;p&gt;容器因具有许多优势而变得流行起来。下面列出的是容器的一些好处：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。&lt;/li&gt;
&lt;li&gt;持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性），支持可靠且频繁的 容器镜像构建和部署。&lt;/li&gt;
&lt;li&gt;关注开发与运维的分离：在构建/发布时而不是在部署时创建应用程序容器镜像， 从而将应用程序与基础架构分离。&lt;/li&gt;
&lt;li&gt;可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。&lt;/li&gt;
&lt;li&gt;跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。&lt;/li&gt;
&lt;li&gt;跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。&lt;/li&gt;
&lt;li&gt;以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。&lt;/li&gt;
&lt;li&gt;松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。&lt;/li&gt;
&lt;li&gt;资源隔离：可预测的应用程序性能。&lt;/li&gt;
&lt;li&gt;资源利用：高效率和高密度。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;org8a82c78&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;为什么需要-kubernetes-它能做什么&#34;&gt;为什么需要 Kubernetes，它能做什么?&lt;/h1&gt;

&lt;p&gt;容器是打包和运行应用程序的好方式。在生产环境中，你需要管理运行应用程序的容器，并确保不会停机。 例如，如果一个容器发生故障，则需要启动另一个容器。如果系统处理此行为，会不会更容易？&lt;/p&gt;

&lt;p&gt;这就是 Kubernetes 来解决这些问题的方法！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移、部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary 部署。&lt;/p&gt;

&lt;p&gt;Kubernetes 为你提供：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务发现和负载均衡&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;存储编排&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自动部署和回滚&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自动完成装箱计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自我修复&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;密钥与配置管理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org5423f7d&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kubernetes-不是什么&#34;&gt;Kubernetes 不是什么&lt;/h1&gt;

&lt;p&gt;Kubernetes 不是传统的、包罗万象的 PaaS（平台即服务）系统。 由于 Kubernetes 在容器级别而不是在硬件级别运行，它提供了 PaaS 产品共有的一些普遍适用的功能， 例如部署、扩展、负载均衡、日志记录和监视。 但是，Kubernetes 不是单体系统，默认解决方案都是可选和可插拔的。 Kubernetes 提供了构建开发人员平台的基础，但是在重要的地方保留了用户的选择和灵活性。&lt;/p&gt;

&lt;p&gt;Kubernetes：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不限制支持的应用程序类型。 Kubernetes 旨在支持极其多种多样的工作负载，包括无状态、有状态和数据处理工作负载。 如果应用程序可以在容器中运行，那么它应该可以在 Kubernetes 上很好地运行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不部署源代码，也不构建你的应用程序。 持续集成(CI)、交付和部署（CI/CD）工作流取决于组织的文化和偏好以及技术要求。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不提供应用程序级别的服务作为内置服务，例如中间件（例如，消息中间件）、 数据处理框架（例如，Spark）、数据库（例如，mysql）、缓存、集群存储系统 （例如，Ceph）。这样的组件可以在 Kubernetes 上运行，并且/或者可以由运行在 Kubernetes 上的应用程序通过可移植机制（例如， 开放服务代理）来访问。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不要求日志记录、监视或警报解决方案。 它提供了一些集成作为概念证明，并提供了收集和导出指标的机制。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不提供或不要求配置语言/系统（例如 jsonnet），它提供了声明性 API， 该声明性 API 可以由任意形式的声明性规范所构成。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不提供也不采用任何全面的机器配置、维护、管理或自我修复系统。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，Kubernetes 不仅仅是一个编排系统，实际上它消除了编排的需要。 编排的技术定义是执行已定义的工作流程：首先执行 A，然后执行 B，再执行 C。 相比之下，Kubernetes 包含一组独立的、可组合的控制过程， 这些过程连续地将当前状态驱动到所提供的所需状态。 如何从 A 到 C 的方式无关紧要，也不需要集中控制，这使得系统更易于使用 且功能更强大、系统更健壮、更为弹性和可扩展。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org76d4217&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;k8s架构原理&#34;&gt;K8S架构原理&lt;/h1&gt;

&lt;p&gt;概括来说 K8s 架构就是一个 Master 对应一群 Node 节点。 高可用时Master一般为3个。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/k8s/k8s-arch/k8s-arch.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org33f9855&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;master节点&#34;&gt;Master节点&lt;/h2&gt;

&lt;p&gt;&lt;a id=&#34;org817c289&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;kube-apiserver&#34;&gt;kube-apiserver&lt;/h3&gt;

&lt;p&gt;K8s 网关，所有的指令请求都必须要经过 apiserver, 对外暴露K8S的api接口，是外界进行资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org51afc21&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;kube-scheduler&#34;&gt;kube-scheduler&lt;/h3&gt;

&lt;p&gt;调度器，使用调度算法，把请求资源调度到某一个 node 节点；负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；就是监视新创建的 Pod，如果没有分配节点，就选择一个节点供他们运行，这就是pod的调度。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgdf97f22&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;kube-controller-manager&#34;&gt;kube-controller-manager&lt;/h3&gt;

&lt;p&gt;维护 K8s 资源对象, 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等，它们是处理集群中常规任务的后台线程。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgf648933&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;etcd&#34;&gt;etcd&lt;/h3&gt;

&lt;p&gt;存储资源对象, 一个可信赖的分布式键值存储服务，能够为整个分布式集群存储一些关键数据，协助分布式集群运转。储存K8S集群所有重要信息（持久化）。v2版本时基于内存的存储，v3开始才是序列化到介质。新版本K8S（v1.11以上）已经改用v3版本etcd。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org7931198&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;worker节点&#34;&gt;Worker节点&lt;/h2&gt;

&lt;p&gt;&lt;a id=&#34;org72f8096&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;kubelet&#34;&gt;kubelet&lt;/h3&gt;

&lt;p&gt;在每一个 node 节点都存在一份，在 node 节点上的资源操作指令由 kubelet 来执行, 直接跟容器引擎交互实现容器的生命周期管理。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org2c78346&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;kube-proxy&#34;&gt;kube-proxy&lt;/h3&gt;

&lt;p&gt;代理服务，处理服务间负载均衡；负责写入规则至 IPTABLES、IPVS 实现服务映射访问的。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org1a12d32&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;组件通信&#34;&gt;组件通信&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/k8s/k8s-arch/k8s-component-arch.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org028c0e9&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/concepts/&#34;&gt;Kubernetes 架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/0voice/k8s_awesome_document/blob/main/%25E6%2596%2587%25E7%25AB%25A0%25E7%25B2%25BE%25E9%2580%2589/%25E4%25B8%2580%25E6%2596%2587%25E4%25BA%2586%25E8%25A7%25A3%2520Kubernetes.md&#34;&gt;一文了解 Kubernetes.md&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>K8S学习笔记(01): 目录</title>
            <link>http://mospany.github.io/2022/09/10/k8s-study-toc/</link>
            <pubDate>Sat, 10 Sep 2022 16:13:51 CST</pubDate>
            <author>Mospan</author>
            <guid>http://mospany.github.io/2022/09/10/k8s-study-toc/</guid>
            <description>

&lt;p&gt;&lt;a id=&#34;org184128e&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;目录&#34;&gt;目录&lt;/h1&gt;

&lt;p&gt;&lt;a id=&#34;org8d20da4&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;k8s使用与原理&#34;&gt;K8S使用与原理&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.mospan.cn/2022/09/10/k8s-study-toc/&#34;&gt;K8S学习笔记(01): 目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.mospan.cn/2022/09/13/k8s-study-install-for-mac/&#34;&gt;K8S学习笔记(03): Mac系统安装k8s集群&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.mospan.cn/2022/09/21/k8s-kubectl-all-cmd/&#34;&gt;K8S学习笔记(04): kubectl命令技巧大全&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a id=&#34;orgd60bd20&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;ppt内容&#34;&gt;PPT内容&lt;/h1&gt;

&lt;p&gt;&lt;center&gt;&lt;embed src=&#34;http://blog.mospan.cn/post/img/k8s/k8s-study-toc.pdf&#34; width=100% height=800&gt;&lt;/center&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>互联网最重要入口DNS系列(1): 基本常识</title>
            <link>http://mospany.github.io/2019/11/14/dns-base/</link>
            <pubDate>Thu, 14 Nov 2019 22:30:22 CST</pubDate>
            <author>Mospan</author>
            <guid>http://mospany.github.io/2019/11/14/dns-base/</guid>
            <description>

&lt;p&gt;&lt;a id=&#34;orga57a6db&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;dns是什么&#34;&gt;DNS是什么？&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;因特尔域名系统&lt;br /&gt;
DNS是Domain Name System(域名系统)的缩写，互联网的入口服务，监听53端口。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提供域名到IP地址的映射，或反之&lt;br /&gt;
将域名和IP地址相互映射的一个分布式数据库，能够更方便地访问互联网。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;是分布式、C/S结构的服务&lt;br /&gt;
DNS是一个倒树形结构的分布式服务。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;主要定义在RFC1034/1035上&lt;br /&gt;
其中RFC1034为域名的概念和设施, RFC1035为域名的概念和设施。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;orgf21c435&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;为什么需要dns&#34;&gt;为什么需要DNS？&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;IP地址难以记忆与理解&lt;br /&gt;
IPv4地址形如192.168.1.1，而IPv6地址形如x:x:x:x:x:x:x:x的128位地址，非常难以记忆和理解，平时我们上网只要在浏览器上输入域名地址如wwww.baidu.com，由DNS系统翻译成所对应的IP地址更加方便一些。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;邮件投递需要寻址 (MX)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;域身份鉴定 (DomainKey, SPF)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;负载均衡(轮询、最小连接)&lt;br /&gt;
通过配置多条A记录实现访问轮询，也通过配置权重来进行负载均衡。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CDN、GSLB&lt;br /&gt;
CDN和GSLB主要利用DNS的CNAME记录来流量的接入与调度。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;orgfe8becb&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;什么是域-zone-与域名-domain&#34;&gt;什么是域(zone)与域名(domain)？&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;“.”是域，是所有其他域的起始点&lt;/li&gt;
&lt;li&gt;宇宙大爆炸：混沌初开，乾坤乃定&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/dns-base/zone.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;com.、com.cn.、cn、net.是域&lt;/li&gt;
&lt;li&gt;mospan.cn.、mospx.com.也是域&lt;/li&gt;
&lt;li&gt;blog.mospan.cn.、www.mospx.com.是域名&lt;/li&gt;
&lt;li&gt;domain = host(主机名) + zone&lt;/li&gt;
&lt;li&gt;标准的域名与主机名，只包括字母、数字、短横线和点&lt;/li&gt;
&lt;li&gt;域名的最大长度为255个字符，单个label最大为63个字符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;orga5e50c4&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;dns基本概念&#34;&gt;DNS基本概念&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/dns-base/concept.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DNS是一种倒树形的分布式系统，每一层存储它下一级的记录信息，自顶向下的查找过程。&lt;/li&gt;
&lt;li&gt;DNS主要分为授权和缓存，其他缓存DNS又分为Local（运营商本地） 和 public（公共） DNS。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;org081a6e5&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;dns报文格式&#34;&gt;DNS报文格式&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/dns-base/format.png&#34; alt=&#34;img&#34; /&gt;&lt;br /&gt;
DNS报文如上图所示，其他左图为报文完整格式，后图区域数据展开形式。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgc9600cf&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;dns-rr-资源记录集&#34;&gt;DNS RR(资源记录集)&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/dns-base/rr.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过dig工具探测典型结果如上图所示，包含多条的域名、生存时间TTL、记录类型、记录数据rdata组成。&lt;br /&gt;
其中TTL为该记录可缓存的时间秒数。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DNS RR(资源记录集)&lt;/li&gt;
&lt;li&gt;ttl:  缓存生存时间(单位：秒)，4个字节)&lt;/li&gt;
&lt;li&gt;type: 常用有A、CNAME、MX、TXT等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;详见：&lt;a href=&#34;https://ephen.me/2016/dns-rr/&#34;&gt;https://ephen.me/2016/dns-rr/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgc38c77f&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;ends-client-subnet&#34;&gt;ends-client-subnet&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/dns-base/edns.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;正常情况下，DNS服务器只能获取到跟它通信的客户端(一般是local DNS)IP来进行区域解析，edns机制是允许在报文中携带用户真实IP来进行区域解析。&lt;br /&gt;
例如: 假设202.106.0.1是北京联通用户，它配置的DNS解析服务器为8.8.8.8，在不支持edns情况下，授权DNS将根据8.8.8.8来解析到国外去，如果支持了edns会根据202.106.0.1来解析到国内服务器中来，这样解析更加准确。&lt;/p&gt;

&lt;p&gt;详见：&lt;a href=&#34;http://www.cnblogs.com/cobbliu/p/3188632.html&#34;&gt;http://www.cnblogs.com/cobbliu/p/3188632.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org9e17f41&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;dns解析过程&#34;&gt;DNS解析过程&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/dns-base/resolv.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在浏览器中输入域名后DNS域名解析过程如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;浏览器DNS缓存中搜索&lt;/li&gt;
&lt;li&gt;在操作系统DNS缓存中搜索&lt;/li&gt;
&lt;li&gt;读取系统hosts文件，查找其中是否有对应的ip&lt;/li&gt;
&lt;li&gt;向本地配置的首选DNS服务器发起域名解析请求&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;本地DNS收到请求后，查找自己的缓存，如找到则直接响应给客户端&lt;/li&gt;
&lt;li&gt;如未找到，则授权DNS服务器进行迭代查找，最终构造完整的响应给客户端。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;org6cc97d0&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;dns组织机构&#34;&gt;DNS组织机构&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ICANN(互联网名称与数字地址分配机构)&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;IP地址分配&lt;/li&gt;
&lt;li&gt;协议标识符的指派&lt;/li&gt;
&lt;li&gt;通用顶级域名（gTLD）管理&lt;/li&gt;
&lt;li&gt;国家和地区顶级域名（ccTLD）系统的管理&lt;/li&gt;
&lt;li&gt;根服务器系统的管理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Registry:   注册局。&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;维护区数据、委托注册机构提供注册服务。(CNNIC)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Registrar:   注册机构。&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;代表注册局提供注册服务。(万网、新网)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Registrant:   域名所有者。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;托管机构:  为域名所有者提供域名托管服务。(dnspod、XNS)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根服务器。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全球有13个根服务器，每个根服务器由不同的机构管理，每个服务器都有若干的镜像，使用anycast技术提供就近访问。&lt;/li&gt;
&lt;li&gt;大部分服务器在美国，北京和香港有根的镜像服务器。&lt;/li&gt;
&lt;li&gt;根区的内容由ICANN管理， 除了现有的TLD，ICANN已经开放了顶级域的注册。&lt;/li&gt;
&lt;li&gt;全球有13台根服务器(242节点)。&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;a.root-servers.net.  ~~  m.root-servers.net.。&lt;/li&gt;
&lt;li&gt;美国10台&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;A(Verisign, 6);   B(ISI, 1)&lt;/li&gt;
&lt;li&gt;C(Cogent, 6);   B(UMD, 1)&lt;/li&gt;
&lt;li&gt;E(NASA, 1);   B(ISC, 49)&lt;/li&gt;
&lt;li&gt;G(DOD, 6);   H(US Army, 2)&lt;/li&gt;
&lt;li&gt;J(Verisign, 70);   H(ICANN, 39)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;欧洲2台&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;J(RIPE NCC, 18);   H(SE, 33)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;日本1台&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;M(WIDE, 6)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/dns-base/root.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>一文读懂《区块链入门》，读完我们就是同志了</title>
            <link>http://mospany.github.io/2019/10/26/blockchain-base/</link>
            <pubDate>Sat, 26 Oct 2019 13:12:03 CST</pubDate>
            <author>Mospan</author>
            <guid>http://mospany.github.io/2019/10/26/blockchain-base/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/blockchain-base/main.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在2011年就开始听到朋友说他同学某某今年挖矿赚了一大笔钱，之后期间也陆陆续续的听到或了解一些币圈链圈的事，&lt;br /&gt;
当时对于投资投机等不以为然，时过境迁, 随着对其的慢慢了解发现未来已来，作为一名初学者，偶尔也小试牛刀，觉得还是有必要通过&lt;br /&gt;
文字与声音来记录分享，以便记录自己的成长与拥抱未来。&lt;/p&gt;

&lt;p&gt;刚开始的时候可能也会有人跟我一样有疑问， 区块链是什么？数字货币又是什么？币在哪儿买？它长得怎么样？于是乎就开始在网络上搜索，大致看到了&lt;br /&gt;
一些购买方式，但看到需要梯子在交易所之间几经转换才能买下来和觉得到未来不明朗就打了退堂鼓，现在政策扶持与国家监管下，可以了解了解该技术、行业与市场。&lt;br /&gt;
以免又发生了&amp;rdquo;看不见，看不起，看不懂，来不及&amp;rdquo;的机会丢失。&lt;/p&gt;

&lt;p&gt;由于区块链具有技术、应用和金融属性，这是它区别于其他技术的独特之处，也是比较有魅力之处，毕竟大家都喜欢升官发财嘛。重要事情说三遍：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;反对炒币、投资有风险、入市须谨慎&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;反对炒币、投资有风险、入市须谨慎&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;反对炒币、投资有风险、入市须谨慎&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面咱们聊聊区块链技术、数字货币和他们之间关系及其应用。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org073cee4&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;政策指引&#34;&gt;政策指引&lt;/h1&gt;

&lt;p&gt;国家为什么要发展区块链，而且还有上升到最高层，权威新闻发布的&amp;rdquo;四个要&amp;rdquo;为我们指引了方向。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/blockchain-base/policy1.png&#34; alt=&#34;img&#34; /&gt;&lt;br /&gt;
民生服务：为教育、商品防伪、食品安全、就业、养老、精准扶贫、医疗健康、公益、社会救助等提供更快捷、优质的服务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/blockchain-base/policy2.png&#34; alt=&#34;img&#34; /&gt;&lt;br /&gt;
智慧城市：为信息基础设施、交通、能源等城市管理提高智能化、精准化水平。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/blockchain-base/policy3.png&#34; alt=&#34;img&#34; /&gt;&lt;br /&gt;
信息共享：在信息、人才、资金、征信等信息共享。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/blockchain-base/policy4.png&#34; alt=&#34;img&#34; /&gt;&lt;br /&gt;
政务服务：为跨部门、跨地区合作提高服务体验。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org52afc5c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;俗话说区块链&#34;&gt;俗话说区块链&lt;/h1&gt;

&lt;p&gt;为了通俗的理解区块链是什么， 我打个比方举个简单但不完全恰当只为说明问题的场景例子：&lt;/p&gt;

&lt;p&gt;在某个山村里，村民A辛辛苦苦的养大一头牛打算要卖掉， 刚好村民B正缺牛耕田打算也想买牛，在咱们正常的做法是一手交钱一手交货， 于是村民B约村民A一起喝酒谈谈这桩买卖，从这家长那家短的开始聊到酒过三巡价格也基本谈拢了，村民B把钱给了村民A，村民B就把牛牵到自己家了，在正常情况下这没有问题，但在个别情况或别有用心的情况下，第二天酒醒了可能出现如下问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;村民A钱丢了，说村民B还没给钱&lt;/li&gt;
&lt;li&gt;村民A觉得卖便宜了，说村民B只给了部分钱，还有多少以后再给&lt;/li&gt;
&lt;li&gt;村民B觉得自己买贵了，说自己给了个整数村民A没有零钱，过两天找零了再退给村民B。&lt;/li&gt;
&lt;li&gt;可能还有其他极端情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两人争来争去谁也不承认，于是找来村长说一通，村长由于当时没有在现场仅凭一方说辞也很难断定谁在说假话。&lt;/p&gt;

&lt;p&gt;然而在区块链的世界里是这样的：&lt;br /&gt;
村民B约村民A牵着牛来到村子上大家平时唠嗑摆龙门阵的地方，这里有很多村民在玩，大声喊了一下说我们要买牛卖牛了大家看看怎么样，大家你一言我一语的，最终把价格谈拢了，村民B把钱给村民A并说大家都看到了哦， 我已经给钱了，谁帮我记录一下给谁点辛苦费(他们村也有统计习惯以便衡量村里经济情况)，于是人群中有人回答我带笔和记事本我记录一下吧, 记录交易详情与时间双方在上面按了手印并抄了好多页份分给了大家回家自己入册， 最后村民B牵着牛回家了，大家都相安无事。&lt;/p&gt;

&lt;p&gt;它们对应区块链的术语是这样的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;村民A卖牛给村民B =&amp;gt;  交易: 一次在区块链上完成的交易行为&lt;/li&gt;
&lt;li&gt;钱 =&amp;gt;  数字货币: 由算法生成的虚拟货币，具有易分割、易携带、总数可控的特点&lt;/li&gt;
&lt;li&gt;钱放入的口袋 =&amp;gt; 钱包: 管理数字货币地址的软件&lt;/li&gt;
&lt;li&gt;围观村民 =&amp;gt; 矿机或节点: 用来存储交易记录与赚取数字货币的计算机&lt;/li&gt;
&lt;li&gt;抢记录 =&amp;gt; 挖矿: 为了赚取数字货币而进行抢到记账优先权的计算行为，一般是计算一个随机大数，需要大量的运算保不齐哪个矿机先算出，一般分为工作量证明PoW、权益证明PoS、小蚁共识等，保证了公平和分散。&lt;/li&gt;
&lt;li&gt;按手印 =&amp;gt; 数字签名: 对交易记录进行数字签名，一串hash值仿篡改，如果交易记录改了hash值也变了。&lt;/li&gt;
&lt;li&gt;记事本 =&amp;gt; 分布账本: 所有记录交易的数据库&lt;/li&gt;
&lt;li&gt;记事页 =&amp;gt; 区块: 一定时间内的所有交易记录。&lt;/li&gt;
&lt;li&gt;辛苦费 =&amp;gt; Gas: 给矿工的辛苦费&lt;/li&gt;
&lt;li&gt;入册 =&amp;gt; 区块链:  所有区块虚拟连在一起的链。&lt;/li&gt;
&lt;li&gt;相安无事 =&amp;gt; 安全，交易有记录证明且很多份，如要篡改，按照少数服从多数原则，需得至少51%以上的记录人同意才行，想想难度可知，即51%攻击。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从上面看，一次交易是在大庭广众并有人记录中完成，具有透明交易、透明账本、可追溯、不可篡改的过程，按此类推，可适用于陌生人、生活中很多更大范围的场景。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org8f8330b&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;与数字货币的关系&#34;&gt;与数字货币的关系&lt;/h1&gt;

&lt;p&gt;货币的本质是人群共识，大家都相信它能买东西别人也认可，例如：古代的贝壳，现在的纸币等，数字货币就是一种加密货币的形式所在，区块链是数字货币的背后技术，数字货币由算法生成且增量与总量可测，研发应用团队会保留一小部分，其他大部分发行到区块链上由矿工挖取，其他人在通过法币或其他数字货币进行购买或交换而产生价值，区块链网络参与人、节点越多越频繁其数字货币就越有价值。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgbc7c241&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;部分主流数字货币&#34;&gt;部分主流数字货币&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/blockchain-base/coin-1.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BTC: 比特币，区块链上的数字货币祖师爷，总量2100万枚，最开始每10分钟生成50个比特币，每4年减半，到2140年被挖完。&lt;/li&gt;
&lt;li&gt;ETH: 一个开源的有智能合约功能的公共区块链平台币，被誉为区块链2.0代表。&lt;/li&gt;
&lt;li&gt;EOS: 为商用分布式应用设计的一款区块链操作系统，旨在实现分布式应用的性能扩展，被称为区块链3.0代表。&lt;/li&gt;
&lt;li&gt;其他：BCH、BTM等等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/blockchain-base/coin.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org368d337&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;部分钱包&#34;&gt;部分钱包&lt;/h2&gt;

&lt;p&gt;imToken 是一款去中心化的数字资产钱包。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/blockchain-base/imtoken-2.png&#34; alt=&#34;img&#34; /&gt;&lt;br /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/blockchain-base/imtoken-1.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org86e757b&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;交易所&#34;&gt;交易所&lt;/h2&gt;

&lt;p&gt;&lt;a id=&#34;org8a792be&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;otcbtc&#34;&gt;otcbtc&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/blockchain-base/otcbtc.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://otcbtc.com/&#34;&gt;otcbtc&lt;/a&gt; 作为中文版的简易便捷的场外交易平台，可支持支付宝、微信、银行卡直接交易，使得入门大大降低。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;优点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持支付宝、微信、银行卡。&lt;/li&gt;
&lt;li&gt;简单方便。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;缺点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;买卖都稍高于各个大交易所&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a id=&#34;org46681ed&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;gateio-io&#34;&gt;gateio.io&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/blockchain-base/gateio.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;优点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持支付宝、微信、银行卡。&lt;/li&gt;
&lt;li&gt;币种比较齐全，尤其是新币。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;缺点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;需要先兑换成usdt，再通过usdt购买所需的币种，两次交易较麻烦。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a id=&#34;org080feed&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;小结&#34;&gt;小结&lt;/h1&gt;

&lt;p&gt;区块链是一个比较新也比较复杂的技术系统，本着学习与分享的小学生心态，有些理解和认知不足在所难免，欢迎指正，大家一起学习，再次提醒&amp;rdquo;反对炒币、投资有风险、入市须谨慎&amp;rdquo;, 多多花时间研究其背后的技术或支持有价值有潜力的应用团队，让更多的区块链应用做到科技普惠。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>从《习总：加快区块链发展》中我们如何应对</title>
            <link>http://mospany.github.io/2019/10/25/learn-blockchain-view/</link>
            <pubDate>Fri, 25 Oct 2019 14:06:08 CST</pubDate>
            <author>Mospan</author>
            <guid>http://mospany.github.io/2019/10/25/learn-blockchain-view/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/learn-blockchain-view/main.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org4daa5cd&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;引言&#34;&gt;引言&lt;/h1&gt;

&lt;p&gt;今天一则《习总：加快推动区块链产业创新发展》新闻在圈内炸开了锅， 让曾经炽手可热现在却处于寒冬时期的区块链行业又看到了曙光， 让从业人员可以光明正大的说自己这几年是做区块链的。&lt;br /&gt;
区块链在前两年很多人见面都谈区块链， 不谈都感觉自己快融不进去马上到来的价值互联网， 随着没有现象级应用落地和资本寒冬伴随的几次大裁员大洗礼，这一行业又慢慢淡出视野谁都觉得技术是好的但不知道春天什么时候到来， 很多公司倒闭很多人转行，随着鼓励政策一出，让我们浅析下政策悟出什么并如何准备和应对。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgc8e6388&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;区块链的诞生&#34;&gt;区块链的诞生&lt;/h1&gt;

&lt;p&gt;十年前，2018年10月31日，一个化名为中本聪的人发布了一份标题为《比特币：一个点对点电子现金系统》（Bitcoin: A Peer-to-Peer Electronic Cash System）的白皮书。随后2009年1月3日，比特币系统开始运行。转眼十年间，比特币经历了非同寻常的跌宕起伏，虽然仍在遭受质疑，但它依然还在。随后在此基础上诞生了很多币，人们开始背后的技术&amp;#x2013;区块链，发现这个技术适用于很多行业，认为是继TCP/IP之后最伟大的发明，将带来天翻地覆的变革。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org36f7a78&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;主要应用场景&#34;&gt;主要应用场景&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/learn-blockchain-view/use.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数字货币：货币数字化将杜绝了假币、容易丢失、容易损坏特性，由于数字货币是经过一定区块链算法生成将可以抵制通货膨胀导致的资本贬值和交易不可篡改而导致的抵赖行为。&lt;/li&gt;
&lt;li&gt;跨境支付: 现在跨境支付需要很多金融公司等经过多天的运算和转账才能成功，如果运用区块链技术产生的币(如：比特币)只需要几分钟就可以完成，大大加快了速度与减少成本。&lt;/li&gt;
&lt;li&gt;信息共享：保持各个节点的数据一致性的，利用区块链的不可篡改和共识机制，可构建其一条安全可靠的信息共享通道。&lt;/li&gt;
&lt;li&gt;版权保护: 可以利用于音乐、著作等的版权保护，区块链的去中心化存储，保证没有一家机构可以任意篡改数据。&lt;/li&gt;
&lt;li&gt;物流链：商品从生产商到消费者手中，需要经历多个环节，每个环节都写入区块链，具有可溯源防止假货。&lt;/li&gt;
&lt;li&gt;&amp;#x2026;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;org9b18b3b&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;人物与机构&#34;&gt;人物与机构&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/learn-blockchain-view/people.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;两年前的区块链行业也曾经盛极一时，也诞生了很多大人物与公司机构，例如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;中本聪：比特币&amp;amp;区块链之父， 手握100万比特币, 比特币最高单价2万美元左右。&lt;/li&gt;
&lt;li&gt;V神：以太坊的创始人V神，推出了智能合约技术，以太坊被认为是区块链2.0.&lt;/li&gt;
&lt;li&gt;李笑来：原新东方名师，自称“中国比特币首富”，《通往财富自由之路》作者。&lt;/li&gt;
&lt;li&gt;吴忌寒：比特大陆联合创始人，研发出矿机曾经占领全球70%以上的市场， 用了三四年时间估值高达300多亿美元。&lt;/li&gt;
&lt;li&gt;何一： 曾经的币圈一姐。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;org3218f75&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;本质与发展&#34;&gt;本质与发展&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/learn-blockchain-view/develop.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;区块链短期看技术、中期看应用、长期改造社会，技术主要包含解决了拜占庭将军问题的共识机制，去中心化、分布式一致性和信用的建立。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/learn-blockchain-view/tech1.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org4e41416&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;数字货币&#34;&gt;数字货币&lt;/h1&gt;

&lt;p&gt;数字货币在区块链技术上发行， 具有交易成本低、高度匿名性和易分割特性，去中心化便于交易的特点，可存储在冷热钱包中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/learn-blockchain-view/coin.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orga459b73&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;区块链技术&#34;&gt;区块链技术&lt;/h1&gt;

&lt;p&gt;区块链中大量使用了密码学保证了资产安全，利用了默克尔树支持了轻量级验证，使得节点存储量可以非常小。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/learn-blockchain-view/crypto.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org4a3bd54&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;城市生态图&#34;&gt;城市生态图&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/learn-blockchain-view/invest-bj.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以北京为例，曾经出现了大量以区块链为中心的投资机构、公司、资讯服务、社区平台与工具等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/learn-blockchain-view/company.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgd779c09&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;小结&#34;&gt;小结&lt;/h1&gt;

&lt;p&gt;区块链是个要技术有技术，要场景有场景，希望在国家政策推动下曾经风靡一时的现象能再回来，出现很多现象级应用改善现有社会，作为普通人的我们可以有钱出钱有力出力， 投资好可以高回报，有技术出力研发出有用好用的产品， 让互联网和资本走出寒冬， 大环境变好后至少大家好找工作赚到钱不更好么？&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>编辑器终结者: vim与emacs双剑合璧</title>
            <link>http://mospany.github.io/2019/10/17/vim-in-emacs/</link>
            <pubDate>Thu, 17 Oct 2019 13:54:40 CST</pubDate>
            <author>Mospan</author>
            <guid>http://mospany.github.io/2019/10/17/vim-in-emacs/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/vim-in-emacs/main.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgdbd1829&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;神器传说&#34;&gt;神器传说&lt;/h1&gt;

&lt;p&gt;在猿的世界里，流传着两大神器的传说： 一个是神的编辑器Emacs，另一个是编辑器之神Vim。&lt;br /&gt;
追求独步天下的高手为了得到它驾驭它，在江湖里宣起了几十年的血雨腥风至今任无法收拾呈蔓延趋势:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有的把Emacs比作屠龙宝刀，Vim则是倚天剑， 有“武林至尊，宝刀屠龙，号令天下，莫敢不从，倚天不出，谁与争锋”之势。&lt;/li&gt;
&lt;li&gt;用Emacs的是海盗， 用Vim的是忍者。Emacs大而全， Vi小而快，Vi有两大模式：“命令模式”和“插入模式”，分别对应忍者的：“匿踪模式”和“战斗模式”；&lt;/li&gt;
&lt;li&gt;性子暴躁的喜欢vim，性格平缓的喜欢emacs，用vim能让你享受到敲击出噼里啪啦的肌肉快感， 而用emacs却能让心如止水、修心养性的感受。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;怎么样才能做到神在使用编辑器之神呢？&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org9bee0d2&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;追寻编辑器的心路历程&#34;&gt;追寻编辑器的心路历程&lt;/h1&gt;

&lt;p&gt;猿在江湖漂为了少挨刀，要么追求绝世武功，要么无上兵器，功夫不负有心人，最终找到它前也一路坎坷：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一次见到师傅习武，仍是DOS时代使用的Turbo C（妈呀暴露年龄了），只见白色光标在蓝屏之间闪烁挥之不去。&lt;/li&gt;
&lt;li&gt;进入师门后先后经历了notepad、UltraEdit、visual c++ 6.0等刀、枪、剑、戟、斧、钺、钩、叉、鞭、锏、锤、挝、镋、棍、槊、棒、拐、流星锤十八种兵器，打下十八铜人阵拿到双证后下山出道。&lt;/li&gt;
&lt;li&gt;出道后先后尝试用了UltraEdit、visual c++ 6.0、sourceinsight、eclipse、sublime text、VS Code、Vim等始终不尽如意。&lt;/li&gt;
&lt;li&gt;直到后来遇见emacs， 才感受到了它的强大，作为一个伪装成的编辑器的操作系统，用着用着有时想单手操作，于是想到了把vim集成到emacs，既能享受到了emacs的强大又能用到vim的快捷，每天都有左右互博的久违感觉，目前已用多年再也纠结其他编辑器认定了它就是唯一的终极编辑器。&lt;/li&gt;
&lt;li&gt;为什么喜欢全键盘的终端模式而不用带鼠标的现在GUI IDE环境， 一个是全键盘更快更能专注其中， 而是现在已是云时代部署在公司开发时到家里也即可使用而不用同步不用每天背mbp回来，终端模式是最好的选择。&lt;/li&gt;
&lt;li&gt;都说编辑器分为三种， 一种是Vim，一种是emacs，剩下的就是Other， 你是属于哪一种呢？ 欢迎在留言下方分享您的使用心得。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;它们大致学习曲线如下：&lt;br /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/vim-in-emacs/learning-curves.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org3716a5b&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;安装配置&#34;&gt;安装配置&lt;/h1&gt;

&lt;p&gt;要想在emacs使用vim，其实是在emacs配置中增加Vim模拟器evil-mode即可。&lt;br /&gt;
先从官网下载git clone git://gitorious.org/evil/evil.git到.emacs.d下再安装,&lt;br /&gt;
在配置文件里.emacs或init.el里增加如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(add-to-list &#39;load-path &amp;quot;~/.emacs.d/evil&amp;quot;)
(require &#39;evil)
(evil-mode 1)
;(setq evil-default-state &#39;emacs) ;; emacs-mode
(setq evil-default-state &#39;normal) ;; vim-normal-mode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要在emacs和vim模式里面随意切换使用：C-z。&lt;br /&gt;
也可以把emacs中想用的功能映射到evil-mode下，这样就可以拥有了emacs中所有功能的快捷操作方式，它大致配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; I learn this trick from ReneFroger, need latest expand-region
;; @see https://github.com/redguardtoo/evil-matchit/issues/38
(define-key evil-visual-state-map (kbd &amp;quot;v&amp;quot;) &#39;er/expand-region)
(define-key evil-insert-state-map (kbd &amp;quot;C-e&amp;quot;) &#39;move-end-of-line)
(define-key evil-insert-state-map (kbd &amp;quot;C-k&amp;quot;) &#39;kill-line)
(define-key evil-insert-state-map (kbd &amp;quot;M-j&amp;quot;) &#39;yas-expand)
(define-key evil-emacs-state-map (kbd &amp;quot;M-j&amp;quot;) &#39;yas-expand)
(global-set-key (kbd &amp;quot;C-r&amp;quot;) &#39;undo-tree-redo)

;; My frequently used commands are listed here
(setq evil-leader/leader &amp;quot;,&amp;quot;)
(require &#39;evil-leader)
(evil-leader/set-key
 ;windowmove
 &amp;quot;wh&amp;quot; &#39;windmove-left
 &amp;quot;wl&amp;quot; &#39;windmove-right
 &amp;quot;wk&amp;quot; &#39;windmove-up
 &amp;quot;wj&amp;quot; &#39;windmove-down
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体可参考&lt;a href=&#34;https://github.com/mospany/emacs.d-for-linux/blob/master/config/init-evil.el即可&#34;&gt;https://github.com/mospany/emacs.d-for-linux/blob/master/config/init-evil.el即可&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orge046aca&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;emacs功能概览&#34;&gt;emacs功能概览&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;收发电子邮件&lt;/li&gt;
&lt;li&gt;通过FTP/TRAMP编辑远程档案&lt;/li&gt;
&lt;li&gt;通过Telnet登录主机&lt;/li&gt;
&lt;li&gt;上新闻组&lt;/li&gt;
&lt;li&gt;对多种编程语言的编辑&lt;/li&gt;
&lt;li&gt;调试程序，结合GDB，EDebug等，支持C/C++，Perl，&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Python，Lisp等等&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;玩游戏&lt;/li&gt;
&lt;li&gt;管理日程，Task，ToDo，约会等&lt;/li&gt;
&lt;li&gt;个人信息管理&lt;/li&gt;
&lt;li&gt;文件比较&lt;/li&gt;
&lt;li&gt;阅读info和man文档&lt;/li&gt;
&lt;li&gt;浏览网站&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为各种程序（TeX等）提供统一的操作界面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/vim-in-emacs/emacs-frame.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;org166e498&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;文档编辑&#34;&gt;文档编辑&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;写文档(org)&lt;/li&gt;
&lt;li&gt;做幻灯片(beamer)&lt;/li&gt;
&lt;li&gt;做表格&lt;/li&gt;
&lt;li&gt;列编辑(cua)&lt;/li&gt;
&lt;li&gt;记笔记(evernote)&lt;/li&gt;
&lt;li&gt;写博客(cnblogs)&lt;/li&gt;
&lt;li&gt;时间管理(gtd)&lt;/li&gt;
&lt;li&gt;任务计划(gtd)&lt;/li&gt;
&lt;li&gt;思维导图(freemind)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;orgb22db31&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;org-mode&#34;&gt;Org-mode&lt;/h2&gt;

&lt;p&gt;Org-模式（Org-mode）是文本编辑软件Emacs的一种支持内容分级显示的编辑模式。&lt;br /&gt;
这种模式支持写 to-do 列表，日志管理，做笔记，做工程计划或者写网页。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/vim-in-emacs/org-mode.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgf33b210&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;编程相关&#34;&gt;编程相关&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;适用多种语言编写&lt;/li&gt;
&lt;li&gt;代码阅读(XCscope和ecb)&lt;/li&gt;
&lt;li&gt;代码调试(gdb)&lt;/li&gt;
&lt;li&gt;代码搜索定位(grep)&lt;/li&gt;
&lt;li&gt;代码着色&lt;/li&gt;
&lt;li&gt;自动补全&lt;/li&gt;
&lt;li&gt;统一注释格式(doxymacs)&lt;/li&gt;
&lt;li&gt;代码折叠&lt;/li&gt;
&lt;li&gt;智能编译&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;org4dcec9d&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;版本控制-git&#34;&gt;版本控制(git)&lt;/h2&gt;

&lt;p&gt;在emacs用git功能，更加方便的进行git库的提交/查看等版本控制功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/vim-in-emacs/emacs-git.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgc0f6593&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;休闲娱乐&#34;&gt;休闲娱乐&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;看电影听音乐(EMMS)&lt;/li&gt;
&lt;li&gt;心理医生(doctor)&lt;/li&gt;
&lt;li&gt;游戏(俄罗斯方块/贪食蛇)&lt;/li&gt;
&lt;li&gt;屏幕保护(zone)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;orgfc36767&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;看电影听音乐-emms&#34;&gt;看电影听音乐(EMMS)&lt;/h2&gt;

&lt;p&gt;EMMS 让你可以在 Emacs 里面播放多媒体文件，他被设计的小巧干净，使用外部 播放器进行播放。是一个小巧、可扩展的完全由 Elisp写成的多媒体系统，支持 多种音频、视频格式以及流媒体播放(这事实上由你所使用的播放器决定)，可以 进行标签操作、方便的播放列表管理以及打分制度，&lt;br /&gt;
总之，这正是我想要的。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgefe8084&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;听音乐&#34;&gt;听音乐&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/vim-in-emacs/emacs-music.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org71fcae1&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;看电影&#34;&gt;看电影&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/vim-in-emacs/emacs-movice.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org2740f5f&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;游戏&#34;&gt;游戏&lt;/h2&gt;

&lt;p&gt;俄罗斯方块或贪食蛇等&lt;br /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/vim-in-emacs/emacs-game.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgded90a9&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;做美食&#34;&gt;做美食&lt;/h1&gt;

&lt;p&gt;&lt;a id=&#34;orgebe7bab&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;煮咖啡-炒川菜&#34;&gt;煮咖啡、 炒川菜&lt;/h2&gt;

&lt;p&gt;RFC中支持超文本咖啡壶协议（RFC2324）与茶壶协议(RFC7168),而emacs提供了完全支持RFC2323的coffee.el插件提供控制展示界面，只要你有一根网线，加一个支持此协议的咖啡壶，你确实可以用emacs煮咖啡，甚至有人已经用它来炒过川菜。&lt;br /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/vim-in-emacs/emacs-cook.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>为什么老家得有房</title>
            <link>http://mospany.github.io/2019/10/14/go-home-build-house/</link>
            <pubDate>Mon, 14 Oct 2019 14:17:41 CST</pubDate>
            <author>Mospan</author>
            <guid>http://mospany.github.io/2019/10/14/go-home-build-house/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/go-home-build-house/main.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;很多农村人到城市里打工或工作，不怎么在农村老家住了，但还要在老家建一座新房，这是为什么呢？&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orga367a76&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;老家才是永远的根&#34;&gt;老家才是永远的根&lt;/h1&gt;

&lt;p&gt;无论在哪里谋生，只要老家的房子还在，那就还有一条退路，还有一个寄托。如果老家的房子都没有了，那就像无根浮萍，灵魂永远没有寄托。&lt;br /&gt;
虽然人可以搬进城里，但是亲情搬不走，只要老家的房子还在，隔三差五的回去看看，这个家就还是一个完整的家，一个团聚的家。房子没了，家也散了，亲情也淡了，那是花多少钱也弥补不回来的。&lt;br /&gt;
很多现在在外打拼的人，以后还是要回到农村养老的,回到乡下老家，养养鸡、种种菜、钓钓鱼，平日里喝点小酒、打点小牌，生命是从这里开始的，再从这里结束。&lt;/p&gt;

&lt;p&gt;对于大多数农村出来的人来说，外面的房子，只是一个住所，老家的房子，才是真正的家。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgb73086d&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;最好吃的永远是家乡菜&#34;&gt;最好吃的永远是家乡菜&lt;/h1&gt;

&lt;p&gt;&lt;a id=&#34;org87e2a8a&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;在城市里只有工作没有生活&#34;&gt;在城市里只有工作没有生活&lt;/h1&gt;

&lt;p&gt;&lt;a id=&#34;org51360fb&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;蜗居在城市向往着豪宅&#34;&gt;蜗居在城市向往着豪宅&lt;/h1&gt;

&lt;p&gt;&lt;a id=&#34;org4168492&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;美好的回忆很多都在儿时的老家&#34;&gt;美好的回忆很多都在儿时的老家&lt;/h1&gt;

&lt;p&gt;&lt;a id=&#34;org6df280d&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;返璞归真-回归田园风光&#34;&gt;返璞归真，回归田园风光&lt;/h1&gt;

&lt;p&gt;&lt;a id=&#34;orgc371da2&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;新农村建设越来越好&#34;&gt;新农村建设越来越好&lt;/h1&gt;

&lt;p&gt;&lt;a id=&#34;org8f4993c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;现在不盖房以后回不去了&#34;&gt;现在不盖房以后回不去了&lt;/h1&gt;
</description>
        </item>
        
        <item>
            <title>又见春哥，OR沙龙现场记实</title>
            <link>http://mospany.github.io/2019/08/11/openresty-salon-site-record/</link>
            <pubDate>Sun, 11 Aug 2019 05:54:34 CST</pubDate>
            <author>Mospan</author>
            <guid>http://mospany.github.io/2019/08/11/openresty-salon-site-record/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/openresty-salon/main.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgbe7fbb9&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;引言&#34;&gt;引言&lt;/h1&gt;

&lt;p&gt;第一次见到春哥本尊(活体)是在2015年是在360举行的openresty大会，历经4年再次在北京现场感受春哥技术热情与现场号召力，即使收了99元门票费现场200个座位座无虚席， 就像开个人演唱会一样，一个人演讲一下午非常辛苦，没有人提前离开，可见春哥在技术圈的影响力。这么说吧， 在中国认为最能拿得出手的开源项目就两个，一个是章文嵩博士开启现在比较稳定变化不大的&lt;a href=&#34;http://zh.linuxvirtualserver.org/&#34;&gt;LVS&lt;/a&gt;项目， 另外一个是章亦春发起在全球广泛使用还在蓬勃发展的&lt;a href=&#34;https://openresty.org/cn/&#34;&gt;openresty&lt;/a&gt;项目，可以说双章把中国开源技术带到世界先进水平。
这次大会春哥认真准备了4份PPT，现场演示了很多技巧，亮点多多，我个人认为最大的亮点有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;动态追踪技术&lt;/li&gt;
&lt;li&gt;各种小语言及周边库建设&lt;/li&gt;
&lt;li&gt;编程与禅修&lt;/li&gt;
&lt;li&gt;&amp;#x2026;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;免责声明&lt;/strong&gt;
如下为本人记录本次技术沙龙部分精要和个人理解，如有错误之处，欢迎指正。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orge0a96ba&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;会议流程&#34;&gt;会议流程&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Openresty北京技术沙龙&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;时间：8 月 10 日（周六）13:30-19:00&lt;/li&gt;
&lt;li&gt;地点：北京丽都皇冠假日酒店（北京朝阳区将台路6号）酒店二层宴会厅A&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/openresty-salon/meeting.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org731738c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;部分精要&#34;&gt;部分精要&lt;/h1&gt;

&lt;p&gt;&lt;a id=&#34;orgae2f336&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;应用开发&#34;&gt;应用开发&lt;/h2&gt;

&lt;p&gt;基于Openresty开发应用的优势：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;小巧&lt;/strong&gt;: lua作为嵌入式脚本放在openresty和游戏中开发很小巧&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高效&lt;/strong&gt;: lua开发非常高效，比用C开发nginx模块要高效很多，入门门槛也低。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成熟稳定&lt;/strong&gt;: 已经大规模广泛商业应用，尤其现在CDN行业基本都用openresty作为前端。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全动态&lt;/strong&gt;: 可以通过edge语言生成不用重启即可生效，程序既数据，数据既程序。&lt;/li&gt;
&lt;li&gt;&amp;#x2026;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/openresty-salon/compare-go.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org6d60254&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;

&lt;p&gt;刚开始写openresty主要是想通过它来做一个完整的blog，包含前后端的webserver，目前openresty做着做着发现在CDN领域应该广泛，它主要应用场景:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;命令行应用(编译器、系统编程工具、测试工具)&lt;/li&gt;
&lt;li&gt;网关类型应用(API、负载均衡、CDN等)&lt;/li&gt;
&lt;li&gt;Web应用(连接数据库、memcached、redis等等)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;orga82b642&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;测试驱动&#34;&gt;测试驱动&lt;/h3&gt;

&lt;p&gt;现在主要通过测试驱动学习、测试驱动开发方法，早期主要抄书，通过肌肉记忆，当抄到一大半时候不懂的慢慢就懂了，看似抄书节奏放慢其实可以更好的理解，书读百遍其义自现。早期抄书有些时候主要是书都是借的，不抄的话以后就看不到了，还透露有些书废寝忘食的抄完后，朋友看自己那么喜欢这本书就说这本书就送给你吧，自己哭笑不得，白抄那么累了。&lt;/p&gt;

&lt;p&gt;自己怎么在两三月内精通nginx核心会开发C模块，一边抄代码一边通过&lt;a href=&#34;https://metacpan.org/pod/Test:Nginx&#34;&gt;Test:Nginx&lt;/a&gt;测试驱动学习开发。它的第一个nginx开源项目&lt;a href=&#34;https://github.com/openresty/echo-nginx-module&#34;&gt;echo-nginx-module&lt;/a&gt;是这样完成的，即使现在还是很多人学习入手nginx的基础, nginx echo模块是在nginx程序上扩展了echo输出字符的功能, 对于调试很方便。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgb810c07&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;resty-cli&#34;&gt;Resty CLI&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;resty -e &#39;ngx.(&amp;quot;hello,world!&amp;quot;)

restydoc ngx.pipe

restydoc -s content_by_lua
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;orge6eaafd&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;resty&#34;&gt;resty&lt;/h3&gt;

&lt;p&gt;resty-cli - OpenResty的高级命令行实用程序，可以像使用 lua 或者 luajit 命令行工具一样直接从命令行运行 resty 命令行实用程序来运行openresty脚本。 它可以使用 OpenResty Lua创建各种命令行实用程序， 现场演示了下该命令与其他语言如python、perl、nodejs等性能对比，都优于python、nodejs。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgebad122&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;restydoc&#34;&gt;restydoc&lt;/h3&gt;

&lt;p&gt;OpenResty 附带了非常完善的用户参考手册 restydoc，提供与 UNIX 手册 man 相同的功能，可以检索 OpenResty 里所有组件的帮助文档，包括但不限于：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OpenResty 各个组件的介绍和用法；&lt;/li&gt;
&lt;li&gt;OpenResty 指令和功能接口的用法；&lt;/li&gt;
&lt;li&gt;Nginx 介绍、用法、基本工作原理；&lt;/li&gt;
&lt;li&gt;Lua/LuaJIT 语法要素。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;org85f1347&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;调试与调优&#34;&gt;调试与调优&lt;/h2&gt;

&lt;p&gt;通过打印日志可以解决大部分的问题，通过动态追踪可以解决高层次的问题。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;打印日志&lt;/li&gt;
&lt;li&gt;测试驱动&lt;/li&gt;
&lt;li&gt;动态追踪(火焰图、SystemTap、GDB、OpenResty Trace)&lt;/li&gt;
&lt;li&gt;Openresty Cloud&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;orgac11789&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;如何编写高效的lua代码&#34;&gt;如何编写高效的Lua代码&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;避免或减少在热代码路径上创建GC对象(string、table、function)&lt;/li&gt;
&lt;li&gt;lua-tablepool&lt;/li&gt;
&lt;li&gt;避免闭包&lt;/li&gt;
&lt;li&gt;尽量使用Lua模块&lt;/li&gt;
&lt;li&gt;拼接字符串的正确做法&lt;/li&gt;
&lt;li&gt;让热代码路径被JIT编译&lt;/li&gt;
&lt;li&gt;自动优化的可能性(lux编译器)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;orgfb483ca&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;更多的开源教程与演示视频&#34;&gt;更多的开源教程与演示视频&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;blog.openresty.com&lt;/li&gt;
&lt;li&gt;youtube/bilibili&lt;/li&gt;
&lt;li&gt;由Openresty Showman批量制作&lt;/li&gt;
&lt;li&gt;由Openresty Trace展示软件内部真实细节&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;orgbff1b17&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;怎样阅读openresty源码&#34;&gt;怎样阅读openresty源码&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Nginx核心&lt;/li&gt;
&lt;li&gt;LuaJit核心&lt;/li&gt;
&lt;li&gt;ngx_http_lua等模块&lt;/li&gt;
&lt;li&gt;lua-resty-*标准库&lt;/li&gt;
&lt;li&gt;按需阅读，只读核心代码路径&lt;/li&gt;
&lt;li&gt;学习代码风格规范: &lt;a href=&#34;https://openresty.org/en/c-coding-style-guide.html&#34;&gt;https://openresty.org/en/c-coding-style-guide.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;org05de733&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;核心开发&#34;&gt;核心开发&lt;/h1&gt;

&lt;p&gt;核心开发主要讲解主题如下，由于没有完全听懂先列出主题，以后再分解。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Openresty核心结构&lt;/li&gt;
&lt;li&gt;luajit内部实现结构&lt;/li&gt;
&lt;li&gt;全新的基于luajit ffi的Lua API实现&lt;/li&gt;
&lt;li&gt;全新的ngx_meta_lua模块&lt;/li&gt;
&lt;li&gt;Test:Nginx测试台&lt;/li&gt;
&lt;li&gt;valgrind测试模式&lt;/li&gt;
&lt;li&gt;mockeagain测试模式&lt;/li&gt;
&lt;li&gt;memcheck模式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/openresty-salon/test-nginx.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgfac76d2&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;小语言与周边建设&#34;&gt;小语言与周边建设&lt;/h1&gt;

&lt;p&gt;春哥曾经说过要学习好技术，主要是：英语、数学、计算机科学，我个人认为计算机科学里最主要的是计算机操作系统、算法、编译原理，曾经有个老师说如何衡量你对某个语言的理解程度，就看你是否自己写出其编译器，再用自己写的编译器与官方编译器对比，就是你对这个语言的理解程度，到目前为止个人还没写过编译器表示汗颜。 他本次分享自己写的小语言如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OpsLang: 更高效更智能的自动化运维语言&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OpsLang 快速上手
&lt;a href=&#34;https://doc.openresty.com.cn/zh/opslang/&#34;&gt;https://doc.openresty.com.cn/zh/opslang/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/openresty-salon/opslang.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;edgelang: 更加接近自然语言，使用更短的语句可翻译生成lua代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Edge 语言用户手册
&lt;a href=&#34;https://doc.openresty.com.cn/zh/edgelang/&#34;&gt;https://doc.openresty.com.cn/zh/edgelang/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/openresty-salon/edgelang.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fanlang: 类似DSL基于Perl 6语言的语法设计&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;fanlang 用户手册
&lt;a href=&#34;https://doc.openresty.com.cn/en/fanlang/&#34;&gt;https://doc.openresty.com.cn/en/fanlang/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/openresty-salon/fanlang.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ylang:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ylang 用户手册
&lt;a href=&#34;https://doc.openresty.com.cn/en/ylang/&#34;&gt;https://doc.openresty.com.cn/en/ylang/&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ylua:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ylua 用户手册
&lt;a href=&#34;https://doc.openresty.com.cn/en/ylua/&#34;&gt;https://doc.openresty.com.cn/en/ylua/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgb9642fe&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;动态追踪&#34;&gt;动态追踪&lt;/h1&gt;

&lt;p&gt;动态追踪技术是一种不用停机停程序、不用修改当前代码情况下的一种调试调优技术，它的一般原理如下：
&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/openresty-salon/dtrace.jpeg&#34; alt=&#34;img&#34; /&gt;
他还现场演示了如何使用动态追踪技术观察程序内部真实细节和不改代码加入探针调试，大致原理是把各种语言都编译成ylang中间语言进行调试。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/openresty-salon/dtrace-stats.jpeg&#34; alt=&#34;img&#34; /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/openresty-salon/dtrace-lua.jpeg&#34; alt=&#34;img&#34; /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/openresty-salon/dtrace-c.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;动态追踪技术详见春哥写的：&lt;a href=&#34;https://openresty.org/posts/dynamic-tracing/&#34;&gt;动态追踪技术漫谈&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgf244bdd&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;编程与禅修&#34;&gt;编程与禅修&lt;/h1&gt;

&lt;p&gt;技术的尽头是宗教，炒币的尽头是嫩模，编程就像学习各种武功，当武功越高毒素越多，需要像佛法之类的心法来综合，一个修外一个修内，武功越高需要的佛法也越高，否则会走火入魔的。&lt;/p&gt;

&lt;p&gt;人们通常说的四禅八定，属于修世间禅的层次和境界。世间禅的禅定层次恰好与三界层次一样，三界是欲界、色界、无色界。世间禅中，欲界中的定有欲界定、未到地定两种。佛家认为，这两种所谓的定，不能算是真正的人定，只是达到身心初步的轻安，为进人四禅八定作准备而已。四禅八定指初禅、二禅、三禅、四禅及空无边处定、识无边处定、无所有处定、非想非非想处定八种依次升进的坐禅人定层次和境界。坐禅者人定，如果依次达到初禅、二禅、三禅、四禅四种境界，就能自然达到脱离欲界众生共同具有的饮食男女之欲，但心念中仍有固定形态的物质身体存在，故名色界四禅。坐禅者如果修过色界四禅，再依次人空无边处定、识无边处定、无所有处定、非想非非想处定四种定者，修持者意识中已没有物质身体的存在，故名无色界四定，也叫四空定。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org25b3296&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;推荐书&#34;&gt;推荐书&lt;/h1&gt;

&lt;p&gt;春哥在会上唯一推荐的书是《&lt;a href=&#34;https://item.jd.com/43659041937.html&#34;&gt;The Practice of Programming&lt;/a&gt;》, 对应的中文版为《&lt;a href=&#34;https://item.jd.com/31648488755.html&#34;&gt;程序设计实践&lt;/a&gt;》,建议读英文版本，春哥说这本书读了很多年很多次，每次读都有新的体会新的收获。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org3beb885&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;小结&#34;&gt;小结&lt;/h1&gt;

&lt;p&gt;一入技术深似海(可能还没入门), 同样是80后人与人差距啥这么大呢，有些时候感觉人与人之间的差距甚至大于人与动物之间的差距，路漫漫其修远兮，吾将上下而求索。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>IPv6时代已来，您Get了多少？</title>
            <link>http://mospany.github.io/2019/08/09/ipv6-base/</link>
            <pubDate>Fri, 09 Aug 2019 17:14:27 CST</pubDate>
            <author>Mospan</author>
            <guid>http://mospany.github.io/2019/08/09/ipv6-base/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/ipv6-base/ipv6-main.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org64c0c7c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;为什么要用ipv6&#34;&gt;为什么要用IPv6&lt;/h1&gt;

&lt;p&gt;如今互联网主要使用IPv4, 感觉已经蓬勃发展了够用了，那为什么还需要使用IPv6呢？主要有如下原因：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IPv4地址匮乏&lt;/li&gt;
&lt;li&gt;NAT非根本解决办法，破坏了端到端模型&lt;/li&gt;
&lt;li&gt;新技术对IP协议催生了更多的需求&lt;/li&gt;
&lt;li&gt;政策驱动: 计划使用5-10年的时间建成全球最大的IPv6商用网络。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;随着5G、IOT万物互联的到来，IPv4已经不方便或不能承载如此大的需求了，更多的应用呼吁着IPv6尽快落地。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgfda1432&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;ipv6优势&#34;&gt;IPv6优势&lt;/h1&gt;

&lt;p&gt;既然IPv4有以上不足，那IPv6有什么优势呢？主要如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;近乎无限的地址空间&lt;/li&gt;
&lt;li&gt;更简洁的报文头部&lt;/li&gt;
&lt;li&gt;内置的安全性&lt;/li&gt;
&lt;li&gt;更好的QoS支持&lt;/li&gt;
&lt;li&gt;更好的移动性&lt;/li&gt;
&lt;li&gt;编址层次等级&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;orgd14bab5&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;ipv6技术&#34;&gt;IPv6技术&lt;/h1&gt;

&lt;p&gt;&lt;a id=&#34;orgf199107&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;标准-rfc&#34;&gt;标准(RFC)&lt;/h2&gt;

&lt;p&gt;IPv6协议由很多RFC组成，IPv6协议族RFC如下， 其中&lt;br /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/ipv6-base/ipv6-rfc.png&#34; alt=&#34;img&#34; /&gt;&lt;br /&gt;
RFC5942 - IPv6子网模式：链路和子网前缀间的关系&lt;br /&gt;
RFC5569 - IPv4/IPv6过渡技术之—— 6rd&lt;br /&gt;
RFC3056 - IPv4/IPv6过渡技术之—— 6to4&lt;br /&gt;
RFC2473 - IPv6标准中的通用分组隧道化&lt;br /&gt;
RFC6333 - IPv4/IPv6过渡技术之——双栈精简版&lt;br /&gt;
RFC5214 - IPv4/IPv6过渡技术之——ISATAP&lt;br /&gt;
RFC4213 - IPv6主机和路由器的基本转换机制-双栈和隧&lt;br /&gt;
RFC3775 - IPv6中的移动性支持&lt;br /&gt;
RFC3053 - IPv4/IPv6过渡技术之——隧道代理&lt;br /&gt;
RFC6434 - 对IPv6节点的要求&lt;br /&gt;
RFC4294 - 对IPv6节点的要求&lt;br /&gt;
RFC4294 - IPv6的默认地址选择&lt;br /&gt;
RFC6071 - IP安全(IPsec)&lt;br /&gt;
RFC5340 - IPv6的动态路由协议OSPFv3&lt;br /&gt;
RFC3315 - DHCPv6&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org2a08aaa&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;报文格式&#34;&gt;报文格式&lt;/h2&gt;

&lt;p&gt;IPv6报文格式与IPv4有一定相似，但比它简化和固定了好多，这样更容易解析与传输。&lt;br /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/ipv6-base/ipv6-header.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org8d4e87c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;地址&#34;&gt;地址&lt;/h2&gt;

&lt;p&gt;巨大的地址空间, 相当于地球上每粒沙子都有自己的地址。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IPv4&lt;/strong&gt;&lt;br /&gt;
地址长度：32位&lt;br /&gt;
地址空间：2的32次方，约42亿(世界上平均3个人有2个IP地址)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IPv6&lt;/strong&gt;&lt;br /&gt;
地址长度：128位&lt;br /&gt;
地址空间：2的128次方，约3.4 x 10^38个(地球上的每一粒沙子都有IP地址)&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgdc9712e&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;表示&#34;&gt;表示&lt;/h3&gt;

&lt;p&gt;非压缩： 2001:0da8:0207:0000:0000:0000:8207&lt;br /&gt;
  压缩前导0：2001:0da8:0207:0:0:0:0:8207&lt;br /&gt;
  压缩: 2001:0d08:0207::8207     注：只能有一个::&lt;br /&gt;
  内嵌IPv4地址： ::192.168.1.1&lt;br /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/ipv6-base/ipv6-addr.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgb488b46&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;分类&#34;&gt;分类&lt;/h3&gt;

&lt;p&gt;IPv6也分单播、组播，但没有了广播，增加了任播anycast，它允许同一个IP配置在多台服务器上，通过路由的方式自动访问离用户的最近的服务器上去。&lt;br /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/ipv6-base/addr-type.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org5489189&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;手工配置&#34;&gt;手工配置&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;添加IPv6地址&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip -6 addr add &amp;lt;ipv6address&amp;gt;/&amp;lt;prefixlength&amp;gt; dev &amp;lt;interface&amp;gt;

ip -6 addr add 2001::1/64 dev eth0

ifconfig &amp;lt;interface&amp;gt; inet6 add &amp;lt;ipv6address&amp;gt;/&amp;lt;prefixlength&amp;gt; 

ifconfig eth0 inet6 add 2001::1/64
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加默认路由&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip -6 route add &amp;lt;ipv6address&amp;gt;/&amp;lt;prefixlength&amp;gt; via &amp;lt;ipv6address&amp;gt;

ip -6 route add default via 2001::1 

route -A inet6 add &amp;lt;ipv6address&amp;gt;/&amp;lt;prefixlength&amp;gt; gw

route -A inet6 add default gw 2001::1 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看路由&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip -6 route show

route -6
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a id=&#34;org956a030&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;无状态配置&#34;&gt;无状态配置&lt;/h3&gt;

&lt;p&gt;IPv6的无状态配置是比较吸引我的一个特点，只要路由器支持插上网线就自动分配到全球唯一的地址就能自动联网。&lt;br /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/ipv6-base/auto-1.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/ipv6-base/auto-2.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orge70663c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;

&lt;p&gt;&lt;a id=&#34;orgfd8171c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;查看ip&#34;&gt;查看ip&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;ip -6 addr 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;orga991404&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;查看路由&#34;&gt;查看路由&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;ip -6 route
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;orgf2c7e21&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;查看多播地址&#34;&gt;查看多播地址&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;ip -6 maddr
netstat -gn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;org04efb87&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;查看dns-aaaa记录-走ipv4路线&#34;&gt;查看dns AAAA记录(走IPv4路线)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;dig -t AAAA www.xxx.com
nslookup -query=AAAA www.xxx.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;orgbaf5477&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;查看dns-aaaa记录-走ipv6路线&#34;&gt;查看dns AAAA记录(走IPv6路线)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;dig @2001::1 -6 -t AAAA www.xxx.com
nslookup -query=AAAA www.xxx.com 2001::1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;orgdb01478&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;查看dns-aaaa记录-走ipv6路线-最完整-最靠谱的办法&#34;&gt;查看dns AAAA记录(走IPv6路线, 最完整，最靠谱的办法)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;dig @2001::1 -6 -t AAAA www.xxx.com +trace
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;orgb5ed7a7&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;curl&#34;&gt;curl&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;curl -6 https://www.xxx.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;orgd4f50fc&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ping&#34;&gt;ping&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;ping6 www.xxx.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;orgfe8a668&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;trace-route&#34;&gt;trace route&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mtr -6 www.xxx.com
traceroute6 www.xxx.com 
tracert6 www.xxx.com 
tracepath6 www.xxx.com 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;org5f9751c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ping-1&#34;&gt;ping&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;ping6 www.xxx.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;orgc80feba&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;邻居地址解析-类似ipv4中的arping&#34;&gt;邻居地址解析，类似IPv4中的arping&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;ndisc6 -n 2001::1 eth0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;org631a50c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;iptables&#34;&gt;iptables&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;ip6tables-save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;orgfd17b8c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;tcpdump&#34;&gt;tcpdump&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;tcpdump -nnn -i eth0 ip6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a id=&#34;org46e39eb&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;在线工具&#34;&gt;在线工具&lt;/h2&gt;

&lt;p&gt;&lt;a id=&#34;org6ac0034&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;公共dns列列表&#34;&gt;公共dns列列表&lt;/h3&gt;

&lt;p&gt;地址: &lt;a href=&#34;http://dns.icoa.cn/ipv6/&#34;&gt;http://dns.icoa.cn/ipv6/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org49d22ec&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;查询-网站是否提供ipv6&#34;&gt;查询⽹网站是否提供IPv6&lt;/h3&gt;

&lt;p&gt;地址:&lt;br /&gt;
&lt;a href=&#34;https://ready.chair6.net/&#34;&gt;https://ready.chair6.net/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://ip6tools.com/#checkWebServer&#34;&gt;http://ip6tools.com/#checkWebServer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org91f5e2c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;查询我-自-己是否拥有公-网ipv6地址&#34;&gt;查询我⾃自⼰己是否拥有公⽹网IPv6地址&lt;/h3&gt;

&lt;p&gt;地址：&lt;br /&gt;
&lt;a href=&#34;http://www.test-ipv6.com&#34;&gt;http://www.test-ipv6.com&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://ip6tools.com/#WhatisMyIPv6Address&#34;&gt;http://ip6tools.com/#WhatisMyIPv6Address&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org6e6f575&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;协议栈&#34;&gt;协议栈&lt;/h2&gt;

&lt;p&gt;IPv6与IPv4协议栈比较相似，经过精心设计后去掉了不少冗余或不合理部分，代码部分将近少了一半，使得更加简洁强大。&lt;br /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/ipv6-base/ipv6-stack.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;org7b102ac&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;现状&#34;&gt;现状&lt;/h1&gt;

&lt;p&gt;IPv6目前用户覆盖率还不高，尤其是中国, 主要原因是钱，运营商通过维护或改造现有IPv4网络基本满足了目前大家的使用要求，在没有其他利益或政策驱动下很难主动自己贴钱去升级网络，再者需要大家都升级后才能完全使用，谁不愿意劳民伤财的去干这件事。但随着中国想努力引领世界，在政策与应用驱动下IPv6将大大加快。&lt;br /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/ipv6-base/ipv6-now.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;orgc6aa769&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;过渡技术&#34;&gt;过渡技术&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/ipv6-base/ipv6-transit.png&#34; alt=&#34;img&#34; /&gt;&lt;br /&gt;
过渡技术主要解决IPv4和IPv6网络共存情况下的互联互通，主要由三种策略：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;双栈协议：设备升级到IPv6同时保留IPv4支持，应用程序可以选择使用IPv4或IPv6; 协议应用允许应用逐渐从IPv4过渡到IPv6。&lt;/li&gt;
&lt;li&gt;隧道封装：IPv6报文作为IPv4的载荷，或由MPLS承载在IPv4 internet海洋中连接多个IPv6孤岛&lt;/li&gt;
&lt;li&gt;协议转换：提供IPv4和IPv6的互通动作，如NAT-PT等提供IPv6与IPv4互相访问的技术，适用于IPv6 internet与IPv4 internet共存，而两者又需要互相通讯的需求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;orgecddc15&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;双栈协议&#34;&gt;双栈协议&lt;/h2&gt;

&lt;p&gt;设备升级到IPv6的同时保留IPv4支持，应用程序可以选择使用IPv6或IPv4协议。&lt;br /&gt;
所有的过渡技术都是基于双协议栈实现的。&lt;br /&gt;
优点：互通性好、易于理解、实现简单。&lt;br /&gt;
缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对每个IPv4节点都要升级，成本较大，没有解决IPv4地址紧缺的问题。&lt;/li&gt;
&lt;li&gt;部署复杂，所有设备都同时配置IPv4和IPv6；&lt;/li&gt;
&lt;li&gt;对设备性能要求高，既要运行IPv6，又要运行IPv4。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;org011bb58&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;隧道封装&#34;&gt;隧道封装&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;IPv6 over IPv4 手动隧道(配置隧道)：隧道两端的边界路由器上通过静态指定隧道的源IPv4地址和目的IPv4地址而创建的隧道。&lt;/li&gt;
&lt;li&gt;IPv6 over IPv4 GRE隧道(GRE隧道)： 使用IPv4的GRE隧道上承载IPv6流而实现IPv6互通。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#34;org5571ac2&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;展望&#34;&gt;展望&lt;/h1&gt;

&lt;p&gt;随着IPv6的普及与更多的应用落地， 使得人与人、物与物之间通信更加频繁，将催生出很多革命创新型应用或巨头公司，谁主沉浮，让我们拭目以待吧。&lt;br /&gt;
&lt;img src=&#34;http://blog.mospan.cn/post/img/2019/ipv6-base/ipv6-preview.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>IPv6技术概览(PDF版)</title>
            <link>http://mospany.github.io/2019/08/02/ipv6-base/</link>
            <pubDate>Fri, 02 Aug 2019 07:39:07 CST</pubDate>
            <author>Mospan</author>
            <guid>http://mospany.github.io/2019/08/02/ipv6-base/</guid>
            <description>

&lt;h1 id=&#34;描述&#34;&gt;描述&lt;/h1&gt;

&lt;p&gt;此《IPv6技术概览》PPT内容由我个人的理解编写与部分来自互联网上的整理, 以便更多的读者分享交流。&lt;/p&gt;

&lt;h1 id=&#34;ppt内容&#34;&gt;PPT内容&lt;/h1&gt;

&lt;p&gt;&lt;center&gt;&lt;embed src=&#34;http://blog.mospan.cn/post/img/ipv6-base.pdf&#34; width=100% height=&#34;800&#34;&gt;&lt;/center&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>我的博客Hugo使用手册</title>
            <link>http://mospany.github.io/2019/02/02/mospan-hugo-blog-manual/</link>
            <pubDate>Sat, 02 Feb 2019 15:18:53 CST</pubDate>
            <author>Mospan</author>
            <guid>http://mospany.github.io/2019/02/02/mospan-hugo-blog-manual/</guid>
            <description>&lt;h1 id=&#34;hugo&#34;&gt;Hugo&lt;/h1&gt;

&lt;p&gt;Hugo是一个用Go语言编写的静态网站生成器，它使用起来非常简单，相对于Jekyll复杂的安装设置来说，Hugo仅需要一个二进制文件hugo(hugo.exe)即可轻松用于本地调试和生成静态页面。&lt;/p&gt;

&lt;p&gt;Hugo生成静态页面的效率很高，我的多篇博客文章生成几乎是瞬间完成的，而用Jekyll需要等待10秒左右。&lt;/p&gt;

&lt;p&gt;Hugo自带watch的调试模式，可以在我修改MarkDown文章之后切换到浏览器，页面会检测到更新并且自动刷新，呈现出最终效果，能极大的提高博客书写效率。再加上Hugo是使用Go语言编写，已经没有任何理由不使用Hugo来代替Jekyll作为我的个人博客站点生成器了。&lt;/p&gt;

&lt;h1 id=&#34;usage&#34;&gt;Usage&lt;/h1&gt;

&lt;p&gt;Demo：
&lt;a href=&#34;http://blog.mospan.cn/&#34; title=&#34;http://blog.mospan.cn/&#34;&gt;http://blog.mospan.cn/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;界面参考 [http://cyrillschumacher.com/](http://cyrillschumacher.com/) 做了一些修改，并做了一个皮肤：panman。&lt;/p&gt;

&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;

&lt;p&gt;下载源码到本地。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git clone git@github.com:mospany/mospan-hugo-blog.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;记得把我的个人信息修改成自己的就行。&lt;/p&gt;

&lt;h2 id=&#34;启动调试&#34;&gt;启动调试&lt;/h2&gt;

&lt;h3 id=&#34;本地调试&#34;&gt;本地调试&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cd mospan-hugo-blog
$ ./debug.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开浏览器：http://localhost:1313&lt;/p&gt;

&lt;h3 id=&#34;远程调试&#34;&gt;远程调试&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cd mospan-hugo-blog
$ ./debug.py AA.BB.CC.DD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开浏览器：http://AA.BB.CC.DD:1313
其中： AA.BB.CC.DD 为本机可访问IP地址。&lt;/p&gt;

&lt;h2 id=&#34;创作&#34;&gt;创作&lt;/h2&gt;

&lt;ul&gt;
现在的hugo可支持markdown与org-mode文件格式，分别对应create-md.py于create-org.py脚本。
&lt;li&gt;执行create-md.py或create-org.py。&lt;/li&gt;
&lt;li&gt;输入文件标题，最后不要有空格。&lt;/li&gt;
&lt;li&gt;它将根据themes/hugo-panman-theme/archetypes/default.[md|org]模板生成以日期+标题的文件。&lt;/li&gt;
&lt;li&gt;打开新生成文件进行编辑，记得修改头部的categories、keywords、tags、title进行归类区分。&lt;/li&gt;
&lt;li&gt;修改好后，通过push.py进行保存到github文件中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;部署&#34;&gt;部署&lt;/h2&gt;

&lt;p&gt;如果是第一次部署，执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ ./deploy.py first
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;否则&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ ./deploy.py manual
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可&lt;/p&gt;

&lt;h1 id=&#34;改进记录&#34;&gt;改进记录&lt;/h1&gt;

&lt;h1 id=&#34;缺陷&#34;&gt;缺陷&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Hugo对org-mode渲染没有markdown好。&lt;/li&gt;
&lt;li&gt;文章标题还需更加美化。&lt;/li&gt;
&lt;li&gt;右边的导航栏在某些浏览器下点击无效。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;

&lt;p&gt;【01】 &lt;a href=&#34;https://www.jianshu.com/p/57afa4844aaa&#34; title=&#34;Gitment评论功能接入踩坑教程&#34;&gt;Gitment评论功能接入踩坑教程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【02】 &lt;a href=&#34;https://www.qikqiak.com/post/hugo-integrated-gitment-plugin/&#34; title=&#34;Hugo 集成 Gitment 评论插件&#34;&gt;Hugo 集成 Gitment 评论插件&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【03】&lt;a href=&#34;https://blog.csdn.net/wardseptember/article/details/82828391&#34; title=&#34;解决gitment无法登陆评论问题（Object ProgressEvent）&#34;&gt;解决gitment无法登陆评论问题（Object ProgressEvent）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【04】&lt;a href=&#34;https://www.xianmin.org/post/utterances-comment-system/&#34; title=&#34;更好的基于 github issues 的评论系统——utterances&#34;&gt;更好的基于 github issues 的评论系统——utterances&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
