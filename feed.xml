<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>墨斯潘園 on 墨斯潘園</title>
        <link>http://yanwushuang.github.io/feed/index.xml</link>
        <language>zh-CN</language>
        <author>Mospan</author>
        <rights>Copyright (c) 2016, mospan; all rights reserved.</rights>
        <updated>Tue, 07 Mar 2017 19:13:23 HKT</updated>
        
        <item>
            <title>精品文章，阅后收藏</title>
            <link>http://yanwushuang.github.io/2017/03/07/collection-after-reading/</link>
            <pubDate>Tue, 07 Mar 2017 19:13:23 HKT</pubDate>
            <author>Mospan</author>
            <guid>http://yanwushuang.github.io/2017/03/07/collection-after-reading/</guid>
            <description>&lt;h1 id=&#34;职场人性类&#34;&gt;职场人性类&lt;/h1&gt;

&lt;h2 id=&#34;编码人生&#34;&gt;编码人生&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;[☆☆☆☆☆] &lt;a href=&#34;https://mp.weixin.qq.com/s?__biz%3DMzA5MjE3NDQ1Mw%3D%3D&amp;amp;mid%3D2649701649&amp;amp;idx%3D1&amp;amp;sn%3Df773ab5158b2afccf2250158e46f09b3&amp;amp;chksm%3D886abc0bbf1d351da17e112dac40232a22b823889e9c055e50cef07c78c5da8d45a48cfae8c6&amp;amp;scene%3D0&amp;amp;key%3Dbf3b92f02199be1cdcedf4f92b26fc4c8ea4b004a348a365b20f53a9532e4adb615e71271351b117ba489992a39f73c30b5f6173e2e7581c2cc7b58fed0fdc9aedc2cc534256816d3dde837a8ab05a29&amp;amp;ascene%3D0&amp;amp;uin%3DMjcyNjk5NDg2Mw%253D%253D&amp;amp;devicetype%3DiMac%2BMacBookPro12%252C1%2BOSX%2BOSX%2B10.11.4%2Bbuild(15E65)&amp;amp;version%3D12010310&amp;amp;nettype%3DWIFI&amp;amp;fontScale%3D100&amp;amp;pass_ticket%3DE5ycGW20zs93%252BTrdHJ7otbfesaM9LgBvWYLbwmkcIilLX9rZY0bQSNAnahU%252F9Hjc&#34; title=&#34;程序员分七个等级，你属于哪一级？&#34;&gt;程序员分七个等级，你属于哪一级？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;技术类&#34;&gt;技术类&lt;/h1&gt;

&lt;h2 id=&#34;基础&#34;&gt;基础&lt;/h2&gt;

&lt;h2 id=&#34;语言&#34;&gt;语言&lt;/h2&gt;

&lt;h3 id=&#34;c&#34;&gt;C&lt;/h3&gt;

&lt;h3 id=&#34;go&#34;&gt;Go&lt;/h3&gt;

&lt;h3 id=&#34;lua&#34;&gt;Lua&lt;/h3&gt;

&lt;h3 id=&#34;shell&#34;&gt;Shell&lt;/h3&gt;

&lt;h3 id=&#34;python&#34;&gt;Python&lt;/h3&gt;

&lt;h2 id=&#34;网络&#34;&gt;网络&lt;/h2&gt;

&lt;h2 id=&#34;算法&#34;&gt;算法&lt;/h2&gt;

&lt;h2 id=&#34;数据库&#34;&gt;数据库&lt;/h2&gt;

&lt;h2 id=&#34;架构&#34;&gt;架构&lt;/h2&gt;

&lt;h1 id=&#34;管理类&#34;&gt;管理类&lt;/h1&gt;
</description>
        </item>
        
        <item>
            <title>openresty&#43;redis practices</title>
            <link>http://yanwushuang.github.io/2017/03/02/openresty&#43;redis-practices/</link>
            <pubDate>Thu, 02 Mar 2017 11:14:08 HKT</pubDate>
            <author>Mospan</author>
            <guid>http://yanwushuang.github.io/2017/03/02/openresty&#43;redis-practices/</guid>
            <description>&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;

&lt;h2 id=&#34;openresty安装&#34;&gt;openresty安装&lt;/h2&gt;

&lt;p&gt;详见 &lt;a href=&#34;https://openresty.org/cn/installation.html&#34; title=&#34;openresty安装&#34;&gt;openresty安装&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;redis安装&#34;&gt;redis安装&lt;/h2&gt;

&lt;p&gt;执行如下命令：&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC sh&lt;/p&gt;

&lt;p&gt;sudo apt-get update&lt;/p&gt;

&lt;p&gt;sudo apt-get install redis-server&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;详见 &lt;a href=&#34;http://www.jianshu.com/p/c8723b677304&#34; title=&#34;Ubuntu安装配置Redis&#34;&gt;Ubuntu安装配置Redis&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;redis启动&#34;&gt;redis启动&lt;/h2&gt;

&lt;p&gt;执行如下命令：&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC sh&lt;/p&gt;

&lt;p&gt;redis-server /etc/redis/redis-master.conf&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;如需启动redis slave，只需把原有配置修改如下几行即可。&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC sh&lt;/p&gt;

&lt;p&gt;slaveof 192.168.1.1 7648&lt;/p&gt;

&lt;p&gt;slave-priority 100&lt;/p&gt;

&lt;p&gt;slave-read-only yes&lt;/p&gt;

&lt;p&gt;slave-serve-stale-data yes&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;h2 id=&#34;openresty启动&#34;&gt;openresty启动&lt;/h2&gt;

&lt;p&gt;执行如下命令：&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC sh&lt;/p&gt;

&lt;p&gt;root@bj94:/usr/local/openresty/nginx# pwd&lt;/p&gt;

&lt;p&gt;/usr/local/openresty/nginx&lt;/p&gt;

&lt;p&gt;root@bj94:/usr/local/openresty/nginx# ./sbin/nginx -p `pwd` -c conf/nginx.conf&lt;/p&gt;

&lt;p&gt;nginx: [alert] lua_code_cache is off; this will hurt performance in /usr/local/openresty/nginx/conf/nginx.conf:29&lt;/p&gt;

&lt;p&gt;root@bj94:/usr/local/openresty/nginx#&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;h1 id=&#34;编写api&#34;&gt;编写API&lt;/h1&gt;

&lt;p&gt;根据项目要求编写openresty+lua的增删改查API接口。&lt;/p&gt;

&lt;h1 id=&#34;测试&#34;&gt;测试&lt;/h1&gt;

&lt;h2 id=&#34;发送请求&#34;&gt;发送请求&lt;/h2&gt;

&lt;p&gt;使用curl命令发送http json请求:&lt;/p&gt;

&lt;p&gt;#+BEGIN_QUOTE&lt;/p&gt;

&lt;p&gt;root@bj94:~/dr302client# cat add.json&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;先写请求json&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&#34;www.example.com&#34;: {&lt;/p&gt;

&lt;p&gt;&#34;sub_domain&#34;: &#34;@&#34;,&lt;/p&gt;

&lt;p&gt;&#34;record_type&#34;: &#34;CNAME&#34;,&lt;/p&gt;

&lt;p&gt;&#34;record_line&#34;: &#34;all&#34;,&lt;/p&gt;

&lt;p&gt;&#34;record_line_id&#34;: &#34;00000000&#34;,&lt;/p&gt;

&lt;p&gt;&#34;value&#34;: &#34;all.china.qiniu.qnydns.com&#34;,&lt;/p&gt;

&lt;p&gt;&#34;mx&#34;: 1,&lt;/p&gt;

&lt;p&gt;&#34;ttl&#34;: 86400,&lt;/p&gt;

&lt;p&gt;&#34;status&#34;: &#34;enable&#34;,&lt;/p&gt;

&lt;p&gt;&#34;weight&#34;: 100&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;#+END_QUOTE&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC sh&lt;/p&gt;

&lt;p&gt;curl -i -H &#39;content-type: application/json&#39; -X POST -d @add.json http://dev.mgrconfig.api.qiniudns.com/qiniu/dr302/records/add&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;h2 id=&#34;回复响应&#34;&gt;回复响应&lt;/h2&gt;

&lt;p&gt;根据不同返回码表示操作结果。&lt;/p&gt;

&lt;p&gt;#+BEGIN_QUOTE -t&lt;/p&gt;

&lt;p&gt;root@bj94:~/dr302client# curl -i -H &#39;content-type: application/json&#39; -X POST -d @addA.json http://dev.mgrconfig.api.qiniudns.com/qiniu/dr302/records/add&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;执行命令：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;HTTP/1.1 200 OK&lt;/p&gt;

&lt;p&gt;Date: Thu, 09 Mar 2017 03:01:17 GMT&lt;/p&gt;

&lt;p&gt;Content-Type: text/plain&lt;/p&gt;

&lt;p&gt;Transfer-Encoding: chunked&lt;/p&gt;

&lt;p&gt;Connection: keep-alive&lt;/p&gt;

&lt;p&gt;Server: DR302-MGR&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;p&gt;&#34;status&#34;:{&lt;/p&gt;

&lt;p&gt;&#34;created_at&#34;:&#34;2017-03-09 11:01:17&#34;,&lt;/p&gt;

&lt;p&gt;&#34;code&#34;:0,&lt;/p&gt;

&lt;p&gt;&#34;message&#34;:&#34;success&#34;&lt;/p&gt;

&lt;p&gt;},&lt;/p&gt;

&lt;p&gt;&#34;record&#34;:{&lt;/p&gt;

&lt;p&gt;&#34;status&#34;:&#34;enable&#34;,&lt;/p&gt;

&lt;p&gt;&#34;key&#34;:&#34;www.example.com#all&#34;,&lt;/p&gt;

&lt;p&gt;&#34;name&#34;:&#34;@&#34;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;#+END_QUOTE&lt;/p&gt;

&lt;h2 id=&#34;查看存储&#34;&gt;查看存储&lt;/h2&gt;

&lt;p&gt;执行命令:&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC sh&lt;/p&gt;

&lt;p&gt;(echo  &#34;select 10&#34;; echo &#34;hgetall www.example.com#all&#34;) | redis-cli -a cdnfusion -p 7648&#34;&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;避免中文乱码，加--raw选项：&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC sh&lt;/p&gt;

&lt;p&gt;(echo  &#34;select 10&#34;; echo &#34;hgetall www.example.com#all&#34;) | redis-cli -a cdnfusion -p 7648 --raw&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;显示如下:&lt;/p&gt;

&lt;p&gt;#+BEGIN_QUOTE&lt;/p&gt;

&lt;p&gt;root@bj94:~/dr302client# (echo  &#34;select 10&#34;; echo &#34;hgetall www.example.com#all&#34;) | redis-cli -a cdnfusion -p 7648&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;1) &#34;weight&#34;&lt;/p&gt;

&lt;p&gt;2) &#34;20&#34;&lt;/p&gt;

&lt;p&gt;3) &#34;record_type&#34;&lt;/p&gt;

&lt;p&gt;4) &#34;A&#34;&lt;/p&gt;

&lt;p&gt;5) &#34;record_line&#34;&lt;/p&gt;

&lt;p&gt;6) &#34;all&#34;&lt;/p&gt;

&lt;p&gt;7) &#34;status&#34;&lt;/p&gt;

&lt;p&gt;8) &#34;enable&#34;&lt;/p&gt;

&lt;p&gt;9) &#34;mx&#34;&lt;/p&gt;

&lt;p&gt;10) &#34;1&#34;&lt;/p&gt;

&lt;p&gt;11) &#34;value&#34;&lt;/p&gt;

&lt;p&gt;12) &#34;1.1.1.1#10|2.2.2.2#20&#34;&lt;/p&gt;

&lt;p&gt;13) &#34;ttl&#34;&lt;/p&gt;

&lt;p&gt;14) &#34;86400&#34;&lt;/p&gt;

&lt;p&gt;15) &#34;record_line_id&#34;&lt;/p&gt;

&lt;p&gt;16) &#34;00000000&#34;&lt;/p&gt;

&lt;p&gt;17) &#34;sub_domain&#34;&lt;/p&gt;

&lt;p&gt;18) &#34;@&#34;&lt;/p&gt;

&lt;p&gt;#+END_QUOTE&lt;/p&gt;

&lt;h2 id=&#34;302测试&#34;&gt;302测试&lt;/h2&gt;

&lt;h3 id=&#34;请求&#34;&gt;请求&lt;/h3&gt;

&lt;p&gt;#+BEGIN_SRC sh&lt;/p&gt;

&lt;p&gt;curl http://192.168.92.94:8302/ -H &#34;host: www.example.com&#34;&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;h2 id=&#34;响应&#34;&gt;响应&lt;/h2&gt;

&lt;p&gt;响应如下：&lt;/p&gt;

&lt;p&gt;#+BEGIN_HTML&lt;/p&gt;

&lt;p&gt;root@bj94:~/dr302client# curl http://192.168.92.94:8302/ -H &#34;host: www.example.com&#34; -v&lt;/p&gt;

&lt;p&gt;*   Trying 192.168.92.94...&lt;/p&gt;

&lt;p&gt;* Connected to 192.168.92.94 (192.168.92.94) port 8302 (#0)&lt;/p&gt;

&lt;p&gt;&gt; GET / HTTP/1.1&lt;/p&gt;

&lt;p&gt;&gt; host: www.example.com&lt;/p&gt;

&lt;p&gt;&gt; User-Agent: curl/7.47.0&lt;/p&gt;

&lt;p&gt;&gt; Accept: &lt;strong&gt;/&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&gt;&lt;/p&gt;

&lt;p&gt;&lt; HTTP/1.1 302 Moved Temporarily&lt;/p&gt;

&lt;p&gt;&lt; Date: Fri, 07 Apr 2017 02:30:50 GMT&lt;/p&gt;

&lt;p&gt;&lt; Content-Type: text/html&lt;/p&gt;

&lt;p&gt;&lt; Content-Length: 167&lt;/p&gt;

&lt;p&gt;&lt; Connection: keep-alive&lt;/p&gt;

&lt;p&gt;&lt; Server: DR302-NODE&lt;/p&gt;

&lt;p&gt;&lt; Location: http://2.2.2.2/www.example.com/&lt;/p&gt;

&lt;p&gt;&lt;&lt;/p&gt;

&lt;p&gt;&lt;html&gt;&lt;/p&gt;

&lt;p&gt;&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;&lt;/p&gt;

&lt;p&gt;&lt;body bgcolor=&#34;white&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;h1&gt;302 Found&lt;/h1&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;hr&gt;&lt;center&gt;openresty/1.11.2.1&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;/body&gt;&lt;/p&gt;

&lt;p&gt;&lt;/html&gt;&lt;/p&gt;

&lt;p&gt;#+END_HTML&lt;/p&gt;

&lt;h2 id=&#34;性能测试&#34;&gt;性能测试&lt;/h2&gt;

&lt;p&gt;使用ab测试DR302服务器的性能。&lt;/p&gt;

&lt;h3 id=&#34;测试步骤&#34;&gt;测试步骤&lt;/h3&gt;

&lt;p&gt;1） 由于ab不支持参数修改HOST字段，需把要测试的域名IP对设置到/etc/hosts中。如: 192.168.92.94 www.example.com&lt;/p&gt;

&lt;p&gt;2)  ab测试输出信息，查看项“ Requests per second”。&lt;/p&gt;

&lt;p&gt;a) 带有keepalive的性能为80000QPS。&lt;/p&gt;

&lt;p&gt;ab -kc 1024 -n 1000000 http://www.example.com:8302/&lt;/p&gt;

&lt;p&gt;b) 不带keepalive的性能为16000QPS。&lt;/p&gt;

&lt;p&gt;ab -c 1024 -n 1000000 http://www.example.com:8302/&lt;/p&gt;

&lt;h3 id=&#34;优化点&#34;&gt;优化点&lt;/h3&gt;

&lt;p&gt;1) 关闭日志记录&lt;/p&gt;

&lt;p&gt;#+BEGIN_QUOTE&lt;/p&gt;

&lt;p&gt;# access_log /usr/local/openresty/nginx/logs/dr302_node_access.log main;&lt;/p&gt;

&lt;p&gt;access_log off;&lt;/p&gt;

&lt;p&gt;error_log  /usr/local/openresty/nginx/logs/dr302_node_error.log error;&lt;/p&gt;

&lt;p&gt;#+END_QUOTE&lt;/p&gt;

&lt;p&gt;2) 打开缓存&lt;/p&gt;

&lt;p&gt;把nginx.conf里的这行打开或加上。&lt;/p&gt;

&lt;p&gt;lua_code_cache on;&lt;/p&gt;

&lt;p&gt;3）使用ulimit -n 65535设置open files数。&lt;/p&gt;

&lt;p&gt;4) 设置nginx的进程数与本服务器CPU匹配的值，如: 8&lt;/p&gt;

&lt;p&gt;5) 关闭掉一些耗性能的进程。&lt;/p&gt;

&lt;h2 id=&#34;踩过的坑&#34;&gt;踩过的坑&lt;/h2&gt;

&lt;h3 id=&#34;table的深度与浅度拷贝&#34;&gt;table的深度与浅度拷贝&lt;/h3&gt;

&lt;h4 id=&#34;现象&#34;&gt;现象&lt;/h4&gt;

&lt;p&gt;当通过API批量获取配置列表时，发现不同的key获取的值是一样的， 但通过redis-cli获取是不一样且正确的。&lt;/p&gt;

&lt;h4 id=&#34;分析&#34;&gt;分析&lt;/h4&gt;

&lt;p&gt;redis存储是正确的，很有可能是中间临时存储存在覆盖的问题， 如果table每次赋值都相当于内存拷贝那样Lua的性能就会大大降低，&lt;/p&gt;

&lt;p&gt;会不会table之间赋值就像C语言一样只赋值地址或指针。经网上查找发现table存在深度与浅度拷贝的区别。&lt;/p&gt;

&lt;p&gt;详见:&lt;a href=&#34;https://my.oschina.net/hqc17/blog/748709&#34; title=&#34;Lua实现深度拷贝&#34;&gt;Lua实现深度拷贝&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;解决措施&#34;&gt;解决措施&lt;/h4&gt;

&lt;p&gt;把中间的临时table变量放入当前语句块中并加local标识，猜测在当前语句块临时table可能会随时被释放掉，&lt;/p&gt;

&lt;p&gt;因此它赋值给其他作用域更大的变量时使用深拷贝。&lt;/p&gt;

&lt;h3 id=&#34;hgetall结果与lua-table转换&#34;&gt;hgetall结果与Lua table转换&lt;/h3&gt;

&lt;p&gt;使用hgetall获取redis的内容需经转换后才能被Lua table使用。&lt;/p&gt;

&lt;p&gt;转换关键代码如下:&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC lua -n&lt;/p&gt;

&lt;p&gt;local v = red:hgetall(innerk)&lt;/p&gt;

&lt;p&gt;if v == nil then&lt;/p&gt;

&lt;p&gt;log(ERR, &#34;get redis empty key: &#34;, innerk)&lt;/p&gt;

&lt;p&gt;return nil&lt;/p&gt;

&lt;p&gt;end&lt;/p&gt;

&lt;p&gt;for key,val in pairs(v) do&lt;/p&gt;

&lt;p&gt;if key%2 ~= 0 then&lt;/p&gt;

&lt;p&gt;result[v[key]] = v[key+1];&lt;/p&gt;

&lt;p&gt;end&lt;/p&gt;

&lt;p&gt;end&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;h3 id=&#34;nginx-worker权限问题&#34;&gt;nginx worker权限问题&lt;/h3&gt;

&lt;h4 id=&#34;现象-1&#34;&gt;现象&lt;/h4&gt;

&lt;p&gt;当使用init_worker_by_lua_file进行定时器任务时，发现不能打开或写入/usr/local/openresty/子目录下的文件， 而init_by_lua_file调用则正常。&lt;/p&gt;

&lt;h4 id=&#34;分析-1&#34;&gt;分析&lt;/h4&gt;

&lt;p&gt;当把路径改为/tmp/目录下则运行都正常，经定位发现nginx master以root身份运行， 而nginx worker以nobody身份运行。&lt;/p&gt;

&lt;p&gt;查看需要读写的文件路径， 发现只有root权限才能写。&lt;/p&gt;

&lt;h4 id=&#34;解决措施-1&#34;&gt;解决措施&lt;/h4&gt;

&lt;p&gt;1） 发现代码以&#34;r+&#34;(更新模式,保存之前的数据)模式进行读文件，需改成&#34;r&#34;只读模式。&lt;/p&gt;

&lt;p&gt;2） 把要写的文件路径改成其他可写，例如: chmod 777 data&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>个人常用面试题及其参考答案</title>
            <link>http://yanwushuang.github.io/2017/03/01/personal-interview-questions/</link>
            <pubDate>Wed, 01 Mar 2017 19:27:08 HKT</pubDate>
            <author>Mospan</author>
            <guid>http://yanwushuang.github.io/2017/03/01/personal-interview-questions/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/jobInterview.jpg&#34; title=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/jobInterview.jpg&#34;&gt;http://7xqi7h.com1.z0.glb.clouddn.com/jobInterview.jpg&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;开篇&#34;&gt;开篇&lt;/h1&gt;

&lt;h2 id=&#34;请您自我介绍一下你自己&#34;&gt;请您自我介绍一下你自己？&lt;/h2&gt;

&lt;p&gt;回答提示：一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，&lt;/p&gt;

&lt;p&gt;包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习无关，也可以和学习有关，&lt;/p&gt;

&lt;p&gt;但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”，&lt;/p&gt;

&lt;p&gt;企业喜欢有礼貌的求职者。&lt;/p&gt;

&lt;h2 id=&#34;您平时主要用什么语言-主要时用户态还是内核态&#34;&gt;您平时主要用什么语言? 主要时用户态还是内核态?&lt;/h2&gt;

&lt;h1 id=&#34;技术&#34;&gt;技术&lt;/h1&gt;

&lt;h2 id=&#34;用户态&#34;&gt;用户态&lt;/h2&gt;

&lt;h3 id=&#34;include-file-h-与-include-file-h-的区别&#34;&gt;#include&lt;file.h&gt; 与#include &#34;file.h&#34;的区别？&lt;/h3&gt;

&lt;p&gt;答：前者是从Standard Library的路径寻找和引用file.h，而后者是从当前工作路径搜寻并引用file.h。&lt;/p&gt;

&lt;h3 id=&#34;堆栈溢出一般是由什么原因导致的&#34;&gt;堆栈溢出一般是由什么原因导致的？&lt;/h3&gt;

&lt;p&gt;答:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;没有回收垃圾资源&lt;/li&gt;
&lt;li&gt;层次太深的递归调用&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;程序的内存分配&#34;&gt;程序的内存分配&lt;/h3&gt;

&lt;p&gt;答：一个由c/C++编译的程序占用的内存分为以下几个部分&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;栈区（stack）—由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。&lt;/li&gt;
&lt;li&gt;堆区（heap）—一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。&lt;/li&gt;
&lt;li&gt;全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。&lt;/li&gt;
&lt;li&gt;文字常量区—常量字符串就是放在这里的。程序结束后由系统释放。&lt;/li&gt;
&lt;li&gt;程序代码区—存放函数体的二进制代码	   &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;请说出const与-define-相比-有何优点&#34;&gt;请说出const与#define 相比，有何优点？&lt;/h3&gt;

&lt;p&gt;答：Const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。&lt;/li&gt;
&lt;li&gt;有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;论述含参数的宏与函数的优缺点&#34;&gt;论述含参数的宏与函数的优缺点&lt;/h3&gt;

&lt;p&gt;答：        带参宏                  函数&lt;/p&gt;

&lt;p&gt;处理时间    编译时               程序运行时&lt;/p&gt;

&lt;p&gt;参数类型   没有参数类型问题      定义实参、形参类型&lt;/p&gt;

&lt;p&gt;处理过程   不分配内存            分配内存&lt;/p&gt;

&lt;p&gt;程序长度   变长                  不变&lt;/p&gt;

&lt;p&gt;运行速度   不占运行时间          调用和返回占用时间&lt;/p&gt;

&lt;h3 id=&#34;什么是平衡二叉树&#34;&gt;什么是平衡二叉树？&lt;/h3&gt;

&lt;p&gt;答：左右子树都是平衡二叉树且左右子树的深度差值的绝对值不大于1。&lt;/p&gt;

&lt;h3 id=&#34;嵌入式系统中经常要用到无限循环-你怎么样用c编写死循环呢&#34;&gt;嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？&lt;/h3&gt;

&lt;p&gt;答：这个问题用几个解决方案。我首选的方案是：&lt;/p&gt;

&lt;p&gt;while(1)&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;一些程序员更喜欢如下方案：&lt;/p&gt;

&lt;p&gt;for(;;)&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的&lt;/p&gt;

&lt;p&gt;基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。&lt;/p&gt;

&lt;p&gt;第三个方案是用 goto&lt;/p&gt;

&lt;p&gt;Loop:&lt;/p&gt;

&lt;p&gt;...&lt;/p&gt;

&lt;p&gt;goto Loop;&lt;/p&gt;

&lt;p&gt;应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。&lt;/p&gt;

&lt;h3 id=&#34;位操作-bit-manipulation&#34;&gt;位操作（Bit manipulation）&lt;/h3&gt;

&lt;p&gt;答：嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。&lt;/p&gt;

&lt;p&gt;对这个问题有三种基本的反应&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不知道如何下手。该被面者从没做过任何嵌入式系统的工作。&lt;/li&gt;
&lt;li&gt;用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC c&lt;/p&gt;

&lt;p&gt;#define BIT3 (0x1 &lt;&lt; 3)&lt;/p&gt;

&lt;p&gt;static int a;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;void set_bit3(void)&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;p&gt;a |= BIT3;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;void clear_bit3(void)&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;p&gt;a &amp;= ~BIT3;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&amp;=~操作。&lt;/p&gt;

&lt;h3 id=&#34;用户进程间通信主要哪几种方式&#34;&gt;用户进程间通信主要哪几种方式&lt;/h3&gt;

&lt;p&gt;	答:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;管道&lt;/li&gt;
&lt;li&gt;命名管道&lt;/li&gt;
&lt;li&gt;信号&lt;/li&gt;
&lt;li&gt;消息（Message）队&lt;/li&gt;
&lt;li&gt;共享内存&lt;/li&gt;
&lt;li&gt;信号量&lt;/li&gt;
&lt;li&gt;套接字&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;线程同步方法&#34;&gt;线程同步方法&lt;/h3&gt;

&lt;p&gt;	答:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;互斥锁&lt;/li&gt;
&lt;li&gt;条件变量&lt;/li&gt;
&lt;li&gt;信号量&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;父子进程哪些是共享的哪些时独立的&#34;&gt;父子进程哪些是共享的哪些时独立的?&lt;/h3&gt;

&lt;h3 id=&#34;用户态调试&#34;&gt;用户态调试&lt;/h3&gt;

&lt;p&gt;答: printf -&gt; ldd -&gt; gdb -&gt; strace -&gt;coredump;&lt;/p&gt;

&lt;h2 id=&#34;内核态&#34;&gt;内核态&lt;/h2&gt;

&lt;h3 id=&#34;内核与用户态的通信方式&#34;&gt;内核与用户态的通信方式?&lt;/h3&gt;

&lt;p&gt;答:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内核启动参数&lt;/li&gt;
&lt;li&gt;模块参数与sysfs&lt;/li&gt;
&lt;li&gt;Sysctl&lt;/li&gt;
&lt;li&gt;系统调用&lt;/li&gt;
&lt;li&gt;Netlink&lt;/li&gt;
&lt;li&gt;/proc&lt;/li&gt;
&lt;li&gt;Seq_file&lt;/li&gt;
&lt;li&gt;Debugfs&lt;/li&gt;
&lt;li&gt;Relayfs&lt;/li&gt;
&lt;li&gt;brk()&lt;/li&gt;
&lt;li&gt;信号&lt;/li&gt;
&lt;li&gt;内存映射机制&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;怎么加载内核模块-insmod与modprobe有什么区别-怎么查看模块信息&#34;&gt;怎么加载内核模块? insmod与modprobe有什么区别? 怎么查看模块信息?&lt;/h3&gt;

&lt;p&gt;	答: insmod/modprobe, modprobe自动找出依赖关系, modinfo查看模块信息,&lt;/p&gt;

&lt;p&gt;	demesg查看输出信息.&lt;/p&gt;

&lt;h3 id=&#34;内核同步方法&#34;&gt;内核同步方法&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;每CPU变量&lt;/li&gt;
&lt;li&gt;原子操作&lt;/li&gt;
&lt;li&gt;优化和内存屏蔽&lt;/li&gt;
&lt;li&gt;自旋锁&lt;/li&gt;
&lt;li&gt;读写自旋锁&lt;/li&gt;
&lt;li&gt;顺序锁&lt;/li&gt;
&lt;li&gt;RCU&lt;/li&gt;
&lt;li&gt;内核信号量&lt;/li&gt;
&lt;li&gt;读写信号量&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;死锁原因与避免&#34;&gt;死锁原因与避免&lt;/h3&gt;

&lt;p&gt;	答:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;两次请求同一个锁&lt;/li&gt;
&lt;li&gt;ABBA锁&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;中断下半部有哪几种实现方式-与应用场景&#34;&gt;中断下半部有哪几种实现方式? 与应用场景?&lt;/h3&gt;

&lt;p&gt;	答: 软中断, tasklet, 工作队列&lt;/p&gt;

&lt;h3 id=&#34;说说你认为内核中最关键的几个数据结构&#34;&gt;说说你认为内核中最关键的几个数据结构?&lt;/h3&gt;

&lt;p&gt;	答: net_device, sk_buff, socket, sock, file;&lt;/p&gt;

&lt;h3 id=&#34;硬中断和软中断的区别&#34;&gt;硬中断和软中断的区别&lt;/h3&gt;

&lt;p&gt;软中断是执行中断指令产生的，而硬中断是由外设引发的。&lt;/p&gt;

&lt;p&gt;硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。&lt;/p&gt;

&lt;p&gt;硬中断是可屏蔽的，软中断不可屏蔽。&lt;/p&gt;

&lt;p&gt;硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。&lt;/p&gt;

&lt;p&gt;软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。&lt;/p&gt;

&lt;h3 id=&#34;几种分配函数的比较&#34;&gt;几种分配函数的比较&lt;/h3&gt;

&lt;p&gt;　　分配原理最大内存其他&lt;/p&gt;

&lt;p&gt;　　__get_free_pages直接对页框进行操作4MB适用于分配较大量的连续物理内存&lt;/p&gt;

&lt;p&gt;　　kmem_cache_alloc基于slab机制实现128KB适合需要频繁申请释放相同大小内存块时使用&lt;/p&gt;

&lt;p&gt;　　kmalloc基于kmem_cache_alloc实现128KB最常见的分配方式，需要小于页框大小的内存时可以使用&lt;/p&gt;

&lt;p&gt;　　vmalloc建立非连续物理内存到虚拟地址的映射物理不连续，适合需要大内存，但是对地址连续性没有要求的场合&lt;/p&gt;

&lt;p&gt;　　dma_alloc_coherent基于__alloc_pages实现4MB适用于DMA操 作&lt;/p&gt;

&lt;p&gt;　　ioremap实现已知物理地址到虚拟地址的映射适用于物理地址已知的场合，如设备驱动&lt;/p&gt;

&lt;p&gt;　　alloc_bootmem在启动kernel时，预留一段内存，内核看不见小于物理内存大小，内存管理要求较高&lt;/p&gt;

&lt;h3 id=&#34;怎么实现cpu与网卡多通道中断绑定&#34;&gt;怎么实现CPU与网卡多通道中断绑定?&lt;/h3&gt;

&lt;h3 id=&#34;数据包各层头主要包含哪些关键字段&#34;&gt;数据包各层头主要包含哪些关键字段?&lt;/h3&gt;

&lt;h3 id=&#34;简述netfilter框架&#34;&gt;简述netfilter框架&lt;/h3&gt;

&lt;h3 id=&#34;说说你自己理解的linux内核tcp-ip协议栈-最好用关键函数表示&#34;&gt;说说你自己理解的linux内核TCP/IP协议栈?(最好用关键函数表示)&lt;/h3&gt;

&lt;h3 id=&#34;说说tcp拥塞控制&#34;&gt;说说TCP拥塞控制&lt;/h3&gt;

&lt;p&gt;	答: 慢启动, 拥塞避免, 快速恢复,快速重传&lt;/p&gt;

&lt;h3 id=&#34;说说网卡驱动框架&#34;&gt;说说网卡驱动框架&lt;/h3&gt;

&lt;h3 id=&#34;内核态调试&#34;&gt;内核态调试&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;BUG()与BUG_ON()&lt;/li&gt;
&lt;li&gt;dump_stack()&lt;/li&gt;
&lt;li&gt;printk()&lt;/li&gt;
&lt;li&gt;OOPS&lt;/li&gt;
&lt;li&gt;kdump&lt;/li&gt;
&lt;li&gt;kgdb&lt;/li&gt;
&lt;li&gt;kprobe&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;协议&#34;&gt;协议&lt;/h2&gt;

&lt;h3 id=&#34;三次握手及四次挥手&#34;&gt;三次握手及四次挥手&lt;/h3&gt;

&lt;p&gt;	答:&lt;/p&gt;

&lt;p&gt;三次握手: SYN -&gt; SYN/ACK -&gt; ACK;&lt;/p&gt;

&lt;p&gt;四次挥手: FIN -&gt; ACK -&gt; FIN -&gt; ACK;&lt;/p&gt;

&lt;h3 id=&#34;tcp状态变迁及对应函数调用&#34;&gt;TCP状态变迁及对应函数调用&lt;/h3&gt;

&lt;p&gt;	答: 11种(LISTEN, SYN_SENT, SYN_RCVD, ESTABLISHED, FIN_WAIT_1, CLOSE_WAIT, FIN_WAIT_2, TIME_WAIT, LAST_ACK, CLOSING, CLOSED);&lt;/p&gt;

&lt;h3 id=&#34;dns协议是tcp-udp协议-端口是多少&#34;&gt;DNS协议是TCP/UDP协议? 端口是多少?&lt;/h3&gt;

&lt;h3 id=&#34;听说过edns-client-subnet&#34;&gt;听说过edns-client-subnet?&lt;/h3&gt;

&lt;h3 id=&#34;dns资源记录&#34;&gt;DNS资源记录&lt;/h3&gt;

&lt;p&gt;	* A ipv4地址&lt;/p&gt;

&lt;p&gt;	* AAAA ipv6地址&lt;/p&gt;

&lt;p&gt;	* NS 授权DNS地址&lt;/p&gt;

&lt;p&gt;	* MX 邮件服务器地址&lt;/p&gt;

&lt;p&gt;	* CNAME 别名记录&lt;/p&gt;

&lt;p&gt;	* PTR 反向解析记录&lt;/p&gt;

&lt;h3 id=&#34;dns查询过程&#34;&gt;DNS查询过程&lt;/h3&gt;

&lt;h3 id=&#34;http工作流程&#34;&gt;http工作流程&lt;/h3&gt;

&lt;p&gt;	一次HTTP操作称为一个事务，其工作过程可分为四步：&lt;/p&gt;

&lt;p&gt;1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。&lt;/p&gt;

&lt;p&gt;2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。&lt;/p&gt;

&lt;p&gt;3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。&lt;/p&gt;

&lt;p&gt;4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。&lt;/p&gt;

&lt;p&gt;如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。&lt;/p&gt;

&lt;h3 id=&#34;http-状态码描述&#34;&gt;http 状态码描述&lt;/h3&gt;

&lt;p&gt;1XX－信息类(Information),表示收到Web浏览器请求，正在进一步的处理中&lt;/p&gt;

&lt;p&gt;2XX－成功类（Successful）,表示用户请求被正确接收，理解和处理例如：200 OK&lt;/p&gt;

&lt;p&gt;3XX-重定向类(Redirection),表示请求没有成功，客户必须采取进一步的动作。&lt;/p&gt;

&lt;p&gt;4XX-客户端错误(Client Error)，表示客户端提交的请求有错误 例如：404 NOT Found，意味着请求中所引用的文档不存在。&lt;/p&gt;

&lt;p&gt;5XX-服务器错误(Server Error)表示服务器不能完成对请求的处理：如 500&lt;/p&gt;

&lt;h1 id=&#34;原有项目介绍&#34;&gt;原有项目介绍&lt;/h1&gt;

&lt;h1 id=&#34;项目管理&#34;&gt;项目管理&lt;/h1&gt;

&lt;h3 id=&#34;学过项目管理认证方面的课程吗&#34;&gt;学过项目管理认证方面的课程吗?&lt;/h3&gt;

&lt;h1 id=&#34;综合&#34;&gt;综合&lt;/h1&gt;

&lt;h2 id=&#34;你对于我们公司有过了解吗&#34;&gt;你对于我们公司有过了解吗？&lt;/h2&gt;

&lt;p&gt;回答提示：在去公司面试前上网查一下该公司主营业务。如回答：贵公司有意改变策略，加强与国外大厂的OEM合作，自有品牌的部分则透过海外经销商。&lt;/p&gt;

&lt;h2 id=&#34;你最擅长的技术方向是什么&#34;&gt;你最擅长的技术方向是什么？&lt;/h2&gt;

&lt;p&gt;回答提示：说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。&lt;/p&gt;

&lt;h2 id=&#34;你的业余爱好是什么&#34;&gt;你的业余爱好是什么？&lt;/h2&gt;

&lt;p&gt;回答提示：找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。&lt;/p&gt;

&lt;h2 id=&#34;你欣赏哪种性格的人&#34;&gt;你欣赏哪种性格的人？&lt;/h2&gt;

&lt;p&gt;回答提示：诚实、不死板而且容易相处的人、有“实际行动”的人。&lt;/p&gt;

&lt;h2 id=&#34;你做过的哪件事最令自己感到骄傲&#34;&gt;你做过的哪件事最令自己感到骄傲？&lt;/h2&gt;

&lt;p&gt;回答提示：这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。&lt;/p&gt;

&lt;p&gt;假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。&lt;/p&gt;

&lt;h2 id=&#34;你觉得你个性上最大的优点是什么&#34;&gt;你觉得你个性上最大的优点是什么？&lt;/h2&gt;

&lt;p&gt;回答提示：沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱。&lt;/p&gt;

&lt;p&gt;我在北大青鸟经过一到两年的培训及项目实战，加上实习工作，使我适合这份工作。&lt;/p&gt;

&lt;h2 id=&#34;说说你最大的缺点&#34;&gt;说说你最大的缺点？&lt;/h2&gt;

&lt;p&gt;回答提示：这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，&lt;/p&gt;

&lt;p&gt;企业肯定不会录用你。绝对不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。&lt;/p&gt;

&lt;p&gt;企业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分，企业喜欢聪明的求职者。&lt;/p&gt;

&lt;h2 id=&#34;为什么要离职&#34;&gt;为什么要离职?&lt;/h2&gt;

&lt;p&gt;回答提示：①回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，&lt;/p&gt;

&lt;p&gt;避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，&lt;/p&gt;

&lt;p&gt;或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。②我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，已经达到顶峰，&lt;/p&gt;

&lt;p&gt;即沒有升迁机会。&lt;/p&gt;

&lt;h2 id=&#34;您最近这两年看过的书有哪些&#34;&gt;您最近这两年看过的书有哪些?&lt;/h2&gt;

&lt;h2 id=&#34;说说你对行业-技术发展趋势的看法&#34;&gt;说说你对行业、技术发展趋势的看法？&lt;/h2&gt;

&lt;p&gt;回答提示：企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。&lt;/p&gt;

&lt;p&gt;企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人” 。&lt;/p&gt;

&lt;h2 id=&#34;在五年的时间内-你的职业规划&#34;&gt;在五年的时间内，你的职业规划？&lt;/h2&gt;

&lt;p&gt;回答提示：这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多的答案是“管理者”。但是近几年来，许多公司都已经建立了专门的技术途径。&lt;/p&gt;

&lt;p&gt;这些工作地位往往被称作“顾问”、“参议技师”或“高级软件工程师”等等。当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与&lt;/p&gt;

&lt;p&gt;你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所&lt;/p&gt;

&lt;p&gt;作为”或“我希望能按照公司的管理思路发展”。&lt;/p&gt;

&lt;h2 id=&#34;你对薪资的要求&#34;&gt;你对薪资的要求？&lt;/h2&gt;

&lt;p&gt;回答提示：如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘&lt;/p&gt;

&lt;p&gt;的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。&lt;/p&gt;

&lt;p&gt;回答样本一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。&lt;/p&gt;

&lt;p&gt;回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。&lt;/p&gt;

&lt;p&gt;回答样本三：如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场作了调查，&lt;/p&gt;

&lt;p&gt;知道像自己这样学历的雇员有什么样的价值。&lt;/p&gt;

&lt;h1 id=&#34;其他&#34;&gt;其他&lt;/h1&gt;

&lt;h2 id=&#34;您还有什么需要问我的吗&#34;&gt;您还有什么需要问我的吗?&lt;/h2&gt;
</description>
        </item>
        
        <item>
            <title>DPDK开发随记</title>
            <link>http://yanwushuang.github.io/2016/09/06/dpdk-develop-notes/</link>
            <pubDate>Tue, 06 Sep 2016 19:37:20 HKT</pubDate>
            <author>Mospan</author>
            <guid>http://yanwushuang.github.io/2016/09/06/dpdk-develop-notes/</guid>
            <description>&lt;h1 id=&#34;性能调优&#34;&gt;性能调优&lt;/h1&gt;

&lt;h2 id=&#34;rte-rand&#34;&gt;rte_rand()&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;现象：使用top perf -g查看时发现__drand48_iterate()所占比例达到40%以上。&lt;/li&gt;
&lt;li&gt;分析：跟踪__drand48_iterate()跟随机数有关， 查看代码响应记录按权重比例负载时使用了rte_rand().&lt;/li&gt;
&lt;li&gt;测试：屏蔽掉rte_rand()，性能上升了100多万。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;faq&#34;&gt;FAQ&lt;/h1&gt;

&lt;h2 id=&#34;打开dpdk工程makefile编译详细信息&#34;&gt;打开DPDK工程Makefile编译详细信息？&lt;/h2&gt;

&lt;p&gt;答：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开dpdk/mk/rte.sdkroot.mk文件。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;#+BEGIN_SRC shell&lt;/p&gt;

&lt;p&gt;# define Q to &#39;@&#39; or not. $(Q) is used to prefix all shell commands to&lt;/p&gt;

&lt;p&gt;# be executed silently.&lt;/p&gt;

&lt;p&gt;Q=&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;把变量Q赋为空。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;出现这个错误-include-dpdk-rte-memcpy-h-870-2-错误-mm-storeu-si128-的第-2-个实参类型不兼容的解决办法&#34;&gt;出现这个错误： include/dpdk/rte_memcpy.h:870:2: 错误：‘_mm_storeu_si128’的第 2 个实参类型不兼容的解决办法&lt;/h2&gt;

&lt;p&gt;答：&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC shell&lt;/p&gt;

&lt;p&gt;include $(RTE_SDK)/mk/rte.vars.mk&lt;/p&gt;

&lt;p&gt;include $(RTE_SDK)/mk/internal/rte.build-pre.mk&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;只要在自己的Makefile中增加如下两行即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;在虚拟机中跑dpdk-网卡接收不正常问题&#34;&gt;在虚拟机中跑DPDK，网卡接收不正常问题。&lt;/h2&gt;

&lt;h3 id=&#34;现象&#34;&gt;现象&lt;/h3&gt;

&lt;p&gt;虚拟出来的网卡只收到了少量的ARP包，并且QANS可以响应ARP请求成功，但收不到icmp与DNS包等。&lt;/p&gt;

&lt;h3 id=&#34;调试过程&#34;&gt;调试过程&lt;/h3&gt;

&lt;h3 id=&#34;原因&#34;&gt;原因&lt;/h3&gt;

&lt;p&gt;使用虚拟机创建出的KNI虚拟机网卡，每次重启后会随机变化并且与物理网卡不一致，到时ARP学习不正常。&lt;/p&gt;

&lt;h3 id=&#34;解决办法&#34;&gt;解决办法&lt;/h3&gt;

&lt;p&gt;在KNI创建虚拟机网卡成功后，使用命令: ifconfig XX hw ether XX:XX:XX:XX:XX:XX 进行配置成物理网卡MAC即可。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;虚拟网卡虚拟出来的是intel 82540EM网卡。&lt;/li&gt;
&lt;li&gt;查看DPDK官方支持网卡列表，支持intel 82540，但不知道与82540EM有哪些细微差别。&lt;/li&gt;
&lt;li&gt;尝试了virtual下可配的虚拟网卡(82545em，82543gc, 82545em，virtio-net)，无一完全成功。&lt;/li&gt;
&lt;li&gt;网卡流量统计，确实只收到了少量与arp包数等同的包(一直ping了10多分钟)。 &lt;/li&gt;
&lt;li&gt;查看了KNI创建的虚拟网卡发现每次启动MAC地址都随机的变化，查看了官方文档与网上结论说有些时候网卡MAC会随机变化，但没有说具体原因情况。&lt;/li&gt;
&lt;li&gt;使用DPDK本身提供的接口rte_eth_macaddr_get()进行读取，发现与物理网卡一致而与KNI创建出的虚拟网卡不一致。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;出现igb-uio-unknown-symbol-uio-unregister-device的解决办法&#34;&gt;出现igb_uio: Unknown symbol uio_unregister_device的解决办法？&lt;/h2&gt;

&lt;p&gt;答：&lt;/p&gt;

&lt;p&gt;在dpdk/lib/librte_eal/linuxapp/igb_uio/Makefile中添加如下行：&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC shell&lt;/p&gt;

&lt;p&gt;KBUILD_EXTRA_SYMBOLS=/usr/src/linux-headers-`uname -r`/Module.symvers&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;h2 id=&#34;使用vmware-exsi虚拟出来的vmnet3类型网卡不能绑定gib网卡将会系统挂掉的解决办法&#34;&gt;使用vmware EXSI虚拟出来的vmnet3类型网卡不能绑定gib网卡将会系统挂掉的解决办法。&lt;/h2&gt;

&lt;p&gt;答：在vmware中换成E1000类型网卡即可正常。&lt;/p&gt;

&lt;h2 id=&#34;在最小ubuntu-16-04系统下要运行dpdk进程需安装文件列表&#34;&gt;在最小Ubuntu 16.04系统下要运行dpdk进程需安装文件列表。&lt;/h2&gt;

&lt;p&gt;答: 只要安装如下软件即可。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;apt-get update&lt;/li&gt;
&lt;li&gt;apt-get install openssh-server&lt;/li&gt;
&lt;li&gt;apt-get install tcpdump&lt;/li&gt;
&lt;li&gt;apt install gcc&lt;/li&gt;
&lt;li&gt;apt install libpcap-dev&lt;/li&gt;
&lt;li&gt;apt install lrzsz&lt;/li&gt;
&lt;li&gt;apt install kernel-source&lt;/li&gt;
&lt;li&gt;apt-get install kernel-source&lt;/li&gt;
&lt;li&gt;apt-get install linux-headers-`uname -r`&lt;/li&gt;
&lt;li&gt;apt install python&lt;/li&gt;
&lt;li&gt;apt-get install make&lt;/li&gt;
&lt;li&gt;apt install libpcap-dev&lt;/li&gt;
&lt;li&gt;apt install doxygen&lt;/li&gt;
&lt;li&gt;apt-get install libdbus-1-dev&lt;/li&gt;
&lt;li&gt;apt-get install libdbus-glib-1-dev&lt;/li&gt;
&lt;li&gt;ln -sf dbus-1.0/dbus dbus&lt;/li&gt;
&lt;li&gt;apt install libssl-dev&lt;/li&gt;
&lt;li&gt;apt-get install libexpat1-dev&lt;/li&gt;
&lt;li&gt;apt install flex&lt;/li&gt;
&lt;li&gt;apt install tree&lt;/li&gt;
&lt;li&gt;apt install linux-tools-generic&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title></title>
            <link>http://yanwushuang.github.io/post/2016/2016-08-31-speech-of-zhangyiming/</link>
            <pubDate>Wed, 31 Aug 2016 08:02:49 HKT</pubDate>
            <author>Mospan</author>
            <guid>http://yanwushuang.github.io/post/2016/2016-08-31-speech-of-zhangyiming/</guid>
            <description></description>
        </item>
        
        <item>
            <title>go语言学习笔记</title>
            <link>http://yanwushuang.github.io/post/2016/2016-08-29-golang-learning-notes/</link>
            <pubDate>Mon, 29 Aug 2016 17:37:54 HKT</pubDate>
            <author>Mospan</author>
            <guid>http://yanwushuang.github.io/post/2016/2016-08-29-golang-learning-notes/</guid>
            <description></description>
        </item>
        
        <item>
            <title>org-mode使用手册</title>
            <link>http://yanwushuang.github.io/2016/05/29/org-manual/</link>
            <pubDate>Sun, 29 May 2016 09:33:53 HKT</pubDate>
            <author>Mospan</author>
            <guid>http://yanwushuang.github.io/2016/05/29/org-manual/</guid>
            <description>&lt;h1 id=&#34;总介&#34;&gt;总介&lt;/h1&gt;

&lt;h2 id=&#34;摘要-org大概能够做什么的摘要&#34;&gt;摘要&lt;/h2&gt;

&lt;p&gt;Org是一种通过纯文本方式来快速而有效地记录笔记,处理待办列表,做项目计划的mode.&lt;/p&gt;

&lt;p&gt;Org通过一些NOTE文件来组织任务,这些NOTE文件用纯文本的方式包含了一些列的项目信息. Org是建立在Outline mode的基础之上的,Outline mode能够很好地组织大型文件的内容. 你可以使用可视的循环和结构编辑功能来帮助你编辑大纲树结构. 通过使用内置的表格编辑器,你也可以很容易地创建出一个表格. Org可以管理代办列表,设置最后期限,加时间戳,制定规划. 它动态的把这些东西显示在一个agenda中,在这个agenda中很好地集成了Emacs calendar和diary功能. 你可以用纯文本的方式记录各种类URL的连接,这些连接可以链接到网站,email,Usenet消息,BBDB(The insidious Big Brother Database)条目,和任何与项目有关的文件. 如果你想打印和分享这些记录,你可以把org导出为结构化的ASCII文件,比如HTML,或者iCalendar文件(仅限于TODO和日程条目). 它也可以作为发布工具,为一堆的相互链接的网页提供发布服务.&lt;/p&gt;

&lt;p&gt;作为一个项目计划的环境,Org通过为大纲节点增加元数据的方式工作. 正是基于这些元数据,我们可以通过查询抽取特定的记录并且动态地创建agenda视图.&lt;/p&gt;

&lt;p&gt;Org模式中也可以包含其他非org环境,这些环境运行你编辑文件中的内嵌源代码,更便利地执行代码,记录文档,进行文学化编程.&lt;/p&gt;

&lt;p&gt;通过激活Orgtbl mode,任何major mode都能拥有Org的表格编辑功能,这些表格编辑功能不仅自动化,上下文敏感,而且具有电子表格(spreadsheet)的运算能力. 通过一个转换步骤,就可以用它来包含一个表格到任意文件类型中(比如LaTeX). 通过minor Orgstruct mode,可以在非Org mode中使用Org的结构编辑和列表创建功能.&lt;/p&gt;

&lt;p&gt;Org保持简单的事情简单化. 当第一次使用它时,感觉它就是个简单易用的大纲编辑器. 它不强加给你复杂性,但是当你需要的时候,却会发现有大量的功能可以使用. Org就是一个工具盒,你可以为了不同的目的,通过的不同的途径来使用它,例如你可以把它看成是:&lt;/p&gt;

&lt;p&gt;#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;• 一个具有可见性的转换和结构编辑能力的outline mode扩展&lt;/p&gt;

&lt;p&gt;• 一个记录结构化记录的ASCII系统和表格编辑器&lt;/p&gt;

&lt;p&gt;• 一个TODO列表的编辑器&lt;/p&gt;

&lt;p&gt;• 一个完整的日程表和计划规划工具,你可以设定工作的最后截止日期和规划执行日期.&lt;/p&gt;

&lt;p&gt;• 一个GTD系统&lt;/p&gt;

&lt;p&gt;• 一个简单的超文本系统,可以导出HTML和LaTeX格式的文件&lt;/p&gt;

&lt;p&gt;• 一个发布工具,可以用来创建一套相互链接的网页&lt;/p&gt;

&lt;p&gt;• 一个进行文学化编程的环境&lt;/p&gt;

&lt;p&gt;#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;有一个网站提供了最新版本的Org连接,还有附加信息,FAQ,和入门指导.这个网页就是http://orgmode.org&lt;/p&gt;

&lt;h2 id=&#34;安装-下载org后-如何安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;*注意*:如果你使用的是Emacs或者XEmacs中自带的Org版本,请跳过这一步直接前往&lt;a href=&#34;Activition&#34; title=&#34;激活&#34;&gt;激活&lt;/a&gt;. 如果需要查看你Emacs中自带的Org是什么版本的,按下 &lt;em&gt;M-x load-library RET org&lt;/em&gt; 然后再 &lt;em&gt;M-x org-version&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;如果你从网站上下载了Org,不管它是zip还是tar格式的分发包,也不管它是不是Git存档,你必须遵照下面的步骤来安装它:&lt;/p&gt;

&lt;p&gt;解压Org分发包并进入解压的目录中,然后编辑顶层目录中的&#39;Makefile&#39;文件. 你必须设置Emacs的二进制执行文件的名字(一般是&#39;emacs&#39;或者&#39;xemacs&#39;),设置Lisp和Info文件存放的路径. 如果你没有权限访问全系统的目录,你只需要简单地把&#39;lisp&#39;子目录加入Emacs的load-path中,然后就可以运行org mode了.如果你用这种方法,需要把下面这一行加入&#39;.emacs&#39;文件中&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC emacs-lisp&lt;/p&gt;

&lt;p&gt;(setq load-path (cons &#34;~/path/to/orgdir/lisp&#34; load-path))&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;如果你想使用&#39;contrib&#39;子目录中的代码,你只需要加这么一句&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC emacs-lisp&lt;/p&gt;

&lt;p&gt;(setq load-path (cons &#34;~/path/to/orgdir/contrib/lisp&#34; load-path))&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;现在用下面的shell命令来把lisp文件编译为字节格式&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC sh&lt;/p&gt;

&lt;p&gt;make&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;如果你只是从发布目录运行Org,这就是所有的步骤了. 如果你想要安装Org到系统目录中,指向下面命令(需要系统管理员权限)&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC sh&lt;/p&gt;

&lt;p&gt;make install&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;安装Info文件是系统依赖的,不同的系统使用的是不同的&#39;install-info&#39;程序. 下面的命令理论上应该可以正确的安装Info文件到大多数系统中,但如果没有正确的安装的话,欢迎发送BUG报告给我们[fn:1]&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC sh&lt;/p&gt;

&lt;p&gt;make install-info&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;然后把下面一行添加到&#39;.eamcs&#39;文件中. 这使得Emacs可以在需要的时候自动加载文件中的函数,而不用在Org mode已启动的时候就加载&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC emacs-lisp&lt;/p&gt;

&lt;p&gt;(require &#39;org-install)&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;不要忘了激活Org,具体操作见下一节.&lt;/p&gt;

&lt;h2 id=&#34;激活-如何为指定的buffer激活org模式-activition&#34;&gt;激活&lt;/h2&gt;

&lt;p&gt;为了保证后缀为&#39;.org&#39;的文件会使用Org mode,在&#39;.emacs&#39;文件中增加下面一行&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC emacs-lisp&lt;/p&gt;

&lt;p&gt;(add-to-list &#39;auto-mode-alist &#39;(&#34;\\.org\\&#39;&#34; . org-mode))&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;Org-mode缓冲区需要打开font-lock选项,默认情况下Emacs已经打开次选项[fn:2]. 有4个Org命令应该定义全局的快捷键(也就是说作用于在Emacs的任何地方,而不仅仅是Org缓存区),这四个org命令为&#39;org-store-link&#39;,&#39;org-capture&#39;,&#39;org-agenda&#39;和&#39;org-iswitchb&#39;. 下面是建议的绑定键设置,你可以按照自己喜欢的来修改键配置&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC emacs-lisp&lt;/p&gt;

&lt;p&gt;(global-set-key &#34;\C-cl&#34; &#39;org-store-link)&lt;/p&gt;

&lt;p&gt;(global-set-key &#34;\C-cc&#34; &#39;org-capture)&lt;/p&gt;

&lt;p&gt;(global-set-key &#34;\C-ca&#34; &#39;org-agenda)&lt;/p&gt;

&lt;p&gt;(global-set-key &#34;\C-cb&#34; &#39;org-iswitchb)&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;经过上面这些配置,所有后缀为&#39;.org&#39;的文件在打开时会直接进入Org-mode. 如果你想不这么配置,作为替代,把下面这句放到文件的一行也可以.&lt;/p&gt;

&lt;p&gt;#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;MY PROJECTS    -*- mode: org; -*-&lt;/p&gt;

&lt;p&gt;#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;这样,不管文件名是什么,在打开时都会进去Org-mode. 参见变量&#39;org-insert-mode-line-in-empty-file&#39;.&lt;/p&gt;

&lt;p&gt;很多Org命令在选定文本块时会对文本块进行操作. 为了保证该特性被启用,你需要开启&#39;transient-mark-mode&#39;(在XEmacs总是&#39;zmacs_regions&#39;). 在Emacs23中默认是打开的,但是在Emacs22中,你需要自己打开,自己打开的命令为&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC emacs-lisp&lt;/p&gt;

&lt;p&gt;(transient-mark-mode 1)&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;如果你不想使用transient-mark-mode,你可以通过鼠标选择一个区域,以这种方式来建立一个选定的文本块,或者在一定光标之前安两下&#39;C-&lt;SPC&gt;&#39;&lt;/p&gt;

&lt;h2 id=&#34;反馈-bug报告-好的想法-补丁等等&#34;&gt;反馈&lt;/h2&gt;

&lt;p&gt;如果你发现了Org有问题,或者你有疑问,建议和好的想法,请发邮件到Org的mailing list &lt;a href=&#34;emacs-orgmode@gnu&#34; title=&#34;emacs-orgmode@gnu&#34;&gt;emacs-orgmode@gnu&lt;/a&gt;. 如果你还不是这个mailing list的会员, 那么在版主批准之后,你的mail会被加入到mailing list中[fn:3].&lt;/p&gt;

&lt;p&gt;如果你想报告BUG,请首先在最新版本的Org上复现这个BUG--如果你允许一个老旧版本的Org,很可能这个Bug已经被修复了. 如果依旧有问题,请写好报告并提供尽可能多的信息,包括Emacs的版本信息(用M-x emacs-version &lt;RET&gt;)和Org的版本信息(用M-x org-version &lt;RET&gt;),以及&#39;.emacs&#39;中Org的相关配置. 最简单的提交报告的方法就是执行命令&#39;M-x org-submit-bug-report&#39;. 这个命令会收集所有必要的信息并放到一个Emacs的mail缓存区中,这样你只需要添加你自己的描述就可以了. 如果你不会在Emacs中发送email,请拷贝这些内容并粘贴到自己常用的Email程序中.&lt;/p&gt;

&lt;p&gt;有时候你面对的错误可能是由于Emacs或Org-mode配置错了. 在报告BUG之前,最后以最小客户化的形式启动Emacs然后复现这个BUG. 这样做常常能够帮助你确定这个问题是因为配置的关系还是Org-mode本身有问题. 你可以用下面这个命令来开启一个最低客户化的session&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC sh&lt;/p&gt;

&lt;p&gt;emacs -Q -l /path/to/minimal-org.el&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;如果你使用的是Emacs中自带的Org mode,那么上面哪个最小客户化的配置就没有必要了. 你可以直接用&#39;emacs -Q&#39;来打开Emacs. 一个典型的&#39;minimal-org.el&#39;配置文件可能包含如下内容&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC emacs-lisp&lt;/p&gt;

&lt;p&gt;;;; Minimal setup to load latest `org-mode&#39;&lt;/p&gt;

&lt;p&gt;;; activate debugging&lt;/p&gt;

&lt;p&gt;(setq debug-on-error t&lt;/p&gt;

&lt;p&gt;debug-on-signal nil&lt;/p&gt;

&lt;p&gt;debug-on-quit nil)&lt;/p&gt;

&lt;p&gt;;; add latest org-mode to load path&lt;/p&gt;

&lt;p&gt;(add-to-list &#39;load-path (expand-file-name &#34;/path/to/org-mode/lisp&#34;))&lt;/p&gt;

&lt;p&gt;(add-to-list &#39;load-path (expand-file-name &#34;/path/to/org-mode/contrib/lisp&#34;))&lt;/p&gt;

&lt;p&gt;;; activate org&lt;/p&gt;

&lt;p&gt;(require &#39;org-install)&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;如果有错误发生,一个错误的跟踪栈对查找问题很有帮助(下面说明了如何创建一个跟踪栈). 通常提供一个简单的造成错误的简单例子会很有帮助, 再加上以下这些信息:&lt;/p&gt;

&lt;p&gt;#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;#+END_EXAMPLE&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;你做了什么&lt;/li&gt;
&lt;li&gt;你希望的结果是什么&lt;/li&gt;
&lt;li&gt;实际上的结果是什么&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;感谢您帮助我们改进这个程序.&lt;/p&gt;

&lt;h3 id=&#34;如何创建一个有用的跟踪栈&#34;&gt;如何创建一个有用的跟踪栈&lt;/h3&gt;

&lt;p&gt;如果Org报出了一个i额你不明白的出错信息,你可能发现了BUG. 报告这个BUG的最好方法是提供一个跟踪栈(backtrace). 跟踪栈使用内置的调试信息来收集一些信息,这些信息包括错误发生的地点和方式. 下面是提供一个有用跟踪栈的步骤&lt;/p&gt;

&lt;p&gt;#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;C-u M-x org-reload RET&lt;/p&gt;

&lt;p&gt;#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;或者在Emacs菜单上选择&#39;Org -&gt; Refresh/Reload -&gt; Reload Org uncompiled&#39;&lt;/p&gt;

&lt;h2 id=&#34;手册中的排版约定-手册中的排版约定&#34;&gt;手册中的排版约定&lt;/h2&gt;

&lt;p&gt;Org使用三种类型的关键字:TODO关键字,标签和属性名称. 在该手册中我们使用如下约定:&lt;/p&gt;

&lt;p&gt;#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;TODO&lt;/p&gt;

&lt;p&gt;WAITING&lt;/p&gt;

&lt;p&gt;#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;TODO关键字全部大些,即使它们可以用户随意定义的.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;重新加载未编译的所有Org mode的Lisp源文件. 如果错误是在未编译的脚本中产生时,跟踪栈能够提供多得多的信息. 要做到这一步,执行&lt;/li&gt;
&lt;li&gt;在&#39;Options&#39;菜单中选择&#39;Enter Debugger On error&#39;(如果是使用XEmacs,需要在&#39;Troubleshooting&#39;子菜单中选择此项).&lt;/li&gt;
&lt;li&gt;复现错误,别忘了记录操作的每个步骤&lt;/li&gt;
&lt;li&gt;当错误产生了,一个名为*Backtrace*的缓存区会显示出来,保存这个缓存区到文件中(一般是用C-x C-w命令)然后附加在你的错误报告中.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;boss&lt;/p&gt;

&lt;p&gt;ARCHIVE&lt;/p&gt;

&lt;p&gt;#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;用户自定义的标签使用全小些;内置的标签具有特定的意义,使用全大些形式&lt;/p&gt;

&lt;p&gt;#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;Release&lt;/p&gt;

&lt;p&gt;PRIORITY&lt;/p&gt;

&lt;p&gt;#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;用户自定义的属性使用首字母大些;内置属性有特定意义的,使用全大些形式.&lt;/p&gt;

&lt;p&gt;该手册列出特定功能的键序列和相应的命令. Org mode经常使用相同的键序列来在不同的上下文中触发不同的功能. 绑定到这些键序列的命令都有一个通用的名称,比如&#39;org-metaright&#39;. 在该手册中,我们会尽可能的给出通用命令内部调用的函数名称. 例如,在文件结构的章节上按下&#39;M-&lt;right&gt;&#39;会被指明调用的是&#39;org-do-demote&#39;程序,而在表标题上按下相同的键序列时,我们会指明调用的是&#39;org-table-move-column-right&#39;.&lt;/p&gt;

&lt;p&gt;如果你愿意,你可以编译这份手册使之不带有命令名称,方法是在&#39;org.texi&#39;中取出&#39;cmdnames&#39;标志.&lt;/p&gt;

&lt;h1 id=&#34;文档结构&#34;&gt;文档结构&lt;/h1&gt;

&lt;p&gt;Org是基于Outline-mode的,它提供了大量的命令来编辑文档的结构.&lt;/p&gt;

&lt;h2 id=&#34;大纲-org是基于outline-mode的&#34;&gt;大纲&lt;/h2&gt;

&lt;p&gt;Org的实现是基于Outline-mode的.Outline运行文档按照分级结构的方式来组织,这种方式(至少对于我来说)是用来展示记录和想法的最佳方式.通过折叠(隐藏)绝大部分的文档内容而只显示文档的大致结构和正在编辑的这一部分内容,一个文档结构的总览被完美地展示出来. Org极大地简化了对大纲的操作,它把整个显示/隐藏功能都通过一个命令来完成:&#39;org-cycle&#39;,这个命令被绑定到了&lt;TAB&gt;键上.&lt;/p&gt;

&lt;h2 id=&#34;标题-如何排版org的树状标题&#34;&gt;标题&lt;/h2&gt;

&lt;p&gt;标题定义了大纲树的结构. Org的标题以一个或多个星号开头,向左对齐[fn:4]. 例如:&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* Top level headline&lt;/p&gt;

&lt;p&gt;,** Second level&lt;/p&gt;

&lt;p&gt;,*** 3rd level&lt;/p&gt;

&lt;p&gt;,    some text&lt;/p&gt;

&lt;p&gt;,*** 3rd level&lt;/p&gt;

&lt;p&gt;,    more text&lt;/p&gt;

&lt;p&gt;,* Another top level headline&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;有些人觉得太多的星号眼花缭乱,它们可能更喜欢Outline-mode使用空格加星号的格式作为标题的开始标识.&lt;a href=&#34;A cleaner outline view&#34; title=&#34;一个更简洁的大纲显示&#34;&gt;一个更简洁的大纲显示&lt;/a&gt;中描述了如何配置.&lt;/p&gt;

&lt;p&gt;在子树的末尾的空行,被认为是子树的一部分,它会随着子树的折叠而被隐藏. 然而,如果你放了两个空行,那么在折叠这个子树的时候,还会有一个空行是可见的,这样做的目的常常是为了构造分割的视图. 要改变这种行为,需要配置变量&#39;org-cycle-separator-lines&#39;&lt;/p&gt;

&lt;h2 id=&#34;可见性的转换-显示和隐藏-很简单&#34;&gt;可见性的转换&lt;/h2&gt;

&lt;p&gt;Outline使得隐藏缓存区中的一部分文本成为可能. Org仅仅使用两个命令来切换缓存区的可见性,这两个命令被绑定到了&#39;&lt;TAB&gt;&#39;和&#39;S-&lt;TAB&gt;&#39;上.&lt;/p&gt;

&lt;p&gt;* &lt;TAB&gt; (org-cycle) :: 子树循环:以下面的循环状态来切换当前子树的状态&lt;/p&gt;

&lt;p&gt;	#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;	,-&gt; FOLDED -&gt; CHILDREN -&gt; SUBTREE --.&lt;/p&gt;

&lt;p&gt;	&#39;-----------------------------------&#39;&lt;/p&gt;

&lt;p&gt;	#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;	为了执行子树的切换,光标位置必须在子树的标题上[fn:5]. 若光标在缓存区的最前端,而这第一行又不是标题,那么&lt;TAB&gt;实际上执行的是&#39;全局循环&#39;(具体情况见下文)[fn:6]. 同样的,如果使用的是带前缀参数的&lt;TAB&gt;(C-u &lt;TAB&gt;),调用的也是&#39;全局循环&#39;&lt;/p&gt;

&lt;p&gt;* S-&lt;TAB&gt; / C-u &lt;TAB&gt; (org-global-cycle) :: 全局循环:使整个缓存区在在不同状态间切换&lt;/p&gt;

&lt;p&gt;	#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;	 ,-&gt; OVERVIEW -&gt; CONTENTS -&gt; SHOW ALL --.&lt;/p&gt;

&lt;p&gt;	&#39;--------------------------------------&#39;&lt;/p&gt;

&lt;p&gt;	#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;	若再S-&lt;TAB&gt;前加了一个数字前缀N,那么CPMTEMTS一直到第N个层次的内容都会显示出来. 需要注意的是,若是在编辑表格中,S-&lt;TAB&gt;的作用是跳到上一个域.&lt;/p&gt;

&lt;p&gt;* C-u C-u &lt;TAB&gt; (show-all) ::&lt;/p&gt;

&lt;p&gt;	显示所有信息,包括&#39;抽屉&#39;内的信息&lt;/p&gt;

&lt;p&gt;* C-c C-r (org-reveal) ::&lt;/p&gt;

&lt;p&gt;	显示光标周围的上下文,也就是显示当前条目,以及所有上层标题. Useful for working near a location that has been exposed by a sparse tree command (see section Sparse trees) or an agenda command (see section Commands in the agenda buffer). With a prefix argument show, on each level, all sibling headings. With a double prefix argument, also show the entire subtree of the parent. (TODO 真没看懂什么意思,在实验C-c C-r的时候我的Org居然没反应...)&lt;/p&gt;

&lt;p&gt;* C-c C-k (show-branches) ::&lt;/p&gt;

&lt;p&gt;	展开所有子树的标题,如果只有一个子树,那么内容也显示出来.&lt;/p&gt;

&lt;p&gt;* C-c C-x b (org-tree-to-indirect-buffer) ::&lt;/p&gt;

&lt;p&gt;	把当前子树显示在indirect buffer中[fn:7]. 如果加了一个前缀参数N,它会向下进入地N层子树并在indirect buffer中显示该子树. 如果N是负数,那么就是向上进入N层的父节点. 如果命令执行前加了C-u前缀,则打开新的indirect buffer,而不会关闭之前打开的indirect buffer.&lt;/p&gt;

&lt;p&gt;* C-c C-x v (org-copy-visible) ::&lt;/p&gt;

&lt;p&gt;	拷贝文本块中的可见文本到kill ring中&lt;/p&gt;

&lt;p&gt;当Emacs第一次打开一个Org文件时,全局状态为OVERVIEW,也就是说,只有顶层的标题是可见的. 这个行为可以通过配置&#39;org-startup-folded&#39;变量来改变.或者可以在文件的任何地方添加下面所列出的任何一句,Emacs就会根据这句配置信息自动设置初始的状态.&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+STARTUP: overview&lt;/p&gt;

&lt;p&gt;,#+STARTUP: content&lt;/p&gt;

&lt;p&gt;,#+STARTUP: showall&lt;/p&gt;

&lt;p&gt;,#+STARTUP: showeverything&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;此外,任何带有&#39;VISIBILITY&#39;属性名的条目(参考&lt;a href=&#34;#Properities and columns&#34; title=&#34;属性与列&#34;&gt;属性与列&lt;/a&gt;)会相应地按照该属性值来设置可见性. 该属性的有效值可以使&#39;folded&#39;,&#39;children&#39;,&#39;cotent&#39;和&#39;all&#39;&lt;/p&gt;

&lt;p&gt;* C-u C-u &lt;TAB&gt; (org-set-startup-visiblity) ::&lt;/p&gt;

&lt;p&gt;重置该buffer的可见性为该buffer在启动时的可见性,也就是说根据buffer的&#39;startup&#39;选项和各个单独条目的&#39;VISIBILITY&#39;属性来重新设置整个buffer的可见性.&lt;/p&gt;

&lt;h2 id=&#34;移动-跳转到其他标题&#34;&gt;移动&lt;/h2&gt;

&lt;p&gt;下面的命令跳转到buffer中的其他标题&lt;/p&gt;

&lt;p&gt;* C-c C-n (outline-next-visible-heading) ::&lt;/p&gt;

&lt;p&gt;下一个标题&lt;/p&gt;

&lt;p&gt;* C-c C-p (outline-previous-visible-heading) ::&lt;/p&gt;

&lt;p&gt;	上一个标题&lt;/p&gt;

&lt;p&gt;* C-c C-f (org-forward-same-level) ::&lt;/p&gt;

&lt;p&gt;	同一级的下一个标题&lt;/p&gt;

&lt;p&gt;* C-c C-b (org-backward-same-level) ::&lt;/p&gt;

&lt;p&gt;	同一级的上一个标题&lt;/p&gt;

&lt;p&gt;* C-c C-u (outline-up-heading) ::&lt;/p&gt;

&lt;p&gt;	回到上一级标题&lt;/p&gt;

&lt;p&gt;* C-c C-j (org-goto) ::&lt;/p&gt;

&lt;p&gt;	跳转到其他位置的同时不改变当前大纲的可见性. 在一个临时buffer中显示文档的结构,在这个临时buffer中你可以使用下面的快捷键来定位:&lt;/p&gt;

&lt;p&gt;	#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;	&lt;TAB&gt;           切换可见性&lt;/p&gt;

&lt;p&gt;	&lt;down&gt; / &lt;up&gt;   下一个/上一个可见的标题&lt;/p&gt;

&lt;p&gt;	&lt;RET&gt;           选定当前位置&lt;/p&gt;

&lt;p&gt;	/               在树中作一个匹配查询&lt;/p&gt;

&lt;p&gt;	如果你关掉了org-goto-auto-isearch选项,下面这些快捷键才可用&lt;/p&gt;

&lt;p&gt;	n / p           下一个/上一个可见的标题&lt;/p&gt;

&lt;p&gt;	f / b           同级别的上一个/下一个标题&lt;/p&gt;

&lt;p&gt;	u               回到上一级标题&lt;/p&gt;

&lt;p&gt;	0-9             数字参数&lt;/p&gt;

&lt;p&gt;	q               退出这个临时buffer&lt;/p&gt;

&lt;p&gt;	#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;	参见变量&#39;org-goto-interface&#39;&lt;/p&gt;

&lt;h2 id=&#34;结构编辑-改变标题的次序和层次&#34;&gt;结构编辑&lt;/h2&gt;

&lt;p&gt;* M-&lt;RET&gt; (org-insert-heading) ::&lt;/p&gt;

&lt;p&gt;插入一个与当前位置同级别的新标题. 如果光标位于一个普通的列表项,新的列表项被创建(参见&lt;a href=&#34;#Plain list&#34; title=&#34;普通列表&#34;&gt;普通列表&lt;/a&gt;). 要强制创建新标题,则需要使用前缀参数. 如果在一行的中间执行这个命令,那么这一行会被分割成两行,光标到行尾的内容会成为新的标题[fn:8]. 如果实在一个标题的开头执行这个命令,那么新标题会天骄到当前行的前面. 如果是在所有行的前面执行这个命令,那么就创建了一个新的文件头. 如果是在折叠起来的子树末尾使用这个命令(也就是说,是在标题末尾的省略号之后),那么与当前标题类似的标题会被插入到这个子树的末尾.&lt;/p&gt;

&lt;p&gt;* C-&lt;RET&gt; (org-insert-heading-respect-content) ::&lt;/p&gt;

&lt;p&gt;	类似与M-&lt;RET&gt;,不同之处在于,当在当前标题后增加一个新标题时,M-&lt;RET&gt;会在当前标题的内容前增加一个新标题(内容成为这个新标题的内容),而C-&lt;ERT&gt;则在内容后增加一个新标题(内容还是原标题的内容). 这个命令在条目的任何地方都是一样的行为.&lt;/p&gt;

&lt;p&gt;* M-S-&lt;RET&gt; (org-insert-todo-heading) ::&lt;/p&gt;

&lt;p&gt;	插入一个与当前标题同级别的TODO事项. 参见变量&#39;org-treat-insert-todo-heading-as-state-change&#39;&lt;/p&gt;

&lt;p&gt;* C-S-&lt;RET&gt; (org-insert-todo-heading-respect-content) ::&lt;/p&gt;

&lt;p&gt;	插入一个与当前标题同级别的TODO事项, 与C-&lt;RET&gt;类似,新的标题会插在当前子树的后面.&lt;/p&gt;

&lt;p&gt;* &lt;TAB&gt; (org-cycle) ::&lt;/p&gt;

&lt;p&gt;	在一个未输入内容的标题上,第一次按&lt;TAB&gt;,这个标题成为了上一个标题的子标题,再按一下&lt;TAB&gt;,这个标题的级别变成了上一个标题的父标题,然后每按一次&lt;TAB&gt;级别就上升一级,一直到最高级.到了最高级再按一次&lt;TAB&gt;,又会回到初始的级别.&lt;/p&gt;

&lt;p&gt;* M-&lt;left&gt; (org-do-promote) ::&lt;/p&gt;

&lt;p&gt;	提升当前标题一级&lt;/p&gt;

&lt;p&gt;* M-&lt;right&gt; (org-do-demote) ::&lt;/p&gt;

&lt;p&gt;	降低当前标题一级&lt;/p&gt;

&lt;p&gt;* M-S-&lt;left&gt; (org-promote-subtree) ::&lt;/p&gt;

&lt;p&gt;	提升当前子树一级&lt;/p&gt;

&lt;p&gt;* M-S-&lt;right&gt; (org-demote-subtree) ::&lt;/p&gt;

&lt;p&gt;	降低当前子树一级&lt;/p&gt;

&lt;p&gt;* M-S-&lt;down&gt; (org-move-subtree-up) ::&lt;/p&gt;

&lt;p&gt;上移当前子树(与同级别的上一个子树交换位置)&lt;/p&gt;

&lt;p&gt;* M-S-&lt;down&gt; (org-move-subtree-down) ::&lt;/p&gt;

&lt;p&gt;下移当前子树(与同级别的下一个子树交换位置)&lt;/p&gt;

&lt;p&gt;* C-c C-x C-w (org-cut-subtree) ::&lt;/p&gt;

&lt;p&gt;	剪切当前子树,也就是说把当前子树从buffer移到kill ring中. 加一个前缀参数N,会剪切N个连续的子树.&lt;/p&gt;

&lt;p&gt;* C-c C-x M-w (org-copy-subtree) ::&lt;/p&gt;

&lt;p&gt;	把当前子树拷贝入kill ring中, 加上一个前缀参数N,会拷贝N个连续子树&lt;/p&gt;

&lt;p&gt;* C-c C-x C-y (org-paste-subtree) ::&lt;/p&gt;

&lt;p&gt;	从kill ring中粘贴子树. 该操作会自动更改被粘贴子树的级别以便它能够使用粘贴的位置. 你也可用在粘贴时就指定好级别,方法有两个,一个是在粘贴命令前加一个数字前置参数,第二种方法是在已经标示好的标题(比如&#39;****&#39;)后粘贴子树.&lt;/p&gt;

&lt;p&gt;* C-y (org-yank) ::&lt;/p&gt;

&lt;p&gt;	根据变量&#39;org-yank-adjusted-subtrees&#39;和&#39;org-yank-folded-subtrees&#39;的值,org-yank可用很智能地用与命令C-c C-x C-y一样的方式来粘贴折叠起来的子树. 在缺省的配置中,org-yank不会调整级别,并且除非会把原先可见的文本折叠起来,否则被粘贴的子树会子的那个被折叠起来. 任何前缀参数会让这个命令强制执行一个带着前缀参数的普通的yank操作. 要强制执行普通yank的一个好方法是按下C-u C-y. 如果在yank之后,你紧接着执行yank-pop命令,就会yank当前kill-ring前一个的内容,而且不会作调整和折叠动作.&lt;/p&gt;

&lt;p&gt;* C-c C-x c (org-clone-subtree-with-time-shift) ::&lt;/p&gt;

&lt;p&gt;	拷贝一堆的同级副本. 你可以一次性拷贝多个同级副本,并且你若拷贝的条目中含有时间戳信息的化,你还可以定义时间戳信息如何变化. 这项功能十分有用,例如,当你要分配任务来准备一系列的课程时. 更多细节参见命令&#39;org-clone-subtree-with-time-shift&#39;的文档字符串.&lt;/p&gt;

&lt;p&gt;* C-c C-w (org-refile) ::&lt;/p&gt;

&lt;p&gt;	转存指定条目或文本块到另一个地方.参见章节&lt;a href=&#34;#Refiling note&#34; title=&#34;转存记录&#34;&gt;转存记录&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;* C-c ^ (org-sort-entries-or-items) ::&lt;/p&gt;

&lt;p&gt;	对同级条目进行排序. 如果选择了一块文本块,所有文本块中的条目都会被排序. 否则当前标题下的子节点进行排序. 该命令会提示你选择排序的方法,可选择的方法有按字母顺序排序,按数字顺序排序,按时间排序(创建时间,规划时间,最后期限),按优先级排序,按TODO的关键字排序(需预先在配置中定义好关键字的排序顺序),按属性值排序. 你也可以采取逆排序的方式排序. 你甚至可以提供自己的函数来对其他的关键字进行排序. 如果加了C-u前缀,排序是大小写敏感的.&lt;/p&gt;

&lt;p&gt;* C-x n s (org-narrow-to-subtree) ::&lt;/p&gt;

&lt;p&gt;	缩减buffer只显示当前的子树的内容&lt;/p&gt;

&lt;p&gt;* C-x n s (org-narrow-to-block) ::&lt;/p&gt;

&lt;p&gt;缩减buffer只显示当前块的内容&lt;/p&gt;

&lt;p&gt;* C-x n w (widen) ::&lt;/p&gt;

&lt;p&gt;	回复被缩减的buffer&lt;/p&gt;

&lt;p&gt;* C-c * (org-toggle-heading) ::&lt;/p&gt;

&lt;p&gt;	该命令把正文转变为一个标题(正文在它的位置成为上一个标题的一个子标题). 也会把一个标题转变为正文. 如果选择了一个文本块,那么文本块中的所有行都变成标题. 如果该文本块中第一行是一个item(什么意思??),那么只把这个item转换为标题. 最后,如果文本块中第一行是一个i额标题,那么该文本块中所有的标题都变成正文.&lt;/p&gt;

&lt;p&gt;当对一个选定的文本块(Transient Mark mode)作升级/降级操作时,会影响到文本块中所有的标题.  要选择一个包含很多标题的文本块,最好是把point和mark都放在行首,mark放在第一个标题的行首,point放在要改变的最后哪个标题的下一行的行首. 需要注意的是,如果光标在表格内部(参见&lt;a href=&#34;#tables&#34; title=&#34;表格&#34;&gt;表格&lt;/a&gt;). Meta-光标键的操作有不同的作用.&lt;/p&gt;

&lt;h2 id=&#34;sparse树-与情景有关的匹配&#34;&gt;Sparse树&lt;/h2&gt;

&lt;p&gt;Org-mode的一个很重要的功能是它可以根据一系列的条件,将一棵大纲树中所匹配出来的一部分形成一棵sparse树,也就是说,整个文档都会尽可能的折叠起来,唯独所匹配的信息和上级标题是可见的[fn:9]. 你只要尝试以下,就立刻能够明白它是怎么工作的.&lt;/p&gt;

&lt;p&gt;Org-mode有很多命令可以创建Sparse树,所有这些命令都可以通过dispatcher来触发.&lt;/p&gt;

&lt;p&gt;* C-c / (org-sparse-tree) ::&lt;/p&gt;

&lt;p&gt;它会提示你输入一个额外的快捷键来选择特定的sparse树的创建命令&lt;/p&gt;

&lt;p&gt;* C-r / r (org-occur) ::&lt;/p&gt;

&lt;p&gt;	提示输入一个正则表达式,然后显示所有匹配的sparse树. 如果有标题匹配,那么只有这个标题可见. 如果是正文匹配,那么标题和正文同时可见. 为了提供最低限度的上下文信息,所有上层标题和紧跟者匹配部分的标题都会被显示. 每个匹配的部分都被高亮; 若这是你对文档进行编辑动作,则高亮会消失[fn:10]. 同样你也可以通过C-c C-c来取消高亮. 如果执行C-u C-c / r则以前匹配的高亮会被高持,这样多次调用这个命令的结果就被保存了下来.&lt;/p&gt;

&lt;p&gt;* M-g n 或者 M-g M-n (next-error) ::&lt;/p&gt;

&lt;p&gt;	跳到当前buffer中匹配的下一个sparse树&lt;/p&gt;

&lt;p&gt;* M-g p 或者 M-g M-p (previous-error) ::&lt;/p&gt;

&lt;p&gt;	跳到当前buffer中匹配的上一个sparse树&lt;/p&gt;

&lt;p&gt;对于那些常用的sparse树查询,你可以在变量&#39;org-agenda-custom-commands&#39;中定义快捷键,直接执行这些sparse树查询. 然后就可以在agenda dispatcher中使用这些快捷键来快速查询了.例如&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC emacs-lisp&lt;/p&gt;

&lt;p&gt;(setq org-agenda-custom-commands&lt;/p&gt;

&lt;p&gt;&#39;((&#34;f&#34; occur-tree &#34;FIXME&#34;)))&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;会定义一个键序列为&#39;C-c a f&#39;的快捷方式,这个快捷方式会通过匹配字符串&#39;FIXME&#39;来创建sparse树.&lt;/p&gt;

&lt;p&gt;其他的sparse树命令(例如通过TODO关键字,标签或者属性来查找)会在手册后一点的位置提到.&lt;/p&gt;

&lt;p&gt;要打印出sparse树,你可以使用emacs命令&#39;ps-print-buffer-with-faces&#39;,这个命令不会把不可见部分给打印出来[fn:11]. 或者你可以用命令&#39;C-c C-e v&#39;把可视化的部分导出到文档中,然后打印导出文档.&lt;/p&gt;

&lt;h2 id=&#34;纯文本列表-条目中的附加结构&#34;&gt;纯文本列表&lt;/h2&gt;

&lt;p&gt;在大纲树的正文内容中,手工排列好的列表被认为是带有一定结构的. Org提供了一种方式来创建带复选框的列表(参见&lt;a href=&#34;#Checkboxes&#34; title=&#34;复选框&#34;&gt;复选框&lt;/a&gt;),它提供工具来编辑这种列表,并且在导出时(参见章节&lt;a href=&#34;Exporting&#34; title=&#34;导出&#34;&gt;导出&lt;/a&gt;)能够解析并且格式化这些列表.&lt;/p&gt;

&lt;p&gt;Org支持有序列表,无序列表和描述列表&lt;/p&gt;

&lt;p&gt;* 无序列表,以&#39;-&#39;,&#39;+&#39;或者&#39;*&#39;[fn:12]开头&lt;/p&gt;

&lt;p&gt;* 有序列表以数字开头,后接句号或者右括[fn:13](像这样&#39;1.&#39;,&#39;1)&#39;)[fn:14]. 如果你想让列表以其他值作为初始值开始计数,需要以类似[@20]这样的文本开头[fn:15]. 这样的用法可以用在列表的任何一项上(而不需要仅仅是第一项),以强制从指定数字顺序开始.&lt;/p&gt;

&lt;p&gt;* 描述列表是一种无序列表,它包含&#39;::&#39;作为分隔符来分割术语和描述.&lt;/p&gt;

&lt;p&gt;同一个列表中的列表项必须有相同的缩进. 尤其当一个有序列表的计数达到了&#39;10&#39;的时候,那么这两位的计数必须与列表中的其他计数左对齐. (一个列表项可以是多行的.)当一个列表项的下一行的缩进与该列表项本身的缩进相等甚至跟少时,才表示该列表项结束了.&lt;/p&gt;

&lt;p&gt;当所有的列表项结束时,一个列表才被认为是结束了的,这意味在有一行的缩进等于或者小于列表第一项的缩进前,该列表都没有结束. 当然,你也可以用两个空白行[fn:16]来强制结束列表. 这种情况下,所有的列表项都被关闭了.下面是一个例子.&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC emacs-lisp&lt;/p&gt;

&lt;p&gt;,** Lord of the Rings&lt;/p&gt;

&lt;p&gt;My favorite scenes are (in this order)&lt;/p&gt;

&lt;p&gt;He makes a really funny face when it happens.&lt;/p&gt;

&lt;p&gt;But in the end, no individual scenes matter but the film as a whole.&lt;/p&gt;

&lt;p&gt;Important actors in this film are:&lt;/p&gt;

&lt;p&gt;him very well from his role as Mikey Walsh in The Goonies.&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The attack of the Rohirrim&lt;/li&gt;
&lt;li&gt;Eowyn&#39;s fight with the witch king&lt;/li&gt;
&lt;li&gt;this was already my favorite scene in the book&lt;/li&gt;
&lt;li&gt;I really like Miranda Otto.&lt;/li&gt;
&lt;li&gt;Peter Jackson being shot by Legolas&lt;/li&gt;
&lt;li&gt;on DVD only&lt;/li&gt;
&lt;dt&gt;Elijah Wood&lt;/dt&gt;
&lt;dd&gt;He plays Frodo&lt;/dd&gt;
&lt;dt&gt;Sean Austin&lt;/dt&gt;
&lt;dd&gt;He plays Sam, Frodo&#39;s friend.  I still remember&lt;/dd&gt;
&lt;/ol&gt;

&lt;p&gt;Org能正确地对这些列表进行filling和warpping调整[fn:17], 而且能够以一种恰当的方式导出这些列表(参见&lt;a href=&#34;#Exporting&#34; title=&#34;导出&#34;&gt;导出&lt;/a&gt;). 由于缩进决定了这些列表的结构,许多像#+BEGIN_...这样的block可以通过缩进来表明它们是属于哪一个列表项的一部分的.&lt;/p&gt;

&lt;p&gt;如果你觉得为子列表使用不同的标示(而不使用当前列表项的标示)可以增加可读性,你可以自定义变量&#39;org-list-demote-modify-bullet&#39;. 如果你想改变缩进程度,自定义变量&#39;org-list-indent-offset&#39;&lt;/p&gt;

&lt;p&gt;当光标处于某列表项的第一行(即带有列表项标示的那一行),可以用下面这些命令来对列表项进行操作. 其中有些命令暗含某些规则来保证列表结构是正确的. 如果你想让这些命令妨碍了你,可以通过配置&#39;org-list-automatic-rule&#39;来禁用其中的某些命令.&lt;/p&gt;

&lt;p&gt;* &lt;TAB&gt; (org-cycle) ::&lt;/p&gt;

&lt;p&gt;列表项可以像标题一样具有折叠的功能. 正常情况下,只有当光标处在plain list item上时才能进行这种折叠操作. 欲了解更多的细节,请看变量&#39;org-cycle-include-plain-lists&#39;. 如果该变量的值为&#39;integrate&#39;. plain list items会被当成是低层次的标题看待. 而*号和数字缩进层次则决定了把它当成几级标题来看待. 列表项的等级总是要低于真正的标题, 然而列表的等级制度与标题的等级制度是完全分开的. 在一个新的还未写内容的列表项上,第一次按&lt;TAB&gt;会把它变成上一个列表项的子项.再按一次&lt;TAB&gt;会上升一个层级,并且下去直到最顶列表项的层级,再按一次则返回最原始的层级位置.&lt;/p&gt;

&lt;p&gt;* M-&lt;RET&gt; (org-insert-heading) ::&lt;/p&gt;

&lt;p&gt;	插入新列表项到当前层级. 若在前面加了前缀参数,则强制插入的是标题(参见&lt;a href=&#34;#Structure editiong&#34; title=&#34;结构编辑&#34;&gt;结构编辑&lt;/a&gt;). 如果在一个列表项的中间位置执行这条命令,这个列表项会被分为2部分,而第二部分则变成了一个新的列表项[fn:18]. 如果在列表项的内容前执行这个命令,则新列表项插入在当前列表项前.&lt;/p&gt;

&lt;p&gt;* M-S-RET ::&lt;/p&gt;

&lt;p&gt;	插入带复选框的列表项(见&lt;a href=&#34;#Checkboxes&#34; title=&#34;复选框&#34;&gt;复选框&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;* S-up 和 S-down ::&lt;/p&gt;

&lt;p&gt;	跳转到当前列表的上一个/下一个列表项上去[fn:19],不过该命令只有在&#39;org-support-shift-select&#39;被关闭的情况下才能用. 如果不是的话,你可以使用段落跳转命令代替,快捷键为C-&lt;up&gt;和C-&lt;down&gt;&lt;/p&gt;

&lt;p&gt;* M-up 或 M-down ::&lt;/p&gt;

&lt;p&gt;	向上或者向下移动列表项及其子项[fn:20](与上一个/下一个同缩进的列表项交换). 如果列表是有序列表,会自动重新计算序号.&lt;/p&gt;

&lt;p&gt;* M-S-left 和 M-S-right ::&lt;/p&gt;

&lt;p&gt;减少/增加列表项(联通其子项)的缩进. 在第一次开始改变缩进时Org就会记住缩进的范围,并且在以后的多次缩进中都以次范围为准进行缩进,即使在缩进过程中可能会形成新的继承体系也不管. 如果你想在新的继承体系上进行缩进,那么你可以移动以下光标或者其他方法来先中端命令链,重新开始新的缩进过程.&lt;/p&gt;

&lt;p&gt;作为一种特殊的情况,在列表的第一个列表项上用这个命令会移动整个列表. 你可以通过配置&#39;org-list-automatic-rules&#39;来禁止这种行为. 一个列表的总体缩进对列表后面的文本并无影响力(什么意思??)&lt;/p&gt;

&lt;p&gt;* C-c C-c ::&lt;/p&gt;

&lt;p&gt;	如果所在的列表项是带复选框的(参见&lt;a href=&#34;#Checkboxes&#34; title=&#34;复选框&#34;&gt;复选框&lt;/a&gt;),那么就会转换复选框的状态. 在任何情况下,该命令都会校验整个列表序号和缩进的一致性.&lt;/p&gt;

&lt;p&gt;* C-c - ::&lt;/p&gt;

&lt;p&gt;循环更改整个列表的列表项标志(对于无需列表:&#39;-&#39;,&#39;+&#39;,&#39;*&#39;;对于有序列表:&#39;1.&#39;,&#39;1)&#39;),更改的具体方式依据&#39;org-plain-list-ordered-item-terminator&#39;,列表的类型和列表项的位置来决定的[fn:21]. 如果加了一个数字前缀N,就会选择&#39;+,*,1.,1),-&#39;中第N个标识作为列表项的标识. 如果在调用该命令时选择了一个文本块,那么整个文本块会转换成一个列表项. 如果加了前缀参数,那么文本块中所有的行各自转换成为列表项. 如果第一行依据是一个列表项,那么文本块中所有的列表项标识都被删除. 最后,即使没有选择文本块,一个普通的文本行也会转换成列表项.&lt;/p&gt;

&lt;p&gt;* C-c * ::&lt;/p&gt;

&lt;p&gt;	把一个普通列表转换为标题(这样它就原地转换为了一个子标题). 更详细的扩展参见&lt;a href=&#34;#Structure editing&#34; title=&#34;结构编辑&#34;&gt;结构编辑&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;* C-c C-c * ::&lt;/p&gt;

&lt;p&gt;	把整个列表转换成当前标题下的子树. 带复选框的列表项(参见&lt;a href=&#34;#Checkboxes&#34; title=&#34;复选框&#34;&gt;复选框&lt;/a&gt;)会转换成TODO(复选框没被选上)或者DONE(复选框被选上)关键字.&lt;/p&gt;

&lt;p&gt;* S-left 或 S-right ::&lt;/p&gt;

&lt;p&gt;	当光标处于列表项的任意位置上时,这个命令也会起到循环转换列表项标志的作用. 具体怎么转换依赖于&#39;org-support-shift-select&#39;&lt;/p&gt;

&lt;p&gt;* C-c ^ ::&lt;/p&gt;

&lt;p&gt;	对列表进行排序. 你会被提示输入排序方法,有按数字排序,按字符排序,按时间排序或自定义方法排序.&lt;/p&gt;

&lt;h2 id=&#34;抽屉-收缩起所有的资料&#34;&gt;抽屉&lt;/h2&gt;

&lt;p&gt;有时候你想记录下一项事务的某些信息,但是这些信息在一般情况下是没必要显示出来的. 为了实现这个目的,Org mode提供了drawers功能. drawers需要在变量&#39;org-drawers&#39;[fn:22]中进行配置. Drawers看起来就像这样:&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,** This is a headline&lt;/p&gt;

&lt;p&gt;,   Still outside the drawer&lt;/p&gt;

&lt;p&gt;,   :DRAWERNAME:&lt;/p&gt;

&lt;p&gt;,   This is inside the drawer.&lt;/p&gt;

&lt;p&gt;,   :END:&lt;/p&gt;

&lt;p&gt;,   After the drawer.&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;无论如何在标题上切换可见性(参见&lt;a href=&#34;#Visibility cycling&#34; title=&#34;切换可见性&#34;&gt;切换可见性&lt;/a&gt;),drawer都是收缩为一行显示的. 要看drawer内的信息,你需要移动鼠标到drawer这一行,然后按&lt;TAB&gt;键. Org-mode使用名为&#39;PROPERTIES&#39;的drawer来存放属性(参见&lt;a href=&#34;#Properties and columns&#34; title=&#34;属性与列&#34;&gt;属性与列&lt;/a&gt;), 你也可以把状态改变记录(参见&lt;a href=&#34;Tracking TODO state changes&#34; title=&#34;跟踪TODO状态变化&#34;&gt;跟踪TODO状态变化&lt;/a&gt;)和计时时间(参见&lt;a href=&#34;#Clocking work time&#34; title=&#34;记录工作时间&#34;&gt;记录工作时间&lt;/a&gt;)存放在名为&#39;LOGBOOK&#39;的drawer中. 如果你想像状态变化信息一样把自己的一段记录也存放到名为&#39;LOGBOOK&#39;的这个drawer中,使用&lt;/p&gt;

&lt;p&gt;* C-c C-z ::&lt;/p&gt;

&lt;p&gt;添加一个带有时间戳信息的记录到名为&#39;LOGBOOK&#39;的drawer中&lt;/p&gt;

&lt;h2 id=&#34;区块-折叠的区块&#34;&gt;区块&lt;/h2&gt;

&lt;p&gt;Org-mode使用begin...end块来实现很多功能,比如引入源代码(参见&lt;a href=&#34;#Literal examples&#34; title=&#34;文学化例子&#34;&gt;文学化例子&lt;/a&gt;),记录计时信息(参见&lt;a href=&#34;#Clocking work time&#34; title=&#34;记录工作时间&#34;&gt;记录工作时间&lt;/a&gt;). 在这些区块的第一行上按TAB键可以折叠/扩展该区块. 你也可以在设置在启动时自动折叠所有的块,方法是配置变量&#39;org-hide-block-startup&#39;或者在每个文件加上&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+STARTUP: hideblocks&lt;/p&gt;

&lt;p&gt;,#+STARTUP: nohideblocks&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;h2 id=&#34;注脚-如何用org标签定义注脚&#34;&gt;注脚&lt;/h2&gt;

&lt;p&gt;Org-mode支持创建注脚. 与&#39;footnote.el&#39;包相反,Org-mode中的注脚功能是专门设计在大型文档来使用的,而不仅仅是用在类型email这样的一次性文件上的. org-mode中注脚的基本语法类似于&#39;footnote.el&#39;中的语法,即,要在段落中定义一个注脚,它需要顶格(不能有缩进)以方括号作为注脚的标记. 如果你需要在注脚内分段,使用LaTeX语法&#39;\par&#39;. 要定义注脚引用,只需要简单的在文本中用方括号做一个标记. 例如&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,The Org homepage[fn:1] now looks a lot better than it used to.&lt;/p&gt;

&lt;p&gt;,...&lt;/p&gt;

&lt;p&gt;,[fn:1] The link is: http://orgmode.org&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;Org-mode会把&#39;footnote.el&#39;中基于数字的语法扩展为可以为注脚命名并且可以选择给注脚提供内部定义. 使用纯数字作为注脚标注(footnote.el就是这样作的)是为了提供向后兼容性,但是这种方式不鼓励使用,因为这种方式可能会与LaTeX snippets(参见&lt;a href=&#34;#Embedded LaTeX&#34; title=&#34;内嵌LaTeX&#34;&gt;内嵌LaTeX&lt;/a&gt;)冲突. 下面列举几种有效的注脚引用:&lt;/p&gt;

&lt;p&gt;* [ 1 ] ::&lt;/p&gt;

&lt;p&gt;一个纯数字的注脚标记. 与&#39;footnote.el&#39;兼容,但是不推荐使用,因为像&#39;[ 1 ]&#39;这样的东西,很可能是code snippet的一部分.&lt;/p&gt;

&lt;p&gt;* [ fn:name ] ::&lt;/p&gt;

&lt;p&gt;	一个带有名字的注脚引用,这里name是一个唯一的标签.如果是自动创建的注脚引用的化,则会是一个数字.&lt;/p&gt;

&lt;p&gt;* [ fn:: This is the inline definitiion of this footnote ] ::&lt;/p&gt;

&lt;p&gt;	这是一个类似LaTeX的匿名注脚,其中注脚的定义直接放在引用的位置.&lt;/p&gt;

&lt;p&gt;* [ fn:name:a definition ] ::&lt;/p&gt;

&lt;p&gt;这是一个带有名字的自定义的注脚. 由于Org-mode允许从多处引用到同一个说明,你可以使用[ fn:name ]来创建更多的引用.&lt;/p&gt;

&lt;p&gt;注脚标记可以被自动创建,你也可以自定义标记自动创建时的名字. 这是由变量&#39;org-footnote-auto-label&#39;变量和变量相应的&#39;#+STARTUP&#39;关键字来决定的. 欲了解详情请查看该变量的文档字符串.&lt;/p&gt;

&lt;p&gt;下面这些都是操作注脚的命令&lt;/p&gt;

&lt;p&gt;* C-c C-x f ::&lt;/p&gt;

&lt;p&gt;注脚行为命令&lt;/p&gt;

&lt;p&gt;当光标位于注脚引用处,该命令会跳转到注脚定义处. 若光标处于注脚定义处,跳转到(第一个)引用处.&lt;/p&gt;

&lt;p&gt;否则,创建一个新的注脚. 根据变量&#39;org-footnote-define-inline[fn:23]&#39;的不同,该注脚的定义可能是作为引用的一部分,会放在文本中, 也可能放在另外的其他位置,这个位置由变量&#39;org-footnote-section&#39;决定.&lt;/p&gt;

&lt;p&gt;当使用带前置参数的方式调用该命令, 会显示出一个附加选项菜单供你选择:&lt;/p&gt;

&lt;p&gt;#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;s   以引用顺序为依据对注脚的定义进行排序. 在编辑过程中,Org不会对注脚的定义进行排序操作. 如果你向对这些注脚的定义进行排序,使用这个命令,在对注脚定义进行排序的同时,也会根据&#39;org-footnote-section&#39;来移动整个条目. 用户可以通过配置变量&#39;org-footnote-auto-adjust&#39;来实现在每次插入/删除一个注脚后自动对注脚定义进行重新排序.&lt;/p&gt;

&lt;p&gt;r   对类型fn:N这样的以简单数字命名的注脚进行重新编号. 可以通过配置变量&#39;org-footnote-auto-adjust&#39;来实现每次插入/删除一个标注就自动对标注进行重新编号.&lt;/p&gt;

&lt;p&gt;S   先执行r操作,然后执行s操作&lt;/p&gt;

&lt;p&gt;n   标准化所有的标准,方法为先收集所有的标注定义(包括自定义的标注定义)并移动到一个特定的区域中,然后按顺序对这些定义进行编号. 那些标注引用随后也会转换为相应的数字. 这常常是在完成一篇文档前的最后一个步骤(例如,要发送email时). 在导出文档时,exporter会自动作这一步.或者当触发类似message-send-hook时,类似的动作也会自动触发.&lt;/p&gt;

&lt;p&gt;d   删除当前位置的标注,连同所有的标注定义和标注引用&lt;/p&gt;

&lt;p&gt;#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;根据变量&#39;org-footnote-auto-adjust[fn:24]&#39;的值,可以设定每插入或删除一个注脚后,自动重编码和排序文档中的所有注脚.&lt;/p&gt;

&lt;p&gt;* C-c C-c ::&lt;/p&gt;

&lt;p&gt;	当光标位于注脚引用处时,跳转到注脚定义处. 若光标处于注脚定义处,则跳转回注脚引用处. 若在标注位置上用带前置参数的方式调用该命令,则弹出一个与C-c C-x f一样的菜单.&lt;/p&gt;

&lt;p&gt;* C-c C-o 或 鼠标左键 或鼠标右键 ::&lt;/p&gt;

&lt;p&gt;	注脚标签也是注脚定义与注脚引用相互之间的一种链接,你可以使用跳转链接的一般命令来在注脚定义/引用间相互跳转.&lt;/p&gt;

&lt;h2 id=&#34;orgstruct的minior模式-在org之外进行结构编辑&#34;&gt;Orgstruct的minior模式&lt;/h2&gt;

&lt;p&gt;如果你喜欢Org-mode编辑结构和格式化列表时的这种直接了当的感受,你可能希望在其他mode下(比如Text-mode或者mail-mode)也能使用这些命令. 这时你可以使用名为&#39;orgstruct-mode&#39;的minor mode. 使用&#39;M-x orgstruct-mode&#39;来切换mode. 如果你想在默认情况下启用&#39;orgstruct-mode&#39;,例如设置在Message-mode下默认启用该mode,可以在配置文件中添加下面中的任一句&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC emacs-lisp&lt;/p&gt;

&lt;p&gt;(add-hook &#39;message-mode-hook &#39;turn-on-orgstruct)&lt;/p&gt;

&lt;p&gt;(add-hook &#39;message-mode-hook &#39;turn-on-orgstruct++)&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;&#39;orgstruct-mode&#39;被激活后,当光标在一行(对org来说)看起来像是标题或列表项的第一行的文本行上时,大多数的结构编辑命令都可以被使用,即使在major mode原本定义的功能键跟&#39;orgstruct-mode&#39;提供的功能键有冲突时,也一样. 如果光标所在行看起来不是那种特殊的行,Orgstruct mode不会有任何作用,就跟没有开启Orgstruct mode一样. 若你使用的是&#39;orgstruct++-mode&#39;,Org也会在major mode中引入缩进和填充设置,并且会探测列表项第一行后面的列表项内容.&lt;/p&gt;

&lt;h1 id=&#34;表格&#34;&gt;表格&lt;/h1&gt;

&lt;p&gt;Org自带一个快速而且直观的表格编辑器. 借助Emacs的&#39;calc&#39;包(参见&lt;Gnu Emacs calculator manual&gt;中的&#39;Top&#39;部分)甚至可以具备类似电子表格的计算能力.&lt;/p&gt;

&lt;h2 id=&#34;内置的表格编辑器-编辑简单的表格&#34;&gt;内置的表格编辑器&lt;/h2&gt;

&lt;p&gt;Org可以很容易的使用纯文本来格式化表格. 任何以&#39;|&#39;为非空白字符开头的行都被认为是表格的一部分. &#39;|&#39;也是列的分隔符[fn:25].一个表格看起来类似于这样:&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,| Name  | Phone | Age |&lt;/p&gt;

&lt;p&gt;,|-------+-------+-----|&lt;/p&gt;

&lt;p&gt;,| Peter |  1234 |  17 |&lt;/p&gt;

&lt;p&gt;,| Anna  |  4321 |  25 |&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;每次在表格内按&lt;TAB&gt;,&lt;RET&gt;或&#39;C-c C-c&#39;都会自动对表格进行重排. &lt;TAB&gt;也使光标移动到下一个域(&lt;RET&gt;使光标移动到下一行)并且会在表格的最后一行或者在水平线之前的位置上添加一行新行.表格的缩进是由第一行来决定的. 任何以&#39;|-&#39;开头的行都被认为是水平分割行,并且在下一次表格重排时会扩展到整个表格的长度. 所有要创建上面的表格,你只需要键入&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,|Name|Phone|Age|&lt;/p&gt;

&lt;p&gt;,|-&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;然后按下&lt;TAB&gt;来对齐表格并且开始在表格域内进行填充操作. 更快的操作是输入&#34;|Name|Phone|Age&#34;然后紧接着输入&#39;C-c &lt;RET&gt;&#39;.&lt;/p&gt;

&lt;p&gt;当在表格域内输入文本时,Org以一种特殊的方法来处理&lt;DEL&gt;,&lt;Backspace&gt;,和所有的字符键,这种方法保证了插入和删除操作可以避免对其他域产生影响. 另外,如果是在光标通过&lt;TAB&gt;,S-&lt;TAB&gt;或&lt;RET&gt;的方式移动到新表格域后立即输入,那么新表格域中的文本会被自动清空. 如果这种行为对你产生了困扰,可以配置变量&#39;org-enable-table-editor&#39;和&#39;org-table-auto-blank-field&#39;来取消这种行为.&lt;/p&gt;

&lt;p&gt;* 创建和转换命令&lt;/p&gt;

&lt;p&gt;* C-c | (org-table-create-or-convert-from-region) ::&lt;/p&gt;

&lt;p&gt;转换选定域为表格. 如果每个行都包含了至少一个TAB键,那么该函数假设选定域的值是以tab键作为分隔符的. 如果每一行都包含了一个逗号,那么选中域被假设为是CSV文件内容. 如果即没有TAB,也没有逗号,那么就认为选中域是以空格为分隔符的. 你可以使用前置参数来告诉函数使用哪种分隔符:C-u使用CSV格式,C-u C-u使用TAB为分隔符,前置参数N标示至少N个连续的空格或TAB键作为分隔符.&lt;/p&gt;

&lt;p&gt;如果没有选定域,这个命令会创建一个空的Org表格. 至少它比输入&#34;|Name|Phone|Age&lt;REt&gt;|-&lt;TAB&gt;&#34;这样来的简单.&lt;/p&gt;

&lt;p&gt;* 重对齐和表格域之间的移动&lt;/p&gt;

&lt;p&gt;* C-c C-c (org-table-align) ::&lt;/p&gt;

&lt;p&gt;对表格进行重对齐操作但不移动光标的位置&lt;/p&gt;

&lt;p&gt;* &lt;TAB&gt; (org-table-next-field) ::&lt;/p&gt;

&lt;p&gt;	  重对齐操作,光标移动到下一个域中. 如果需要的话创建一个新行.&lt;/p&gt;

&lt;p&gt;* S-&lt;TAB&gt; (org-table-previous-field) ::&lt;/p&gt;

&lt;p&gt;	  重对齐操作,光标移动到上一个域中.&lt;/p&gt;

&lt;p&gt;* &lt;ERT&gt; (org-table-next-row) ::&lt;/p&gt;

&lt;p&gt;	  重对齐表格,并且光标移到下一行. 如果需要的话会新键一行. 若光标在一行的开头或末尾,&lt;ERT&gt;也会新建一行,因此该功能可以用来分割表格.&lt;/p&gt;

&lt;p&gt;* M-a (org-table-beginning-of-field) ::&lt;/p&gt;

&lt;p&gt;	  移动到光标当前域的开头位置,或者(若已经在当前域的开头位置)上一个域的开头位置&lt;/p&gt;

&lt;p&gt;* M-e (org-table-end-of-field) ::&lt;/p&gt;

&lt;p&gt;	  移动到光标当前域的结尾位置,或者(若已经在当前域的结尾位置)下一个域的结尾位置&lt;/p&gt;

&lt;p&gt;* 列和行的编辑&lt;/p&gt;

&lt;p&gt;* M-&lt;left&gt; (org-table-move-column-left) ::&lt;/p&gt;

&lt;p&gt;移动当前列到左方(与左列交换位置)&lt;/p&gt;

&lt;p&gt;* M-&lt;right&gt; (org-table-move-column-right) ::&lt;/p&gt;

&lt;p&gt;移动当前列到右方(与右列交换位置)&lt;/p&gt;

&lt;p&gt;* M-&lt;up&gt; (org-table-move-row-up) ::&lt;/p&gt;

&lt;p&gt;	  移动当前行到上方(与上行交换位置)&lt;/p&gt;

&lt;p&gt;* M-&lt;down&gt; (org-table-move-row-down) ::&lt;/p&gt;

&lt;p&gt;	  移动当前行到下方(与下行交换位置)&lt;/p&gt;

&lt;p&gt;* M-S-&lt;up&gt; (org-table-kill-row) ::&lt;/p&gt;

&lt;p&gt;	  删除当前行或水平分隔行&lt;/p&gt;

&lt;p&gt;* M-S-&lt;down&gt; (org-table-insert-row) ::&lt;/p&gt;

&lt;p&gt;	  在当前行上面插入一新行. 如果加上前置参数,就在当前行下方插入新行.&lt;/p&gt;

&lt;p&gt;* C-c - (org-table-insert-hline) ::&lt;/p&gt;

&lt;p&gt;	  在当前行下面插入一新水平分隔行. 如果加上前置参数,就在当前行上方插入新水平分隔行.&lt;/p&gt;

&lt;p&gt;* C-c &lt;RET&gt; (org-table-hline-and-move) ::&lt;/p&gt;

&lt;p&gt;	  在当前行下方插入一水平分隔行,并且移动光标到该分隔行的下一行&lt;/p&gt;

&lt;p&gt;* C-c ^ (org-table-sort-lines) ::&lt;/p&gt;

&lt;p&gt;	  对当前块的表格行进行重新排序. 光标的位置指明根据哪一列来排序, 排序的范围就是上下两个最近的水平分隔行之间所包含的行,或者是整个表格. 如果光标处于第一列的前面,你会被提示需要输入按照哪一列来进行排序. 如果存在一个被选定的块,那么文本块的标记位置就指定了要排序的起始行,并且根据标记所在的列来进行排序,而光标所在的列(包括该列)为要排序的结束行. 该命令会提示您输入排序的类型(按字母排序,按数字排序或这按时间排序). 当该命令带有前置参数的时候,按字母排序是大小写敏感的.&lt;/p&gt;

&lt;p&gt;* 区域&lt;/p&gt;

&lt;p&gt;* C-c C-x M-w (org-table-copy-region) ::&lt;/p&gt;

&lt;p&gt;从表格中拷贝一个矩形区域到粘贴板. 光标所在的位置和标记的位置决定了矩阵的边界. 如果没有选定的区域,就把整个当前域拷贝到粘贴板中. 该操作会忽略水平分隔行.&lt;/p&gt;

&lt;p&gt;* C-c C-x C-w (org-table-cut-region) ::&lt;/p&gt;

&lt;p&gt;	  拷贝表格中的矩形区域的内容到剪贴板,并且对该矩形其余进行填空操作.因此这其实是个剪切操作&lt;/p&gt;

&lt;p&gt;* C-c C-x C-y (org-table-paste-rectangle) ::&lt;/p&gt;

&lt;p&gt;	  粘贴矩形区域内容到表格中. 该区域的左上角放置在当前域. 所有涉及到的域都会被覆盖掉. 如果矩阵不能合适地放到当前表格中,那么当前表会根据需要扩大. 该操作会忽略水平分隔行的存在.&lt;/p&gt;

&lt;p&gt;* M-&lt;RET&gt; (org-table-wrap-region) ::&lt;/p&gt;

&lt;p&gt;	  以光标位置为界限分割当前域,并且把剩下的部分移动到下一行. 如果存在已选定的文本块,并且光标和标记处于同一个列中,the text in the column is wrapped to minimum width for the given number of lines. 如果存在一个数字的前置参数,那么该参数会用来指定操作的行数. 如果没有选定的区域,而你又指定了前置参数,当前域会被清空,并且原先的内容会粘贴在当前域的上个域的内容后面.&lt;/p&gt;

&lt;p&gt;* 计算&lt;/p&gt;

&lt;p&gt;* C-c + (org-table-sum) ::&lt;/p&gt;

&lt;p&gt;把当前列(或选定区域)的数字求总和.求和的结果会在echo区域显示,并且可以用C-y命令插入结果&lt;/p&gt;

&lt;p&gt;* S-&lt;RET&gt; (org-table-copy-down) ::&lt;/p&gt;

&lt;p&gt;若当前域是空的,就会拷贝上方的第一个非空域的值. 如果当前域不是空的,则拷贝当前域的值覆盖下一行的值,并且鼠标也跟着下移. 根据变量&#39;org-table-copy-increment&#39;的设置,若域中的值是整数,则拷贝时会自增. 若域中的整数值太过巨大了,则该值不会被增加. 另外,若前置参数为0,则会暂时地禁止这种增加行为. 该键序列在shift-selection和相关模式中也有定义,因此可能会有冲突(参见&lt;a href=&#34;#Packages that lead to conflicts with org mode&#34; title=&#34;与org-mode冲突的包&#34;&gt;与org-mode冲突的包&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;* 杂项&lt;/p&gt;

&lt;p&gt;* C-c ` (org-table-edit-field) ::&lt;/p&gt;

&lt;p&gt;在另一个窗口中编辑当前域. 这在编辑显示不下内容的域时非常有用(参见&lt;a href=&#34;#Column width and alignment&#34; title=&#34;列宽度与对齐&#34;&gt;列宽度与对齐&lt;/a&gt;). 当添加了C-u前缀时,仅仅只是把当前域的内容全部显示出来,这样就能在本地编辑该域了. 如果加了两个C-u前缀则会保持一个编辑窗口,该窗口的内容随着光标的所在域不同而动态改变. 这种模式会一直持续到光标离开表格,或者你重复输入该命令&#39;C-u C-u C-c `&#39;&lt;/p&gt;

&lt;p&gt;* M-x org-table-import ::&lt;/p&gt;

&lt;p&gt;	  把一个文件当作表格导入进来. 文件内容必须是以TAB或空格分隔的(通常从电子表格或数据库中导出的数据是可以定义为以TAB分隔的文本文件的). 该命令先插入文件内容到缓冲区内然后调用转换命令(org-table-create-or-convert-from-region)将内容为一个表格. 任何前缀参数都会被传递给转换命令作为决定分隔符的参数.&lt;/p&gt;

&lt;p&gt;* C-c | (org-table-create-or-convert-from-region) ::&lt;/p&gt;

&lt;p&gt;	  也可以通过粘贴以tab分隔的文本到Org缓冲区的方式来导入表格.方法是,先用C-x C-x选择(也可以用其他方法)要粘贴的文本,然后使用&#39;C-c |&#39;命令&lt;/p&gt;

&lt;p&gt;* M-x org-tableexport ::&lt;/p&gt;

&lt;p&gt;	  导出表格,默认是以TAB作为分隔符. 常常用来与电子表格或数据库程序作数据交换. 导出文件的格式可以在变量&#39;org-table-export-default-format&#39;中配置. 你也可以在子树中用属性&#39;TABLE_EXPORT_FILE&#39;来定义导出文件的名字和属性&#39;TABLE_EXPORt_FORMAT&#39;来定义导出文件的格式. Org支持将表格导出为许多格式. 导出的格式与Orgtbl radio表格的格式是一样的. 详细描述请参见&#39;&lt;a href=&#34;#Translator functions&#34; title=&#34;转换功能&#34;&gt;转换功能&lt;/a&gt;&#39;.&lt;/p&gt;

&lt;p&gt;如果你不喜欢Org的表格功能(因为你可能象要有记录一些以|开头的行,而不作为表格),你可以用下面的配置语句关掉该功能&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC emacs-lisp&lt;/p&gt;

&lt;p&gt;(setq org-enable-table-editor nil)&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;这样一来,唯一可用的表格命令就是C-c C-c,该命令用来作人工的重对齐&lt;/p&gt;

&lt;h2 id=&#34;列的宽度与对齐-不使用自动化的设置&#34;&gt;列的宽度与对齐&lt;/h2&gt;

&lt;p&gt;列的宽度是有表格编辑器自动决定的. 列的对齐方式也是由列中的值的类型来自动决定的,若值类似于数字则默认右对齐,否则默认为左对齐.&lt;/p&gt;

&lt;p&gt;有时候,一个或多个域会由于包含了太多的文本而导致列的宽度看起来很不方便. 又或者你想象让多个列不管内容多少都保持固定的宽度. 要设置[fn:26]列的宽度, 在列的任何一个域中包含类似&#39;&lt;N&gt;&#39;这样的字符串即可. 这里N的意思代表了该列的宽度限定为N个字符长度. 下一次重排时,该列的宽度会调整为这个值.例如&lt;/p&gt;

&lt;p&gt;#+begin_example&lt;/p&gt;

&lt;p&gt;|---+------------------------------|               |---+--------|&lt;/p&gt;

&lt;p&gt;|   |                              |               |   | &lt;6&gt;    |&lt;/p&gt;

&lt;p&gt;| 1 | one                          |               | 1 | one    |&lt;/p&gt;

&lt;p&gt;| 2 | two                          |     ----\     | 2 | two    |&lt;/p&gt;

&lt;p&gt;| 3 | This is a long chunk of text |     ----/     | 3 | This=&gt; |&lt;/p&gt;

&lt;p&gt;| 4 | four                         |               | 4 | four   |&lt;/p&gt;

&lt;p&gt;|---+------------------------------|               |---+--------|&lt;/p&gt;

&lt;p&gt;#+end_example&lt;/p&gt;

&lt;p&gt;太长的域会被裁减并且以字符串&#39;=&gt;&#39;结尾. 注意,此时完成的字符串还保留在缓冲区内,只不过被隐藏起来罢了. 要查看完整的文本,只需要把鼠标移到要查看的域上过一会儿,会有一个小提示窗口弹出来,里面有完整的内容. 要编辑这个域,使用命令C-c `(C-c 接着反引号). 该编辑命令会打开一个新窗口给你编辑,里面是完整的内容.输入C-c C-c完成编辑&lt;/p&gt;

&lt;p&gt;打开一个文件时,若文件中存在缩小的列的表格,此时列中的文本不会自动进行隐藏动作.这时候的表格看起来不太好看,需要重排. 设置选项&#39;org-startup-align-all-tables&#39;会使org在打开文件时自动重排其中的所有表格,当然这个动作也会降低org启动的速度. 你也可以在每个文件中设置这个属性,方法为:&lt;/p&gt;

&lt;p&gt;#+begin_src org&lt;/p&gt;

&lt;p&gt;,#+STARTUP: align&lt;/p&gt;

&lt;p&gt;,#+STARTUP: noalign&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;

&lt;p&gt;默认清空下富含数字的列是右对齐的,富含字符串的列是左对齐的,但你也可以自定义列的对齐方式,方法为在列中使用类似&#39;&lt;r&gt;&#39;,&#39;c&#39;[fn:27],或&#39;&lt;l&gt;&#39;这样的字符串来定义该列的对齐方式. 当然你也可以同时定义列对齐方式和列的宽度,例如&#39;&lt;r10&gt;&#39;.&lt;/p&gt;

&lt;p&gt;当导出文档时,只包含指定格式的字符串的行会自动移除不被导出.&lt;/p&gt;

&lt;h2 id=&#34;对列进行分组-grouping-to-trigger-vertical-lines&#34;&gt;对列进行分组&lt;/h2&gt;

&lt;p&gt;当Org导出表格时,默认是不导出表格中的竖线的,因为通常来说这不美观. 然而有时候竖线可用用来把表格划分为几个列的组(类似于水平分隔行把行划分为几个组别). 要定义列的组别,你可以使用一种特殊的行,在这一行里,第一个域只包含&#39;/&#39;. 接下来的域中可用包含&#39;&lt;&#39;(表格这一列是一个组别的起始列),或者&#39;&gt;&#39;(指示这一列是组别的结束列),或者&#39;&lt;&gt;&#39;(&#39;&lt;&#39;和&#39;&gt;&#39;中间没有空格,这表示这一列自成一组). 组别之间的边界在导出时会用竖线标示出来.如下例子所示&lt;/p&gt;

&lt;p&gt;#+begin_src org&lt;/p&gt;

&lt;p&gt;,| N | N^2 | N^3 | N^4 | sqrt(n) | sqrt[4](N) |&lt;/p&gt;

&lt;p&gt;,|---+-----+-----+-----+---------+------------|&lt;/p&gt;

&lt;p&gt;,| / |   &lt; |     |   &gt; |       &lt; |          &gt; |&lt;/p&gt;

&lt;p&gt;,| 1 |   1 |   1 |   1 |       1 |          1 |&lt;/p&gt;

&lt;p&gt;,| 2 |   4 |   8 |  16 |  1.4142 |     1.1892 |&lt;/p&gt;

&lt;p&gt;,| 3 |   9 |  27 |  81 |  1.7321 |     1.3161 |&lt;/p&gt;

&lt;p&gt;,|---+-----+-----+-----+---------+------------|&lt;/p&gt;

&lt;p&gt;,#+TBLFM: $2=$1^2::$3=$1^3::$4=$1^4::$5=sqrt($1)::$6=sqrt(sqrt(($1)))&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;

&lt;p&gt;你也可以只是在想要竖线的地方插入列组的起始符号即可.例如&lt;/p&gt;

&lt;p&gt;#+begin_src org&lt;/p&gt;

&lt;p&gt;,|  N | N^2 | N^3 | N^4 | sqrt(n) | sqrt[4](N) |&lt;/p&gt;

&lt;p&gt;,|----+-----+-----+-----+---------+------------|&lt;/p&gt;

&lt;p&gt;,| /  | &lt;   |     |     | &lt;       |            |&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;

&lt;h2 id=&#34;名为orgtbl的minor-mode-使用minor-mode中的表格编辑器&#34;&gt;名为Orgtbl的minor mode&lt;/h2&gt;

&lt;p&gt;如果你喜欢Org表格编辑器的直观操作，你也可以在别的mode(例如text-mode或mail-mode)中使用它. 名为&#39;Orgtbl-mode&#39;的minor mode可以实现这一点. 你可以通过&#39;M-x orgtbl-mode&#39;来切换该模式. 如果你想在进入特定mode(例如Message mode)时自动进入该minor mode,使用如下的配置语句&lt;/p&gt;

&lt;p&gt;#+begin_src emacs-lisp&lt;/p&gt;

&lt;p&gt;(add-hook &#39;message-mode-hook &#39;turn-on-orgtbl)&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;

&lt;p&gt;此外,通过一些配置,还可以用Orgtbl-mode实现在任意标签内包含表格. 例如,它可以实现在构建LaTeX表格时兼顾LaTeX的易用和Orgtbl-mode的能力(包含了电子表格的能力). 详细请见&lt;a href=&#34;#Tables and lists in arbitrary syntax&#34; title=&#34;任意标签中的表格和列表&#34;&gt;任意标签中的表格和列表&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;电子表格-带有电子表格功能的表格编辑器&#34;&gt;电子表格&lt;/h2&gt;

&lt;p&gt;表格编辑器使用Emacs的&#39;calc&#39;包来实现类似电子表格的功能. 它也可以根据Emacs Lisp表达式来根据其他域中的值计算得出当前域的值. 虽然功能上类似,但是严格来说,Org的实现方式与其他电子表格的实现方式是不一样的. 例如, Org能够理解column formula(列公式)的概念，列公式会自动应用到当前列的每一个非最开头的域中，而不用在每一个域中都复制一份公式(formula). Org还提供了一个formula调试器和一个formula编辑器, 该formula编辑器会高亮公式中所引用到的域,并且可以通过方向键来移动该引用.&lt;/p&gt;

&lt;h3 id=&#34;引用-如何引用其他域或区域&#34;&gt;引用&lt;/h3&gt;

&lt;p&gt;要根据其他域的值来计算表格中的值,公式必须引用到其他域或区间. 域可用通过名称,通过绝对坐标和相对坐标用这三种方式来引用. 要确定某个域的坐标是什么,在这个域中按下&#39;C-c ?&#39;就会在echo区域显示出该域的坐标,也可以按下&#39;C-c }&#39;来切换显示坐标网格.&lt;/p&gt;

&lt;p&gt;* 域引用&lt;/p&gt;

&lt;p&gt;在公式中有两种方法来引用其他域中的值. 第一种类似于其他电子表格,你可以用一个字母/数字组合起来表示一个域的引用,例如&#39;B3&#39;的意思是第3行的第2个域. 然而,Org更推荐[fn:28]使用另一种更加通用的表示方法,这种表示方法看起来是这样的:&lt;/p&gt;

&lt;p&gt;#+begin_example&lt;/p&gt;

&lt;p&gt;@row$column&lt;/p&gt;

&lt;p&gt;#+end_example&lt;/p&gt;

&lt;p&gt;列的可以用绝对坐标表示,类似于这样:$1,$2...$N.也可以用相对坐标表示(当前列为基准值)类似于这样:$+1,$-2,$&lt;,$&gt;.其中$&lt;固定表示第一列,$&gt;固定表示最后一列. 另外,你可以用$&gt;&gt;&gt;表示从右往左数第3列&lt;/p&gt;

&lt;p&gt;行在计算坐标时,值计算数据行,而 &lt;strong&gt;不算水平分隔行(hline)&lt;/strong&gt; .类似于列的表示方法,你可以使用绝对行数来表示,类似于@1,@2...@N,也可以用相对行数来表示,类似于@+3,@-1,@&lt;和@&gt;. 其中@&lt;固定表示表格中的第一行,@&gt;固定表示表格中的最后一行[fn:29].另外你也可用通过与hline的相对位置来引用行:@I引用第一个hline,@II引用第二个hline,一次类推. @-I引用的是当前行的上一个hline,@+I是当前行的下一个hline. 你也可以通过@III+2表示第3个hline的后2行&lt;/p&gt;

&lt;p&gt;$0和$0分别引用的是当前行和当前列,也就是要被计算的域的行和列. 另外,如果你忽略了引用的行或列部分,默认情况下使用当前域的行或列代替.&lt;/p&gt;

&lt;p&gt;Org中不带符号只含数字的引用是固定引用,也就是说如果你在两个不同的域中使用同一个引用表示法,引用的是同一个域. 而org中带符号和数字的引用是浮动引用,即相同的引用表示法可能引用的是不同的域,这取决于公式所在的那个域的位置.&lt;/p&gt;

&lt;p&gt;下面是一些例子:&lt;/p&gt;

&lt;p&gt;#+begin_example&lt;/p&gt;

&lt;p&gt;@2$3      2nd row, 3rd column (same as C2)&lt;/p&gt;

&lt;p&gt;$5        column 5 in the current row (same as E&amp;)&lt;/p&gt;

&lt;p&gt;@2        current column, row 2&lt;/p&gt;

&lt;p&gt;@-1$-3    the field one row up, three columns to the left&lt;/p&gt;

&lt;p&gt;@-I$2     field just under hline above current row, column 2&lt;/p&gt;

&lt;p&gt;@&gt;$5      field in the last row, in column 5&lt;/p&gt;

&lt;p&gt;#+end_example&lt;/p&gt;

&lt;p&gt;* 区间引用&lt;/p&gt;

&lt;p&gt;你可以引用一个矩形区间,方法是指明两个域引用,并用&#39;..&#39;连接起来. 如果这两个域都处于同一个行,可用只使用&#39;$2..$7&#39;这样来代替, 但若至少有一个域处于不同的行,那么你需要对至少第一个域使用完整的@row$column格式(即引用必须以@开头,以便能够正确第解释).例如&lt;/p&gt;

&lt;p&gt;#+begin_example&lt;/p&gt;

&lt;p&gt;$1..$3        first three fields in the current row&lt;/p&gt;

&lt;p&gt;$P..$Q        range, using column names (see under Advanced)&lt;/p&gt;

&lt;p&gt;$&lt;&lt;&lt;..$&gt;&gt;     start in third column, continue to the one but last&lt;/p&gt;

&lt;p&gt;@2$1..@4$3    6 fields between these two fields (same as A2..C4)&lt;/p&gt;

&lt;p&gt;@-1$-2..@-1   3 numbers from the column to the left, 2 up to current row&lt;/p&gt;

&lt;p&gt;@I..II        between first and second hline, short for @I..@II&lt;/p&gt;

&lt;p&gt;#+end_example&lt;/p&gt;

&lt;p&gt;区间引用返回一个值的vector(向量),并传入Calc向量函数中执行. 区间中的空域正常来说都会被忽略掉,这样向量中就只包含了非空域(要切换这种行为,参见下面的&#39;E&#39; mode).如果区域中所有的域都为空域,那么就会返回&#39;[ 0 ]&#39;一次来避免公式中发生语法错误.&lt;/p&gt;

&lt;p&gt;* 公式中的域坐标&lt;/p&gt;

&lt;p&gt;若要在Calc公式使用当前域的行号和列号,可用用@#和$#来表示. 在传统的Lisp公式中等价于&#39;org-table-current-dline&#39;和&#39;org-table-current-column&#39;.例如:&lt;/p&gt;

&lt;p&gt;#+begin_example&lt;/p&gt;

&lt;p&gt;if(@# % 2, $#, string(&#34;&#34;))   column number on odd lines only&lt;/p&gt;

&lt;p&gt;$3 = remote(FOO, @@#$2)      copy column 2 from table FOO into&lt;/p&gt;

&lt;p&gt;column 3 of the current table&lt;/p&gt;

&lt;p&gt;#+end_example&lt;/p&gt;

&lt;p&gt;对于第二个例子,FOO表格至少需要有与当前表格一样多的行. 注意:这对于大量的行操作来说是很不效率的[fn:30].&lt;/p&gt;

&lt;p&gt;* 命名引用&lt;/p&gt;

&lt;p&gt;&#39;$name&#39;会被被解释成列名，参数或者常量. 可以通过变量&#39;org-table-formula-constants&#39;来定义全局常量,或者通过类似下面一行的方法来为某个文件定义本地常量.&lt;/p&gt;

&lt;p&gt;#+begin_src org&lt;/p&gt;

&lt;p&gt;,#+CONSTANTS: c=299792458. pi=3.14 eps=2.4e-6&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;

&lt;p&gt;另外,在表格公式中,也可以使用属性(参见章节&lt;a href=&#34;#Properties and columns&#34; title=&#34;属性与列&#34;&gt;属性与列&lt;/a&gt;)来作为常量使用[fn:31]:你可以通过名为&#39;$PROP_ Xyz&#39;的常量来访问属性&#39;:Xyz:&#39;,Org会在表格所在大纲条目及其上级条目中搜索该属性. 如果你加载了&#39;constants.el&#39;这个包,那么Org也会使用这个包来匹配常量,这个包甚至包括自然常量(例如$h表示普朗克常量)和单位(例如$km表示千米). 列名和参数可以在一个特殊的表格行内指定,更具体描述以后再说,可以参见&lt;a href=&#34;#Advanced features&#34; title=&#34;高级特性&#34;&gt;高级特性&lt;/a&gt;.现阶段所有的名字都必须以字母开头,以后可能可以以字母和数字开头.&lt;/p&gt;

&lt;p&gt;* 远程引用&lt;/p&gt;

&lt;p&gt;你也可以引用其他表格中的常量,域和区间, 这些表格可以在同一个文件也可以在不同文件中. 引用的方法为&lt;/p&gt;

&lt;p&gt;#+begin_src org&lt;/p&gt;

&lt;p&gt;,        remote(NAME-OR-ID,REF)&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;

&lt;p&gt;这里NAME可以是当前文件中当前表格以前所定义的表格名字. 这里表格名字可以用&#39;#+TBLANAME:表格名字&#39;来定义. NAME的值也可以是某个大纲条目的ID(甚至可以是其他文件中的大纲条目),这时引用的就是该条目中的第一个表格. REF是一个绝对域或绝对区间的引用(具体方法如上面所示,例如@3$3或者$somename,这些绝对引用需要确保在被引用表格中都是可用的).&lt;/p&gt;

&lt;h3 id=&#34;calc的公式语法-使用calc计算&#34;&gt;Calc的公式语法&lt;/h3&gt;

&lt;p&gt;一个公式可用是任何能够被Emacs的&#39;calc&#39;包所识别的代数表达式. *注意,在&#39;Calc&#39;中,&#39;/&#39;的操作符优先级要比&#39;*&#39;低,因此&#39;a/b*c&#39;会被解释为&#39;a/(b*c)&#39;,这一点与标准不符*. 在calc-eval(参见GNUEmacs Calc　Manual中&#39;Calling Calc from Your Lisp Programs&#39;章节的)进行计算之前,变量替换会以之前所描述的方式发生. 公式之中的区域变量可用直接放入Calc的向量函数(例如&#39;vmean&#39;和&#39;vsum&#39;)中作为参数使用.&lt;/p&gt;

&lt;p&gt;公式可用在分号之后附加上可选的选项模式字符串. 这种选项模式字符串由标志所组成,这些标志会在公式被执行时影响Calc和其他模式. 默认情况下,Org使用标准的Calc模式(精度为12位,角度单位为度,分数和symbolic模式为关闭状态). 然而,公式在显示时,会自动调整为(float 8)以便保持表格的紧凑. 可用通过变量&#39;org-calc-default-modes&#39;来配置这些默认设置&lt;/p&gt;

&lt;p&gt;#+begin_example&lt;/p&gt;

&lt;p&gt;p20           set the internal Calc calculation precision to 20 digits&lt;/p&gt;

&lt;p&gt;n3 s3 e2 f4   Normal, scientific, engineering, or fixed&lt;/p&gt;

&lt;p&gt;format of the result of Calc passed back to Org.&lt;/p&gt;

&lt;p&gt;Calc formatting is unlimited in precision as&lt;/p&gt;

&lt;p&gt;long as the Calc calculation precision is greater.&lt;/p&gt;

&lt;p&gt;D R           angle modes: degrees, radians&lt;/p&gt;

&lt;p&gt;F S           fraction and symbolic modes&lt;/p&gt;

&lt;p&gt;N             interpret all fields as numbers, use 0 for non-numbers&lt;/p&gt;

&lt;p&gt;E             keep empty fields in ranges&lt;/p&gt;

&lt;p&gt;L             literal&lt;/p&gt;

&lt;p&gt;#+end_example&lt;/p&gt;

&lt;p&gt;除非你使用大整数或高精度计算式,并且需要显示浮点式数字,你可以提供一个printf格式说明字符串[fn:32]来对Calc计算并传回Org的结果进行重新格式化,而不是Calc自己作这种格式化. 下面是一些例子&lt;/p&gt;

&lt;p&gt;#+begin_example&lt;/p&gt;

&lt;p&gt;$1+$2                Sum of first and second field&lt;/p&gt;

&lt;p&gt;$1+$2;%.2f           Same, format result to two decimals&lt;/p&gt;

&lt;p&gt;exp($2)+exp($1)      Math functions can be used&lt;/p&gt;

&lt;p&gt;$0;%.1f              Reformat current cell to 1 decimal&lt;/p&gt;

&lt;p&gt;($3-32)*5/9          Degrees F -&gt; C conversion&lt;/p&gt;

&lt;p&gt;$c/$1/$cm            Hz -&gt; cm conversion, using ‘constants.el’&lt;/p&gt;

&lt;p&gt;tan($1);Dp3s1        Compute in degrees, precision 3, display SCI 1&lt;/p&gt;

&lt;p&gt;sin($1);Dp3%.1e      Same, but use printf specifier for display&lt;/p&gt;

&lt;p&gt;vmean($2..$7)        Compute column range mean, using vector function&lt;/p&gt;

&lt;p&gt;vmean($2..$7);EN     Same, but treat empty fields as 0&lt;/p&gt;

&lt;p&gt;taylor($3,x=7,2)     Taylor series of $3, at x=7, second degree&lt;/p&gt;

&lt;p&gt;#+end_example&lt;/p&gt;

&lt;p&gt;Calc还包含了一个完整的逻辑操作集合. 例如&lt;/p&gt;

&lt;p&gt;#+begin_example&lt;/p&gt;

&lt;p&gt;if($1&lt;20,teen,string(&#34;&#34;))            如果第一列(age列)比20小,则返回值&#34;teen&#34;,否则返回空值&lt;/p&gt;

&lt;p&gt;#+end_example&lt;/p&gt;

&lt;p&gt;注意,在计算时长时,还可以使用两个特定的标志T和t,具体参见&lt;a href=&#34;#Durations and time values&#34; title=&#34;时长与时间&#34;&gt;时长与时间&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;emacs-lisp写成的公式-使用emacs-lisp来写公式&#34;&gt;Emacs Lisp写成的公式&lt;/h3&gt;

&lt;p&gt;你可以使用Emacs Lisp来写公式;这在当Calc提供的函数不足与实现我们期望的操纵字符串和控制结构的功能时非常有用. 如果一个公式是以单引号后跟一个开括号开头的,则该公式被认为是Lisp形式的. 该Lisp的运算结果应该是返回一个字符串或者是数字的. 就像使用&#39;calc&#39;公式一样,你可以在分号&#39;;&#39;后面指定模式和printf格式. 使用Emacs Lisp形式,你需要关注域引用插入到form中的方式. 默认情况下,一个引用是将域中的值以字符串的形式(包括在双引号内)插入的. 如果开启了M模式,则所有的被引用元素都会被转化为数字(非数字域转化为0)并且在插入时作为Lisp数字型插入(不包含引号). 如果你提供了&#39;L&#39;标志,所有的域将会以字面上的方式(不包含引号)插入公式中. 也就是说,如果你想一个引用作为字符串来插入到Lisp形式的公式中,则使用双引号来包含引用表达式(例如&#34;$3&#34;)即可. 区域在插入时会作为一系列以空格分隔的域,这样你就可以把它们潜入list或vector符号中. 下面是一些例子--注意我们在用Lisp计算时是如何使用&#39;N&#39;模式的&lt;/p&gt;

&lt;p&gt;#+begin_example&lt;/p&gt;

&lt;p&gt;Swap the first two characters of the content of column 1&lt;/p&gt;

&lt;p&gt;&#39;(concat (substring $1 1 2) (substring $1 0 1) (substring $1 2))&lt;/p&gt;

&lt;p&gt;Add columns 1 and 2, equivalent to Calc&#39;s $1+$2&lt;/p&gt;

&lt;p&gt;&#39;(+ $1 $2);N&lt;/p&gt;

&lt;p&gt;Compute the sum of columns 1-4, like Calc&#39;s vsum($1..$4)&lt;/p&gt;

&lt;p&gt;&#39;(apply &#39;+ &#39;($1..$4));N&lt;/p&gt;

&lt;p&gt;#+end_example&lt;/p&gt;

&lt;h3 id=&#34;时长和时间的值-如何计算工期和时间的值&#34;&gt;时长和时间的值&lt;/h3&gt;

&lt;p&gt;如果你希望计算的是时间的值,你需要在Calc公式或Elisp公式中使用T标志&lt;/p&gt;

&lt;p&gt;#+begin_src org&lt;/p&gt;

&lt;p&gt;,  |  Task 1 |   Task 2 |    Total |&lt;/p&gt;

&lt;p&gt;,  |---------+----------+----------|&lt;/p&gt;

&lt;p&gt;,  |    2:12 |     1:47 | 03:59:00 |&lt;/p&gt;

&lt;p&gt;,  | 3:02:20 | -2:07:00 |     0.92 |&lt;/p&gt;

&lt;p&gt;,  #+TBLFM: @2$3=$1+$2;T::@3$3=$1+$2;t&lt;/p&gt;

&lt;p&gt;,&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;

&lt;p&gt;输入的时长值必须是以[HH:MM[:SS]]的形式的,这里秒数是可选的. 当使用了T标志,计算出来的时长会以HH:MM:SS的形式来显示(参见上面例子的第一个公式). 当使用t标志时,计算出来的时长的显示方式是根据变量&#39;org-table-duration-custom-format&#39;的不同而不同的, 该变量默认单位为小时并且会以小数的形式来显示结果(参见上面的第二个公式).&lt;/p&gt;

&lt;p&gt;Org也支持副的时长,而且数字在作加减法时会被认为是秒数.&lt;/p&gt;

&lt;h3 id=&#34;域公式和区间公式-给某个域或某个区间分配一个公式&#34;&gt;域公式和区间公式&lt;/h3&gt;

&lt;p&gt;要给一个域分配公式,直接输入公式,并在前面加上&#39;:=&#39;,例如&#39;:vsum(@II..III)&#39;. 当你在 &lt;strong&gt;光标还在域中时&lt;/strong&gt; 按下&lt;TAB&gt;或&lt;RET&gt;或C-c C-c,公式就会被保持在该域中,并且会自动计算并把计算结果展示为域的值.&lt;/p&gt;

&lt;p&gt;公式是统一存储在一个特殊行中的,该行是以&#34;#+TBLFM:&#34;开头的,并且直接就在表格的下方紧靠表格. 如果你在第3行的第4个域中输入公式,那么该公式就会类似于&#39;@3$4=$1+$2&#39;这样. 当使用命令插入/删除/交换了行或者列时,公式中的绝对引用(但是不包括相对引用)也会跟着改变,以保证引用还是指向与修改前同一域. 要避免这种情况发生(特别是在公式中使用了区间引用,表格的边界引用(使用@&lt;,@&gt;,$&lt;,$&gt;)或hlines引用(使用@I符号)的情况下), 你需要使用一般的编辑命令来改变表格结构.当使用一般的编辑命令来修改表结构的情况下,域引用的这种自动适配功能当然是不会发生的--这样的话,你需要自己修正公式.&lt;/p&gt;

&lt;p&gt;除了直接在域中输入公式,你也可以使用下面这些命令&lt;/p&gt;

&lt;p&gt;* C-u C-c = (org-table-eval-formula) ::&lt;/p&gt;

&lt;p&gt;为当前域分配一个新的公式. 该命令提示你输入公式(默认值为从#+TBLFM:行中获得公式),然后应用该公式到当前域并保持起来.&lt;/p&gt;

&lt;p&gt;在公式的左侧也可以是特别的表达式,以这种方法可用为一系列不同的域分配公式. 并没有快捷方式来输入这种区间公式. 要增加这种区间公式,需要使用公式编辑器(参见&lt;a href=&#34;#Editing and debugging formulas&#34; title=&#34;编辑和调试公式&#34;&gt;编辑和调试公式&lt;/a&gt;)或者直接编辑$+TBLFM:行&lt;/p&gt;

&lt;p&gt;* $N= (这里N表示第几列) ::&lt;/p&gt;

&lt;p&gt;	     列公式,对整个列生效. 这种公式如此常见以至于Org以一种特殊的方式来处理这些公式,参见&lt;a href=&#34;#Column%20formulas&#34; title=&#34;列公式&#34;&gt;列公式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;* @N= (这里N表示第几行) ::&lt;/p&gt;

&lt;p&gt;	     行公式,对一行的所有域生效. @&gt;=表示最后一行.&lt;/p&gt;

&lt;p&gt;* @1$2..@4$3= ::&lt;/p&gt;

&lt;p&gt;		    区间公式,对所指定的矩阵区间内的所有域有效. 这可以用来分配公式给行中的一些域(但不是所有的域)&lt;/p&gt;

&lt;p&gt;* $name= ::&lt;/p&gt;

&lt;p&gt;		命名域,具体参见&lt;a href=&#34;Advanced features&#34; title=&#34;高级特性&#34;&gt;高级特性&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;列公式-对整个列都生效的公式&#34;&gt;列公式&lt;/h3&gt;

&lt;p&gt;#&lt;&lt;Column formulas&gt;&gt;&lt;/p&gt;

&lt;p&gt;当你分配一个列公式到一个列时(使用类似$3=这样的语法),该列的所有域都会使用同一个公式,然而也会有一些例外:(i) 如果表格包含了水平分隔行hlines,任何在第一个水平分隔行之前的行都被认为是表头信息,因此就不会被列公式所改变. (ii) 如果一个域已经定义了域公式或区间公式,那么它也被列公式排除在外(即域公式和列公式的优先级高于列公式). 上诉的两个条件使得列公式很容易使用.&lt;/p&gt;

&lt;p&gt;要分配一个列公式给某个列,直接输入公式到该列的任何一个域中,并在前面加一个-号,就像这样&#39;=$1+$2&#39;. 当你在光标还在域的情况下按下&lt;TAB&gt;或&lt;RET&gt;或C-c C-c, 输入的公式就会作为该列的列公式而存储起来,然后经过计算,把结果在当前域(而不是当前列)中展示出来. 如果列中的某个域只包含&#39;=&#39;,那么该列中前一个存储起来的公式会被应用到该域中. 对于每个列来说,Org只会记住最近使用的那个公式. 在&#39;#+TBLFM:&#39;行,列公式看起来类似于&#39;$4=$1+$2&#39;这样. 列公式的左边不能是列的名字,它必须是数字形式的列引用或$&gt;&lt;/p&gt;

&lt;p&gt;除了输入以=开头的公式到域中,你也可以使用下面的命令来创建列公式&lt;/p&gt;

&lt;p&gt;* C－c = (org-table-eval-formula) ::&lt;/p&gt;

&lt;p&gt;为该列应用一个新的列公式,然后使用该公式的计算结果显示在当前域中. 该命令会提示你输入列公式,默认值为#+TBLFM行的公式. 输入的列公式会应用到当前域中并存储起来. 如果加上一个数字前缀(例如C-5 C-c =),该命令会应用到当前列中连续N个域中.&lt;/p&gt;

&lt;h3 id=&#34;编辑和调试公式-修正公式&#34;&gt;编辑和调试公式&lt;/h3&gt;

&lt;p&gt;你可以在minibuffer或者直接在域中编辑一个个的公式. Org也可以准备一个包含表格中所有公式的特殊缓存区. 当对公式进行编辑时,Org在可能的情况下会转换引用为标准格式(类似于B3或者D&amp;这样的引用). 如果你想只使用引用内部格式(类似于@3$2或者$4),请配置变量&#39;org-table-use-standard-references&#39;&lt;/p&gt;

&lt;p&gt;* C-c = 或者 C-u C-c = (org-table-eval-formula) ::&lt;/p&gt;

&lt;p&gt;在minibuffer中编辑当前列/域的公式. 参见&lt;a href=&#34;#Column formulas&#34; title=&#34;列公式&#34;&gt;列公式&lt;/a&gt;和&lt;a href=&#34;#Field and range formulas&#34; title=&#34;域与区间公式&#34;&gt;域与区间公式&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;* C-u C-u C-c = (org-table-eval-formula) ::&lt;/p&gt;

&lt;p&gt;	 为当前域重新设定一个公式(可以使域公式也可以是列公式),使用这个命令你可以直接在域中编辑公式. 与在minibuffer中编辑公式相比,这种方法的优势在于你可以使用命令C-c ?查询域的信息.&lt;/p&gt;

&lt;p&gt;* C-c ? (org-table-field-info) ::&lt;/p&gt;

&lt;p&gt;	 当在表格域中编辑公式时,高亮公式中鼠标所在位置的域引用所引用的域.&lt;/p&gt;

&lt;p&gt;* C-c } ::&lt;/p&gt;

&lt;p&gt;	       切换显示行列编号,using overlays(org-table-toggle-coordinate-overlays). 这些信息在每次表格重排之后都会自动更新;你也可以使用C-c C-c来强制更新信息.&lt;/p&gt;

&lt;p&gt;* C-c } ::&lt;/p&gt;

&lt;p&gt;	       切换开启或者关闭公式调试器(org-table-toggle-formula-debugger). 具体信息参见下面&lt;/p&gt;

&lt;p&gt;* C-c &#39; (org-table-edit-formulas) ::&lt;/p&gt;

&lt;p&gt;	 打开一个特殊的缓冲区(公式编辑器),可以在里面编辑当前表格所有的公式,在这个缓冲区中,每个公式都显示一行. 如果当前域包含包含有一个激活的公式,公式编辑器中的光标会标示出它来. 当光标在这个特殊的缓冲区中时,Org会自动高亮任何光标位置的域引用所引用的域. 你可以在这个特殊缓冲区中使用下面这些命令来编辑,删除和新增公式&lt;/p&gt;

&lt;p&gt;* C-c C-c 或 C-x C-s (org-table-fedit-finish) ::&lt;/p&gt;

&lt;p&gt;	   退出公式编辑器,并且保持修改后的公式. 如果加了C-u前缀,那么会对整个表格应用新修改的公式(表格中所有的公式都会被重新计算一遍,然后显示出来)&lt;/p&gt;

&lt;p&gt;* C-c C-q (org-table-fedit-abort) ::&lt;/p&gt;

&lt;p&gt;	   退出公式编辑器,而不做任何修改&lt;/p&gt;

&lt;p&gt;* C-c C-r (org-table-fedit-toggle-ref-type) ::&lt;/p&gt;

&lt;p&gt;	   对表格编辑器中的所有引用切换显示格式,在标准格式(类似于B3)和内部格式(类似于@3$2)间切换&lt;/p&gt;

&lt;p&gt;* &lt;TAB&gt; (org-table-fedit-lisp-indent) ::&lt;/p&gt;

&lt;p&gt;	   美化并缩进当前光标所在的Lisp公式. 当光标所在行包含有Lisp公式时,使用Emacs Lisp的规则来格式化公式. Another &lt;TAB&gt; collapses the formula back again. 在open formula(开放式公式??)中,&lt;TAB&gt;跟在Emacs Lisp mode一样起着重新缩进的功能.&lt;/p&gt;

&lt;p&gt;* M-&lt;TAB&gt; (lisp-complete-symbol) ::&lt;/p&gt;

&lt;p&gt;	   补完Lisp符号,就跟在Emacs Lisp mode中一样&lt;/p&gt;

&lt;p&gt;* S-&lt;up&gt;/&lt;down&gt;/&lt;left&gt;/&lt;right&gt; ::&lt;/p&gt;

&lt;p&gt;	   切换光标所在的引用. 例如如果现在光标所在的引用是B3,你按下S-&lt;right&gt;之后,该引用变成了C3. 这对相对引用和hline引用也有效&lt;/p&gt;

&lt;p&gt;* M-S-&lt;up&gt; (org-table-fedit-line-up) 或 M-S-&lt;down&gt; (org-table-fedit-line-down) ::&lt;/p&gt;

&lt;p&gt;	   上下移动Org buufer中行公式的test line&lt;/p&gt;

&lt;p&gt;* M-&lt;up&gt; (org-table-fedit-scroll-down&gt; 或 M-&lt;down&gt; (org-table-fedit-scroll-up) ::&lt;/p&gt;

&lt;p&gt;	   滚动表格所在的窗口&lt;/p&gt;

&lt;p&gt;* C-c } ::&lt;/p&gt;

&lt;p&gt;		 显示/关闭表格中各个域的坐标&lt;/p&gt;

&lt;p&gt;把一个域清空并不会删掉这个域的公式,因为公式实际上是保存在其他行(#_TBLFM行)-这样在下一次重新计算时,该域又会有新的值初出现. 要删掉一个域中的公式,你需要在编辑公式要求输入新公式时输入一个空回复,或者直接编辑#+TBLFM行&lt;/p&gt;

&lt;p&gt;你可以直接编辑&#39;#+TBLFM&#39;行,然后在该行运行C-c C-c来对改变后的公式进行重新计算.或者也可以在表格中执行普通的重计算命令.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;调试公式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当公式的计算产生错误时,域中的内容变为字符串&#39;#ERROR&#39;. 如果你想知道在变量替换和计算时都发生了什么以便寻找bug,你可以在Tbl菜单上打开公式调试功能然后重新对改公式计算一次(在域中按下C-u C-u C-c = &lt;RET&gt;).随后就会显示详细信息出来.&lt;/p&gt;

&lt;h3 id=&#34;更新表格-重新计算所有相关域&#34;&gt;更新表格&lt;/h3&gt;

&lt;p&gt;表格一般来说不会自动进行重计算,而是需要通过命令来触发. 要想使表格半自动地进行重计算,请参见&lt;a href=&#34;#Advanced features&#34; title=&#34;高级特性&#34;&gt;高级特性&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;要想对整个表格或者一整行进行重新计算,可用使用下面的命令:&lt;/p&gt;

&lt;p&gt;* C-c * (org-table-recalculate) ::&lt;/p&gt;

&lt;p&gt;重新计算当前行,计算的方法是首先从左到右对该行的每个域都计算一次列公式,然后再当前行的域公式和区间公式.&lt;/p&gt;

&lt;p&gt;* C-u C-c * 或C-u C-c C-c ::&lt;/p&gt;

&lt;p&gt;	 一行一行地重新计算整个表格. 任何在第一个hline之前的行都被认为是表头而排除在重计算操作之外&lt;/p&gt;

&lt;p&gt;* C-u C-u C-c * 或 C－u C-u C-c C-c (org-table-iterate) ::&lt;/p&gt;

&lt;p&gt;	 重复对表格进行重计算,直到没有变化可以继续产生. 如果有些域的计算结果依赖于其他域的值,而这些被依赖的域的值需要在指向了一系列的计算之后才能得到的时候,这时候这项功能就很有必要了.&lt;/p&gt;

&lt;p&gt;* M-x org-table-recalculate-buffer-tables ::&lt;/p&gt;

&lt;p&gt;	 重新计算当前缓冲区中的所有表格&lt;/p&gt;

&lt;p&gt;* M-x org-table-iterate-buffer-tables ::&lt;/p&gt;

&lt;p&gt;	 对当前缓冲区中的所有表格进行迭代计算,以便converge(汇聚??)表与表之间的依赖关系.&lt;/p&gt;

&lt;h3 id=&#34;高级特性-域和列的名字-参数和自动重计算&#34;&gt;高级特性&lt;/h3&gt;

&lt;p&gt;#&lt;&lt;Advanced features&gt;&gt;&lt;/p&gt;

&lt;p&gt;如果你想自动重计算域的值,或者你向为域和列分配名字[fn:33],你需要保留表格的第一列作存放特殊的标志字符.&lt;/p&gt;

&lt;p&gt;* C-# (org-table-rotate-recalc-marks) ::&lt;/p&gt;

&lt;p&gt;使第一列的标志字符在&#39; &#39;,&#39;#&#39;,&#39;*&#39;,&#39;!&#39;,&#39;$&#39;这几个状态之间切换. 如果存在一个激活的块,则会改变该块中所有的标志.&lt;/p&gt;

&lt;p&gt;下面的例子是一个记录学生考试成绩的表格,里面用到了这些特性:&lt;/p&gt;

&lt;p&gt;#+begin_src org&lt;/p&gt;

&lt;p&gt;,|---+---------+--------+--------+--------+-------+------|&lt;/p&gt;

&lt;p&gt;,|   | Student | Prob 1 | Prob 2 | Prob 3 | Total | Note |&lt;/p&gt;

&lt;p&gt;,|---+---------+--------+--------+--------+-------+------|&lt;/p&gt;

&lt;p&gt;,| ! |         |     P1 |     P2 |     P3 |   Tot |      |&lt;/p&gt;

&lt;p&gt;,| # | Maximum |     10 |     15 |     25 |    50 | 10.0 |&lt;/p&gt;

&lt;p&gt;,| ^ |         |     m1 |     m2 |     m3 |    mt |      |&lt;/p&gt;

&lt;p&gt;,|---+---------+--------+--------+--------+-------+------|&lt;/p&gt;

&lt;p&gt;,| # | Peter   |     10 |      8 |     23 |    41 |  8.2 |&lt;/p&gt;

&lt;p&gt;,| # | Sam     |      2 |      4 |      3 |     9 |  1.8 |&lt;/p&gt;

&lt;p&gt;,|---+---------+--------+--------+--------+-------+------|&lt;/p&gt;

&lt;p&gt;,|   | Average |        |        |        |  29.7 |      |&lt;/p&gt;

&lt;p&gt;,| ^ |         |        |        |        |    at |      |&lt;/p&gt;

&lt;p&gt;,| $ | max=50  |        |        |        |       |      |&lt;/p&gt;

&lt;p&gt;,|---+---------+--------+--------+--------+-------+------|&lt;/p&gt;

&lt;p&gt;,#+TBLFM: $6=vsum($P1..$P3)::$7=10*$Tot/$max;%.1f::$at=vmean(@-II..@-I);%.1f&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;

&lt;p&gt;注意事项:请注意,对于这些特殊的表格来说,使用&#39;C-u C-c *&#39; 来重计算表格,只对标记了&#39;#&#39;或&#39;*&#39;的行,和那些分配了公式的域生效. 列公式对当第一个域为空的行无效.&lt;/p&gt;

&lt;p&gt;这些标志字符的意义如下所示:&lt;/p&gt;

&lt;p&gt;* &#39;!&#39; ::&lt;/p&gt;

&lt;p&gt;该行的域中的值为列的名称,因此你可以使用引用&#39;$Tot&#39;来代替&#39;$6&#39;&lt;/p&gt;

&lt;p&gt;* &#39;^&#39; ::&lt;/p&gt;

&lt;p&gt;	     这一行定义了上一行相应域的名称. 有着这种定义,任何表格中的公式可以使用&#39;$m1&#39;来引用值&#39;10&#39;. 而且如果你为这个命名了的域分配公式,该公式会被存储为&#39;$name=...&#39;的形式&lt;/p&gt;

&lt;p&gt;* &#39;-&#39; ::&lt;/p&gt;

&lt;p&gt;	     类似于&#39;^&#39;,但是是为下一行的相应域定义名字的.&lt;/p&gt;

&lt;p&gt;* &#39;$&#39; ::&lt;/p&gt;

&lt;p&gt;	     这一行的域可以为公式定义参数. 举个例子,如果&#39;$&#39;行中的某个域包含了&#39;max=50&#39;,则表格中的公式可以使用&#39;$max&#39;来引用50这个值. 参数就好像是常量一样,所不同的是它们(参数)能够根据每个表格来定义.&lt;/p&gt;

&lt;p&gt;* &#39;#&#39; ::&lt;/p&gt;

&lt;p&gt;	     当在行中按下了&lt;TAB&gt;或&lt;RET&gt;或S-,TAB&gt;,所有该标示的行中的域会自动重新计算. 另外当使用全局重计算命令(C-u C-c * )时这些行也会进行重计算,而无标示的行则对该全局重计算命令无效.&lt;/p&gt;

&lt;p&gt;* &#39;*&#39; ::&lt;/p&gt;

&lt;p&gt;	     当使用全局重计算命令(C-u C-c * )时,该标志行也会进行重计算,但是该标志行并不会自动进行重计算. 当自动重计算功能会明显降低编辑效率时,该标志很有用.&lt;/p&gt;

&lt;p&gt;* &#39;&#39; ::&lt;/p&gt;

&lt;p&gt;	    无标志字符的行在使用C-u C-c * 进行重计算时并不会进行重计算. 只有标示了&#39;#&#39;或&#39;*&#39;的行才会重新计算.&lt;/p&gt;

&lt;p&gt;* &#39;/&#39; ::&lt;/p&gt;

&lt;p&gt;	     不导出带有该标志的行. 对那些包含了narrowing &#39;&lt;N&gt;&#39;标记(缩小的&#39;&lt;N&gt;&#39;标记)或列的分组标志很有用.&lt;/p&gt;

&lt;p&gt;最后,你可能会对使用梦幻般的&#39;calc.el&#39;包能实现那些功能很感兴趣, 下面是一个表格,它计算了the Taylor series of degree n at location x for a couple of functions.&lt;/p&gt;

&lt;p&gt;#+begin_src org&lt;/p&gt;

&lt;p&gt;,|---+-------------+---+-----+--------------------------------------|&lt;/p&gt;

&lt;p&gt;,|   | Func        | n | x   | Result                               |&lt;/p&gt;

&lt;p&gt;,|---+-------------+---+-----+--------------------------------------|&lt;/p&gt;

&lt;p&gt;,| # | exp(x)      | 1 | x   | 1 + x                                |&lt;/p&gt;

&lt;p&gt;,| # | exp(x)      | 2 | x   | 1 + x + x^2 / 2                      |&lt;/p&gt;

&lt;p&gt;,| # | exp(x)      | 3 | x   | 1 + x + x^2 / 2 + x^3 / 6            |&lt;/p&gt;

&lt;p&gt;,| # | x^2+sqrt(x) | 2 | x=0 | x*(0.5 / 0) + x^2 (2 - 0.25 / 0) / 2 |&lt;/p&gt;

&lt;p&gt;,| # | x^2+sqrt(x) | 2 | x=1 | 2 + 2.5 x - 2.5 + 0.875 (x - 1)^2    |&lt;/p&gt;

&lt;p&gt;,| * | tan(x)      | 3 | x   | 0.0175 x + 1.77e-6 x^3               |&lt;/p&gt;

&lt;p&gt;,|---+-------------+---+-----+--------------------------------------|&lt;/p&gt;

&lt;p&gt;,#+TBLFM: $5=taylor($2,$4,$3);n3&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;

&lt;h2 id=&#34;org-plot-org表格绘图&#34;&gt;Org-Plot&lt;/h2&gt;

&lt;p&gt;通过使用&#39;Gnuplot&#39;&lt;a href=&#34;http://www.gnuplot.info&#34; title=&#34;http://www.gnuplot.info&#34;&gt;http://www.gnuplot.info&lt;/a&gt; 和&#39;gnplot-mode&#39;&lt;a href=&#34;http://cars9.uchicago.edu/~ravel/software/gnuplot-mode.html&#34; title=&#34;http://cars9.uchicago.edu/~ravel/software/gnuplot-mode.html&#34;&gt;http://cars9.uchicago.edu/~ravel/software/gnuplot-mode.html&lt;/a&gt; ,Org-Plot可用根据表格中的数据生成2D和3D图表. 这里有一个例子: 首先确保你安装了Gnuplot和Gnuplot mode,然后对下面的表格调用&#39;org-plot/gnuplot&#39;&lt;/p&gt;

&lt;p&gt;#+begin_src org&lt;/p&gt;

&lt;p&gt;,#+PLOT: title:&#34;Citas&#34; ind:1 deps:(3) type:2d with:histograms set:&#34;yrange [0:]&#34;&lt;/p&gt;

&lt;p&gt;,| Sede      | Max cites | H-index |&lt;/p&gt;

&lt;p&gt;,|-----------+-----------+---------|&lt;/p&gt;

&lt;p&gt;,| Chile     |    257.72 |   21.39 |&lt;/p&gt;

&lt;p&gt;,| Leeds     |    165.77 |   19.68 |&lt;/p&gt;

&lt;p&gt;,| Sao Paolo |     71.00 |   11.50 |&lt;/p&gt;

&lt;p&gt;,| Stockholm |    134.19 |   14.33 |&lt;/p&gt;

&lt;p&gt;,| Morelia   |    257.56 |   17.67 |&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;

&lt;p&gt;注意,Org Plot会自动把表格的标题作为生成图表的标签. 通过表格前的#+PLOT:行,你还可以定义plot的标签,类型,内容和展示. 下面列出了完整的Org-plot选项. 更多的信息和例子请参见Org-plot教程&lt;a href=&#34;http://orgmode.org/worg/org-tutorials/org-plot.html&#34; title=&#34;http://orgmode.org/worg/org-tutorials/org-plot.html&#34;&gt;http://orgmode.org/worg/org-tutorials/org-plot.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Plot Options&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;* set ::&lt;/p&gt;

&lt;p&gt;当绘图时,用于设置任何的gnuplot选项&lt;/p&gt;

&lt;p&gt;* title ::&lt;/p&gt;

&lt;p&gt;	      指定plot的标题&lt;/p&gt;

&lt;p&gt;* ind ::&lt;/p&gt;

&lt;p&gt;	    指定表格的哪一列作为x轴&lt;/p&gt;

&lt;p&gt;* deps ::&lt;/p&gt;

&lt;p&gt;	     指定描绘哪些列,该设置的格式类似于Lisp中的list,由小括号括起来,内部用空格分隔,例如&#39;dep:(3 4)&#39;指定只描绘第3,4列(默认情况下,除了指明为ind的列,其他的列都会被描绘)&lt;/p&gt;

&lt;p&gt;* type ::&lt;/p&gt;

&lt;p&gt;	     指定plot是2d还是3d还是grid的&lt;/p&gt;

&lt;p&gt;* with ::&lt;/p&gt;

&lt;p&gt;	     对每一个要被绘制的列都插入一个指定的with选项(例如,lines,points,boxes,impulses,等等). 默认值为lines&lt;/p&gt;

&lt;p&gt;* file ::&lt;/p&gt;

&lt;p&gt;	     如果你想将描绘输出成一个文件,指定输出文件的路径&lt;/p&gt;

&lt;p&gt;* labels ::&lt;/p&gt;

&lt;p&gt;	       用一个列表指定各输出列的标签(默认情况下,如果列的标题村爱的话,使用列标题作为标签)&lt;/p&gt;

&lt;p&gt;* line ::&lt;/p&gt;

&lt;p&gt;	     在gnuplot脚本中插入指定的一整行(Specify an entire line to be inserted in the Gnuplot script. )&lt;/p&gt;

&lt;p&gt;* map ::&lt;/p&gt;

&lt;p&gt;	    当描绘类型为3d或grid时,该选项的值设为t则在描绘时描绘的是一个平面映射而不是3维图形(set this to t to graph a flat mapping rather than a 3d slope)&lt;/p&gt;

&lt;p&gt;* timefmt ::&lt;/p&gt;

&lt;p&gt;		指定Org-mode的时间戳格式,因为它们会被Gnuplot所解析,默认格式为&#39;%Y-%m-%d-%H:%M:%S&#39;&lt;/p&gt;

&lt;p&gt;* script ::&lt;/p&gt;

&lt;p&gt;	       如果你想实现完全的自定义,你可以指定一个脚本文件(把文件名放在双引号内)来实现描绘动作. 在正真描绘之前,这个特定脚本中的每个&#39;$datafile&#39;会被替换成生成的数据文件的实际路径. 注意:即使你设置了这个选项,你也可能仍然需要定义plot的type,因为这个选项会影响到生成的数据文件的内容.&lt;/p&gt;

&lt;h1 id=&#34;超链接&#34;&gt;超链接&lt;/h1&gt;

&lt;p&gt;类似于HTML,Org提供了文件内部的链接,和文件外部的链接(可以链接到其他文件,Usenet文章,email等等)&lt;/p&gt;

&lt;h2 id=&#34;链接的格式-org中的链接是什么格式的&#34;&gt;链接的格式&lt;/h2&gt;

&lt;p&gt;Org会识别类似URL的链接并且把它们作为可点击的链接. 然而,Org中链接的一般形式看起来像下面这样子&lt;/p&gt;

&lt;p&gt;#+begin_example&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;链接地址&#34; title=&#34;描述&#34;&gt;描述&lt;/a&gt;  或者 &lt;a href=&#34;链接&#34; title=&#34;链接&#34;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#+end_example&lt;/p&gt;

&lt;p&gt;一旦缓冲区中的链接被补完(所有的中括号都有了), Org会只显示链接中的&#39;描述&#39;,而不是链接的完整形式. Link会以&#39;org-link&#39;定义的方式高亮,默认情况下是以下划线标示起来. 你可以直接编辑链接的显示部分(当有描述部分是为&#39;描述&#39;部分,否则为&#39;链接&#39;部分). 要编辑不可见的&#39;链接&#39;部分,把光标放在要编辑的链接上然后按下C-c C-l&lt;/p&gt;

&lt;p&gt;如果光标在链接的起始部分或就在链接中显示文本的后面,然后你按下&lt;DEL&gt;或&lt;BACKSPACE&gt;时,你删掉的是链接中不可见的中括号. 这样会使这个链接变得不完整,因此该链接的内部表现形式会以纯文本的方式展现出来. 再补完这个中括号又会使链接隐藏其内部结构. 要显示出所有链接的内部结构,使用菜单&#39;org-&gt;hyperlinks-&gt;Literal links&#39;&lt;/p&gt;

&lt;h2 id=&#34;内部链接-链接到同一文件的不同地方&#34;&gt;内部链接&lt;/h2&gt;

&lt;p&gt;如果链接看起来不像是URL,那么它会被认为是链接到当前文件的内部. 最重要的一个例子就是一种看起来像&#39;&lt;a href=&#34;#my-custom-id&#34; title=&#34;#my-custom-id&#34;&gt;#my-custom-id&lt;/a&gt;(中间没有空格)&#39;的链接,这种链接会连接到&#39;CUSTOM_ID&#39;属性为&#39;my-custom-id&#39;的条目中. 这种客户化的ID在导出为HTML时很有帮助(参见&lt;a href=&#34;#HTML export&#34; title=&#34;导出为HTML&#34;&gt;导出为HTML&lt;/a&gt;),通过这些ID,org会自动产生许多章节间的链接. 你需要保证这些客户化的ID在文件中是唯一的.&lt;/p&gt;

&lt;p&gt;类似于&#39;&lt;a href=&#34;My Target&#34; title=&#34;My Target&#34;&gt;My Target&lt;/a&gt;&#39;或&#39;&lt;a href=&#34;My Target&#34; title=&#34;Find my target&#34;&gt;Find my target&lt;/a&gt;]&#39;会在当前文件中搜索指定文本,并链接过去.&lt;/p&gt;

&lt;p&gt;当光标处于链接上时,可以用C-c C-o或鼠标点击(参见&lt;a href=&#34;#Handing links&#34; title=&#34;处理链接&#34;&gt;处理链接&lt;/a&gt;)的方式来进入链接. 连接到客户化ID的链接会指向相应的标题. 匹配文本链接的一个比较好的方法是使用dedicated target:用两个尖括号将文本括起来. 链接标的可以放置在任何地方; 有时候把这些链接标的放置在注释行中会比较好.例如&lt;/p&gt;

&lt;p&gt;#+begin_example&lt;/p&gt;

&lt;p&gt;# &lt;&lt;My Target&gt;&gt;&lt;/p&gt;

&lt;p&gt;#+end_example&lt;/p&gt;

&lt;p&gt;在导出HTML时(参见&lt;a href=&#34;#HTML export&#34; title=&#34;导出HTML&#34;&gt;导出HTML&lt;/a&gt;),这些链接标的会转换为已命名的锚点,可以通过http链接[fn:34]直接定位到这些锚点的位置.&lt;/p&gt;

&lt;p&gt;如果没有&#39;dedicated target&#39;存在, Org会搜索与链接文本完全一样的标题(可能也会搜索TODO关键字和标签[fn:35]). 在非Org文件中,则会搜索跟链接文本匹配的文本内容. 在上面的例子中,匹配的是&#39;my target&#39;.&lt;/p&gt;

&lt;p&gt;进入一个链接会把一个mark放置仅Org自己的mark ring中. 这样你可以使用C-c &amp;退回前一个位置. 可以多次使用该命令来退到早期记录的位置上.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;Radio targets&#34; title=&#34;Radio targets&#34;&gt;Radio targets&lt;/a&gt; 使得可以触发纯文本形式的链接.&lt;/p&gt;

&lt;h3 id=&#34;radio-targets&#34;&gt;Radio targets&lt;/h3&gt;

&lt;p&gt;Org可以自动把普通文本中特定的文本转换为链接. 因此不需要明确地创建链接,这些特定的文本会自动创建连接到带有radio target标志的位置. Radio target包裹在三个尖括号中,就像&#39;&lt;&lt;&lt;My Target&gt;&gt; &gt;(不带空格)&#39;这样. 这个radio target使得普通文本中出现&#39;My Target&#39;的地方都被自动转换为链接. 只有在文档第一次加载人Emacs时,Org才会自动去扫描radio target. 在编辑时要更新target列表,可以把光标放到target上,然后安歇C-c C-c&lt;/p&gt;

&lt;h2 id=&#34;外部链接-类似与url这样的链接-可以链接到全世界&#34;&gt;外部链接&lt;/h2&gt;

&lt;p&gt;Org支持连接到文件,网站,Usenet,email信息,BBDB数据库条目,IRC会议及其日志的链接. 外部链接看起来类似URL. 这些外部链接是以一个简短的标示串开头后面紧跟冒号(在冒号后面不跟空格).下面是各种类的链接的例子[fn:36]&lt;/p&gt;

&lt;p&gt;#+begin_example&lt;/p&gt;

&lt;p&gt;http://www.astro.uva.nl/~dominik          on the web&lt;/p&gt;

&lt;p&gt;doi:10.1000/182                           DOI for an electronic resource&lt;/p&gt;

&lt;p&gt;file:/home/dominik/images/jupiter.jpg     file, absolute path&lt;/p&gt;

&lt;p&gt;/home/dominik/images/jupiter.jpg          same as above&lt;/p&gt;

&lt;p&gt;file:papers/last.pdf                      file, relative path&lt;/p&gt;

&lt;p&gt;./papers/last.pdf                         same as above&lt;/p&gt;

&lt;p&gt;file:/myself@some.where:papers/last.pdf   file, path on remote machine&lt;/p&gt;

&lt;p&gt;/myself@some.where:papers/last.pdf        same as above&lt;/p&gt;

&lt;p&gt;file:sometextfile::NNN                    file, jump to line number&lt;/p&gt;

&lt;p&gt;file:projects.org                         another Org file&lt;/p&gt;

&lt;p&gt;file:projects.org::some words             text search in Org file[36]&lt;/p&gt;

&lt;p&gt;file:projects.org::*task title            heading search in Org file&lt;/p&gt;

&lt;p&gt;file+sys:/path/to/file                    open via OS, like double-click&lt;/p&gt;

&lt;p&gt;file+emacs:/path/to/file                  force opening by Emacs&lt;/p&gt;

&lt;p&gt;docview:papers/last.pdf::NNN              open in doc-view mode at page&lt;/p&gt;

&lt;p&gt;id:B7423F4D-2E8A-471B-8810-C40F074717E9   Link to heading by ID&lt;/p&gt;

&lt;p&gt;news:comp.emacs                           Usenet link&lt;/p&gt;

&lt;p&gt;mailto:adent@galaxy.net                   Mail link&lt;/p&gt;

&lt;p&gt;vm:folder                                 VM folder link&lt;/p&gt;

&lt;p&gt;vm:folder#id                              VM message link&lt;/p&gt;

&lt;p&gt;vm://myself@some.where.org/folder#id      VM on remote machine&lt;/p&gt;

&lt;p&gt;wl:folder                                 WANDERLUST folder link&lt;/p&gt;

&lt;p&gt;wl:folder#id                              WANDERLUST message link&lt;/p&gt;

&lt;p&gt;mhe:folder                                MH-E folder link&lt;/p&gt;

&lt;p&gt;mhe:folder#id                             MH-E message link&lt;/p&gt;

&lt;p&gt;rmail:folder                              RMAIL folder link&lt;/p&gt;

&lt;p&gt;rmail:folder#id                           RMAIL message link&lt;/p&gt;

&lt;p&gt;gnus:group                                Gnus group link&lt;/p&gt;

&lt;p&gt;gnus:group#id                             Gnus article link&lt;/p&gt;

&lt;p&gt;bbdb:R.*Stallman                          BBDB link (with regexp)&lt;/p&gt;

&lt;p&gt;irc:/irc.com/#emacs/bob                   IRC link&lt;/p&gt;

&lt;p&gt;info:org#External links                   Info node link&lt;/p&gt;

&lt;p&gt;shell:ls *.org                            A shell command&lt;/p&gt;

&lt;p&gt;elisp:org-agenda                          Interactive Elisp command&lt;/p&gt;

&lt;p&gt;elisp:(find-file-other-frame &#34;Elisp.org&#34;) Elisp form to evaluate&lt;/p&gt;

&lt;p&gt;#+end_example&lt;/p&gt;

&lt;p&gt;要自定义Org以支持新的链接类型,参见&lt;a href=&#34;#Adding hyperlink types&#34; title=&#34;新增链接类型&#34;&gt;新增链接类型&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一个链接应该被两个中括号括住,并且可以包含一个描述文本,这个描述文本会代替URL显示给用户看(参见章节&lt;a href=&#34;#Link format&#34; title=&#34;链接类型&#34;&gt;链接类型&lt;/a&gt;),例如:&lt;/p&gt;

&lt;p&gt;#+begin_src org&lt;/p&gt;

&lt;p&gt;,&lt;a href=&#34;http://www.gnu.org/software/emacs/&#34; title=&#34;GNU Emacs&#34;&gt;GNU Emacs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;

&lt;p&gt;如果描述部分是一个文件的名字或者是一个连接到图像的链接,HTML导出时(参见&lt;a href=&#34;#HTML export&#34; title=&#34;导出HTML&#34;&gt;导出HTML&lt;/a&gt;)会内嵌入这个图像并显示为一个可点击的按钮. 如果链接中根本没有定义描述而定义的link是指向一个图形文件的,那么这个图形文件会被内嵌入导出的的HTML文件中.&lt;/p&gt;

&lt;p&gt;Org也会在普通文本中查找外部链接并且把它们当做真正的链接处理. 如果link部分包含有空格(例如&#39;bbdb:Richar stallman&#39;),或者如果你需要明确link的结尾位置所在,你可以把它们放入方括号中.&lt;/p&gt;

&lt;h2 id=&#34;链接处理-创建-插入和进入链接&#34;&gt;链接处理&lt;/h2&gt;

&lt;p&gt;Org提供了多种方法来创建和跟踪链接&lt;/p&gt;

&lt;p&gt;* C-c l (org-store-link) ::&lt;/p&gt;

&lt;p&gt;	 在创建一个连接到当前位置的链接. 这是一个全局命令(你需要自己创建绑定热键),你可以用它在任一个buffer中创建指向自己的连接. 这个被创建出来的链接可以随后插入到Org-mode的buffer中保存起来(见下文). 具体创建的是哪个类型的链接由当前buffer的类型来决定&lt;/p&gt;

&lt;p&gt;	 * Org-mode buffer&lt;/p&gt;

&lt;p&gt;	   对于Org文件来说,若光标位于&#39;&lt;&lt;&gt;target&gt;&#39;处,则创建的链接指向该target. 否则链接指向当前的headline,同时以headline作为链接中描述部分的内容[fn:37]&lt;/p&gt;

&lt;p&gt;	   如果headline有CUSTOM_ID属性的话,会创建一个连接到该客户化ID的链接. Org会创建一个全局唯一的ID,并根据org-link-to-org-use-i的值新增一条指向该ID的链接/替换原有的自定义ID. 因此在Org buffer中使用这个命令有可能会创建两个链接,一个指向可读的自定义ID,一个指向全局唯一的链接,这个全局唯一的链接即使在原条目被移动到其他文件后也是可用的. 随后当你要把链接插入Org文件时,你需要决定插入哪个链接.&lt;/p&gt;

&lt;p&gt;	 * Email/News客户端:VM,Rmail,Wanderlust,MH-E,Gnus&lt;/p&gt;

&lt;p&gt;	   在很多Emacs邮件客户端buffer使用这个命令时,产生的链接会指向当前的邮件,甚至,在某些GNUS buffer中,可用指向分组. 邮件的作者和标题会作为链接的描述信息&lt;/p&gt;

&lt;p&gt;	 * Web浏览器:W3和W3M&lt;/p&gt;

&lt;p&gt;	   生成的链接连接到当前的URL,网页title作为链接的描述信息&lt;/p&gt;

&lt;p&gt;	 * Chat:IRC&lt;/p&gt;

&lt;p&gt;	   对于IRC链接来说,如果你设置变量org-irc-link-to-logs的值为t,那么创建的链接指向当前会话的日志,链接的形式类似于&#39;file:/&#39;. 否则的话,创建的链接指向当前用户/频道/服务器,链接的形式为&#39;irc:/&#39;&lt;/p&gt;

&lt;p&gt;	 * 其他类型的文件&lt;/p&gt;

&lt;p&gt;	   对于其他类型的文件,创建的链接指向该文件,同时链接会有一个搜索字符串(参见&lt;a href=&#34;#Search options in file links&#34; title=&#34;指向文件链接的搜索项&#34;&gt;指向文件链接的搜索项&lt;/a&gt;)指向当前行的内容.&lt;/p&gt;

&lt;p&gt;* C-c C-l (org-insert-link) ::&lt;/p&gt;

&lt;p&gt;	 插入一个链接[fn:38].它会提示你输入一个链接,并将这个链接插入到当前的buffer中. 你可以输入上面例子中提到的任何类型的链接.随后系统会让你输入链接的描述文本并将生成的链接插入到buffer中[fn:39]. 如果在调用该命令时选中了一些文本,那么选中的文本会成为默认的描述文本呢&lt;/p&gt;

&lt;p&gt;	 * 插入存储过的链接&lt;/p&gt;

&lt;p&gt;	   所有在当前会话期存储过的链接都会记录到该命令提示的历史信息中,因此,在提示符中你可以用&lt;up&gt;和&lt;down&gt;(或者M-p/n)来切换历史链接信息&lt;/p&gt;

&lt;p&gt;	 * 支持补全&lt;/p&gt;

&lt;p&gt;	   如果你要插入的链接前缀类似于&#39;http:&#39;或&#39;ftp:&#39;,你可用通过按&lt;TAB&gt;键来自动补全.比如你可以只写链接的简写形式,然后按TAB键扩充它(参见&lt;a href=&#34;#Link%20abbreviations&#34; title=&#34;链接的缩写&#34;&gt;链接的缩写&lt;/a&gt;).如果你在输入前缀部分之后直接按&lt;RET&gt;,Org会根据前缀的不通为各种不通类型的链接提供不通的补全模式[fn:40].例如,如果你输入`file &lt;RET&gt;`,就会进入文件路径补全状态(另一种进入该状态的方式是用C-u C-c C-l,见下文),而如果你输入`bbdb &lt;RET&gt;`,就会进入联系人名称补全的状态&lt;/p&gt;

&lt;p&gt;* C-u C-c C-l  ::&lt;/p&gt;

&lt;p&gt;	 插入一个指向本地文件的链接,你可以使用文件路径的补全功能来补全文件路径. 若插入的文件路径为相对路径,则该相对路径是相对与正在编辑的Org文件的目录来说的.你可以用`~/`代替你的home目录. 你也可用通过两个C-u前缀来强迫插入的链接为绝对路径&lt;/p&gt;

&lt;p&gt;* C-c C-l :: 光标需要停在链接上&lt;/p&gt;

&lt;p&gt;	 当光标停在链接上时,C-c C-l允许你编辑链接的连接和描述信息&lt;/p&gt;

&lt;p&gt;* C-c C-o (org-open-at-point) ::&lt;/p&gt;

&lt;p&gt;		打开光标所在的链接,Org会使用web浏览器(由值browse-url-at-point定义)打开URL,&lt;/p&gt;

&lt;p&gt;会使用VM/MH-E/Wanderlust/Gnus/BBDB打开相应的链接,&lt;/p&gt;

&lt;p&gt;若链接为shell链接还会在在shell中执行链接中的命令.&lt;/p&gt;

&lt;p&gt;若链接为内部链接,该命令会进行相应的搜索操作.&lt;/p&gt;

&lt;p&gt;若光标出于标题的TAG列表处,则会创建相应的TAGS视图.&lt;/p&gt;

&lt;p&gt;如果光标处于时间戳上,它会为该日期生成一个agenda.&lt;/p&gt;

&lt;p&gt;另外如果光标处于&#39;file:&#39;类型的链接处,它会打开链接所指向的文件,如果指向的文件是远程文件或文本文件则直接用Emacs打开,如果是本地的非文本文件,则命令会挑选合适的程序打开. 命令是根据文件的扩展名来识别文件类型的. 哪种文件用哪种程序打开由org-file-apps选项配置. 如果你想用Emacs代替默认的程序来打开链接指向的文件,使用C-u前缀执行该命令. 而如果你不想用Emacs打开链接所指向的文件,使用C-u C-u前缀来调用该命令.&lt;/p&gt;

&lt;p&gt;		如果光标位于headline处,而这个headline刚好又不是个链接,则命令会搜索该headline下的所有链接并显示给你选择打开哪个链接.&lt;/p&gt;

&lt;p&gt;		如果你想setup the frame configuration for following links ,配置org-link-frame-setup变量&lt;/p&gt;

&lt;p&gt;* &lt;RET&gt; ::&lt;/p&gt;

&lt;p&gt;			  若设置了&#39;org-return-follows-link&#39;值,&lt;RET&gt;也会打开光标所在的链接&lt;/p&gt;

&lt;p&gt;* 鼠标右键 鼠标左键 ::&lt;/p&gt;

&lt;p&gt;		在链接上单击鼠标右键,则会像执行了C-c C-o一样的打开链接. 在Emacs22或更高版本上,鼠标左键也能打开链接&lt;/p&gt;

&lt;p&gt;* 鼠标中间键 ::&lt;/p&gt;

&lt;p&gt;				   类似于鼠标右键,但是强制使用Emacs打开链接,如果链接是内部链接,那么会在另一个窗口显示链接内容[fn:41]&lt;/p&gt;

&lt;p&gt;* C-c C-x C-v (org-toggle-inline-images) ::&lt;/p&gt;

&lt;p&gt;		切换是否内联显示连接的图片. 正常情况下,它只会内联哪些在链接中没有描述信息的图片,比如那些在导出时会内联的图片. 如果执行该命令时加了一个前缀参数,则命令也会显示那些有描述信息的链接图片. 通过配置变量`org-startup-with-inline-images`[fn:42]你也可以让emacs在一打开org的时候就内联显示图片.&lt;/p&gt;

&lt;p&gt;* C-c % (org-mark-ring-push) ::&lt;/p&gt;

&lt;p&gt;		把当前位置压入mark ring中,以方便以后方便跳回该位置. 那些打开链接的命令都会自动执行这一步&lt;/p&gt;

&lt;p&gt;* C-c &amp; (org-mark-ring-goto) ::&lt;/p&gt;

&lt;p&gt;		跳回一个已经记录了的位置. 在访问内部链接和执行`C-c %`命令时都会记录下位置信息. 连续使用该命令多次可用跳到mark ring中更远的记录位置处&lt;/p&gt;

&lt;p&gt;* C-c C-x C-n (org-next-link) / C-c C-x C-p (org-previous-link) ::&lt;/p&gt;

&lt;p&gt;		跳到该buffer下一个/前一个链接处. 当到达buffer的最后一个/第一个链接处时,在执行该命令,第一次会显示失败,之后就跳到最后一个/第一个链接处继续搜索. 这两个命令的绑定键确实太长了;你可能希望用C-n和C-p来绑定:&lt;/p&gt;

&lt;p&gt;		#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;(add-hook &#39;org-load-hook&lt;/p&gt;

&lt;p&gt;(lambda ()&lt;/p&gt;

&lt;p&gt;(define-key org-mode-map &#34;\C-n&#34; &#39;org-next-link)&lt;/p&gt;

&lt;p&gt;(define-key org-mode-map &#34;\C-p&#34; &#39;org-previous-link)))&lt;/p&gt;

&lt;p&gt;		#+END_SRC&lt;/p&gt;

&lt;h2 id=&#34;在org外使用链接-从我的c源码中链接过来的&#34;&gt;在Org外使用链接&lt;/h2&gt;

&lt;p&gt;不仅在Org模式中,在其他模式下你也可以插入和进入使用Org语法标示的链接. 要做到这一点,你可以就像下面所示创建两个全局命令(你可以选择自己喜欢的全局键)&lt;/p&gt;

&lt;p&gt;#+begin_src emacs-lisp&lt;/p&gt;

&lt;p&gt;(global-set-key &#34;\C-c L&#34; &#39;org-insert-link-global)&lt;/p&gt;

&lt;p&gt;(global-set-key &#34;\C-c o&#34; &#39;org-open-at-point-global)&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;

&lt;h2 id=&#34;链接的缩写-复杂链接的缩写形式-link-abbreviations&#34;&gt;链接的缩写&lt;/h2&gt;

&lt;p&gt;长URL输起来很麻烦,而且很多时候在文档中需要插入很多类似的链接. 这个时候你就可以使用链接缩写的功能了. 一个缩写的链接看起类似于&lt;/p&gt;

&lt;p&gt;#+begin_src org&lt;/p&gt;

&lt;p&gt;,&lt;a href=&#34;linkword:tag&#34; title=&#34;description&#34;&gt;description&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;

&lt;p&gt;这里tag是可选的. linkword必须是一个word,以字母开头后面跟着字母,数字,&#39;-&#39;和&#39;_&#39;. Org根据变量&#39;org-link-abbrev-alist&#39;中的信息来分析缩写. 该变量把linkword与替代的文本关联起来.下面是个例子&lt;/p&gt;

&lt;p&gt;#+begin_src emacs-lisp&lt;/p&gt;

&lt;p&gt;(setq org-link-abbrev-alist&lt;/p&gt;

&lt;p&gt;&#39;((&#34;bugzilla&#34; . &#34;http://10.1.2.9/bugzilla/show_bug.cgi?id=&#34;)&lt;/p&gt;

&lt;p&gt;(&#34;google&#34;   . &#34;http://www.google.com/search?q=&#34;)&lt;/p&gt;

&lt;p&gt;(&#34;gmap&#34;     . &#34;http://maps.google.com/maps?q=%s&#34;)&lt;/p&gt;

&lt;p&gt;(&#34;omap&#34;     . &#34;http://nominatim.openstreetmap.org/search?q=%s&amp;polygon=1&#34;)&lt;/p&gt;

&lt;p&gt;(&#34;ads&#34;      . &#34;http://adsabs.harvard.edu/cgi-bin/nph-abs_connect?author=%s&amp;db_key=AST&#34;)))&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;

&lt;p&gt;如果被替代的文本中包含字符串&#39;%s&#39;, 字符串&#39;%s&#39;会被tag所取代. 否则tag会直接浮在字符串后面并以此来创建一个链接. 你也可以指定一个函数来创建链接,该函数要求只接受tag这唯一一个参数.&lt;/p&gt;

&lt;p&gt;通过上面的设置,你可以使用&#39;&lt;a href=&#34;bugzilla:129&#34; title=&#34;bugzilla:129&#34;&gt;bugzilla:129&lt;/a&gt;(不含空格)&#39;来连接到一个指定的bug, 使用&#39;&lt;a href=&#34;google:OrgMode&#34; title=&#34;google:OrgMode&#34;&gt;google:OrgMode&lt;/a&gt;&#39;来在web上搜索&#39;OrgMode&#39;,使用&#39;&lt;a href=&#34;gmap:51 Franklin Street,Boston&#34; title=&#34;gmap:51 Franklin Street,Boston&#34;&gt;gmap:51 Franklin Street,Boston&lt;/a&gt;&#39;显示自由软件组织在地图上的位置,使用&#39;&lt;a href=&#34;omap:Science Park 904, Amsterdam, The Netherlands&#34; title=&#34;omap:Science Park 904, Amsterdam, The Netherlands&#34;&gt;omap:Science Park 904, Amsterdam, The Netherlands&lt;/a&gt;&#39;来显示Carsten office在地图上的位置,使用&#39;&lt;a href=&#34;ads:Dominik,C&#34; title=&#34;ads:Dominik,C&#34;&gt;ads:Dominik,C&lt;/a&gt;&#39;来查找Org的作者在Emacs hacking时做了什么.&lt;/p&gt;

&lt;p&gt;如果你只需要为单独一个Org buffer指定缩写,你可以在文件中定义:&lt;/p&gt;

&lt;p&gt;#+begin_src org&lt;/p&gt;

&lt;p&gt;,#+LINK: bugzilla  http://10.1.2.9/bugzilla/show_bug.cgi?id=&lt;/p&gt;

&lt;p&gt;,#+LINK: google    http://www.google.com/search?q=%s&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;

&lt;p&gt;在&#39;[&#39;之后可以使用In-buffer补完功能来补完缩写. 你也可以定义一个名为&#39;org-PREFIX-complete-link&#39;的函数,该函数实现对使用C-c C-l插入的链接的特定支持动作(例如补完动作). 这个函数不接受任何参数并且返回带前置的完整链接.&lt;/p&gt;

&lt;h2 id=&#34;文件链接中的搜索选项-链接到特殊的位置&#34;&gt;文件链接中的搜索选项&lt;/h2&gt;

&lt;p&gt;连接到文件的链接(文件链接)可以包含附加的信息来让Emacs在进入链接时跳转到文件的指定位置. 这个附加信息是放置在双[fn:43]冒号(::)之后,它可以是行号或者是搜索项. 例如当用C-c l创建一个连接到文件的链接时(参见章节&lt;a href=&#34;#handling links&#34; title=&#34;处理链接&#34;&gt;处理链接&lt;/a&gt;), 这个链接会编码一个单词到当前行中,这个单词作为搜索字符串,当用C-c C-o进入链接时,就可以根据这个搜索字符串找回这一行.&lt;/p&gt;

&lt;p&gt;下面是一些例子,演示了添加搜索项到文件链接的不同方式.&lt;/p&gt;

&lt;p&gt;#+begin_example&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;~/code/main.c::255&#34; alt=&#34;~/code/main.c::255&#34; title=&#34;~/code/main.c::255&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;~/xx.org::My Target&#34; alt=&#34;~/xx.org::My Target&#34; title=&#34;~/xx.org::My Target&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;~/xx.org::*My Target&#34; alt=&#34;~/xx.org::*My Target&#34; title=&#34;~/xx.org::*My Target&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;~/xx.org::#my-custom-id&#34; alt=&#34;~/xx.org::#my-custom-id&#34; title=&#34;~/xx.org::#my-custom-id&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;~/xx.org::/regexp/&#34; alt=&#34;~/xx.org::/regexp/&#34; title=&#34;~/xx.org::/regexp/&#34; /&gt;&lt;/p&gt;

&lt;p&gt;#+end_example&lt;/p&gt;

&lt;p&gt;* 255 ::&lt;/p&gt;

&lt;p&gt;跳转到第255行&lt;/p&gt;

&lt;p&gt;* My Target ::&lt;/p&gt;

&lt;p&gt;		  搜索链接项&lt;&lt;My Target&gt;&gt;,或者直接文本搜索&#39;my target&#39;, 类似于文件内链接的搜索,参见&lt;a href=&#34;#Internal links&#34; title=&#34;内部链接&#34;&gt;内部链接&lt;/a&gt;. 在导出HTML时(参见章节&lt;a href=&#34;#HTML export&#34; title=&#34;导出HTML&#34;&gt;导出HTML&lt;/a&gt;),这种文件链接会导出为HTML链接,连接到被连接文件的指定anchor处.&lt;/p&gt;

&lt;p&gt;* *My Target ::&lt;/p&gt;

&lt;p&gt;		   在Org文件中,精确搜索名为为My Target的标题&lt;/p&gt;

&lt;p&gt;* #my-custom-id ::&lt;/p&gt;

&lt;p&gt;		      连接到CUSTOM_ID属性值为my-custom-id的标题&lt;/p&gt;

&lt;p&gt;* &lt;em&gt;regexp &lt;/em&gt; ::&lt;/p&gt;

&lt;p&gt;		 使用regexp做正则搜索. 该命令使用Emacs命令occur来在新窗口中列出所有的匹配项. 如果被连接文件处于Org模式下,org会使用org-occur命令来创建这些匹配的sparse tree&lt;/p&gt;

&lt;p&gt;作为简化,一个文件名为空的文件连接,默认是连接到当前文件的. 例如&#39;&lt;img src=&#34;::find me&#34; alt=&#34;::find me&#34; title=&#34;::find me&#34; /&gt;&#39;(没有空格),会在当前文件中搜索&#39;find me&#39;,就好像&#39;&lt;a href=&#34;find me&#34; title=&#34;find me&#34;&gt;find me&lt;/a&gt;&#39;一样.&lt;/p&gt;

&lt;h2 id=&#34;客户化搜索-当内置的搜索不够用的时候&#34;&gt;客户化搜索&lt;/h2&gt;

&lt;p&gt;文件链接中的字符串搜索的默认实现并不能在所有情况下都能正常工作. 例如,BibTex数据库文件有很多类似于&#39;year=&#34;1993&#34;&#39;这样的条目,由于BibTex条目的唯一识别就是引用的键值(key),因此这些条目可能不能很好地进行字符串搜索(??意思可能是当对BibTex数据库进行搜索时,只希望在key中搜索,而不在value中搜索)&lt;/p&gt;

&lt;p&gt;如果你遇到了这样的问题,你可以为特定的文件类型指定客户化的函数来实现正确的字符串搜索. 使用add-hook,这些函数需要添加到hook变量&#39;org-create-file-search-functions&#39;和变量&#39;org-excute-file-search-functions&#39;中. 要了解更多的信息可以参见这两个变量的docstring. org实际上使用这里定义的实现来对BibTex数据库文件进行搜索,你可以参见文件&#39;org-bibtex.el&#39;作为一个实现的例子.&lt;/p&gt;

&lt;h1 id=&#34;项&#34;&gt;&lt;span class=&#34;todo TODO&#34;&gt;TODO&lt;/span&gt; 项&lt;/h1&gt;

&lt;p&gt;Org-mode并不把TODO列表作为单独的一种文档来看待[fn:44]. 相反,由于在记录的时候常常会有TODO事项发生,因此TODO事项被认为是记录文件中中不可分割的一部分! 使用Org可用很容易的把各级条目标记为TODO事项. 通过这种方法,可用避免信息的重复,同时TODO事项的整个内容也是可见的&lt;/p&gt;

&lt;p&gt;当然,这种方式组织的TODO事项就会分散在你的记录文件的各个地方. Org-mode通过提供各种函数(这些函数能够告诉你待办事项的这个概览情况)来补偿这一点.&lt;/p&gt;

&lt;h2 id=&#34;最基本的todo功能-标记和显示todo事项&#34;&gt;最基本的TODO功能&lt;/h2&gt;

&lt;p&gt;任何以·TODO·卡头的标题都被认为是TODO事项，例如&lt;/p&gt;

&lt;p&gt;#＋BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;:   *** TODO Write letter to Sam Fortune&lt;/p&gt;

&lt;p&gt;#＋END_SRC&lt;/p&gt;

&lt;p&gt;关于TODO事项最重要的命令有：&lt;/p&gt;

&lt;p&gt;* C-c C-t (org-todo) ::&lt;/p&gt;

&lt;p&gt;	 让当前事项的TODO状态在`无` `TODO`和`DONE`之间切换&lt;/p&gt;

&lt;p&gt;	 在timeline和agenda缓存区中,使用t命令键也能够实现这样的切换(参见&lt;a href=&#34;#Commands in the agenda buffer&#34; title=&#34;agenda缓存区中的命令&#34;&gt;agenda缓存区中的命令&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;* C-u C-c C-t ::&lt;/p&gt;

&lt;p&gt;					使用补全方式或快速选择界面(需要设置)来选择特定的TODO关键字, 若要使用快速选择界面,你需要給每个TODO状态分配快捷键,更多信息,参见&lt;a href=&#34;#Setting up keywords for individual files&#34; title=&#34;为各个文件分配TODO关键字&#34;&gt;为各个文件分配TODO关键字&lt;/a&gt;和&lt;a href=&#34;#Setting tags&#34; title=&#34;设置tags&#34;&gt;设置tags&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;* S-&lt;right&gt;  /  S-&lt;left&gt; ::&lt;/p&gt;

&lt;p&gt;		循环选择下一个/上一个TODO状态. 在事项有超过两个TODO状态的时候最有用(参见章节&lt;a href=&#34;#Extended use of TODO keywords&#34; title=&#34;扩展TODO关键字&#34;&gt;扩展TODO关键字&lt;/a&gt;). 要了解`shift-selection-mode`对改名了的而影响,参见章节&lt;a href=&#34;#Packages that lead to conflicts with Org mode&#34; title=&#34;与Org mode冲突的包&#34;&gt;与Org mode冲突的包&lt;/a&gt;.参见变量`org-treat-S-cursor-todo-selection-as-state-change`变量的说明&lt;/p&gt;

&lt;p&gt;* C-c / t (org-show-todo-key) ::&lt;/p&gt;

&lt;p&gt;		在一个&lt;a href=&#34;#sparse tree&#34; title=&#34;sparse tree&#34;&gt;sparse tree&lt;/a&gt;中查看TODO事项. 这回折叠起整个buffer只显示所有的未完成事项及其标题. 在命令前加上前缀(C-u C-c / t)可用搜索指定的TODO状态,你会被要求输入需要搜索的TODO状态(可用&#39;KWD1|KWD2&#39;的形式输入多个TODO状态),命令会列出匹配的所有事项. 如果调用该命令时附加了一个数字型的前缀参数N,则会匹配变量`org-to-keywords`中的第N个TODO状态. 如果调用该命令时加了两个前缀参数,则所有未完成和已完成的事项都会被找出来&lt;/p&gt;

&lt;p&gt;* C-c a t (org-todo-list) ::&lt;/p&gt;

&lt;p&gt;		显示全局的TODO列列表,从所有加入agenda的文件(参见&lt;a href=&#34;Agenda views&#34; title=&#34;Agenda视图&#34;&gt;Agenda视图&lt;/a&gt;)中收集所有的未完成事项到一个缓冲区中. 这个新buffer会处于agenda-mode,agenda-mode提供了很多命令来查看,操作buffer中的这些TODO事项(参见章节&lt;a href=&#34;#Commands in the agenda buffer&#34; title=&#34;agenda buffer中的命令&#34;&gt;agenda buffer中的命令&lt;/a&gt;). 更多信息请见章节&lt;a href=&#34;#The global TODO list&#34; title=&#34;全局代办列表&#34;&gt;全局代办列表&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;* S-M-&lt;RET&gt; (org-insert-todo-heading) ::&lt;/p&gt;

&lt;p&gt;		在当前TODO事项下面增加一个新的TODO事项&lt;/p&gt;

&lt;p&gt;改变TODO状态也会触发tag改变事件. 细节方面请参见选型&#39;org-todo-state-tags-triggers&#39;的docstring&lt;/p&gt;

&lt;h2 id=&#34;扩充todo关键字-工作流和委派&#34;&gt;扩充TODO关键字&lt;/h2&gt;

&lt;p&gt;默认情况下,TODO事项只有两种状态:TODO和DONE. Org-mode允许你通过设置`TODO 关键字`来对自己的TODO事项进行划分.(保存在`org-todo-keywords`中). 不同的文件可用有自己独特的TODO关键字设置.&lt;/p&gt;

&lt;p&gt;需要注意的是可用通过打tag的方式来对标题和TODO事项进行区分(参见章节&lt;a href=&#34;#Tags&#34; title=&#34;Tag&#34;&gt;Tag&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&#34;标示工作流状态的todo关键字-一步步的从todo状态演化到done状态&#34;&gt;标示工作流状态的TODO关键字&lt;/h3&gt;

&lt;p&gt;	你可以使用TODO关键字来标示事项处于工作流程中的不同状态.例如[fn:45]&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;(setq org-todo-keywords&lt;/p&gt;

&lt;p&gt;&#39;((sequence &#34;TODO&#34; &#34;FEEDBACK&#34; &#34;VERIFY&#34; &#34;|&#34; &#34;DONE&#34; &#34;DELEGATED&#34;)))&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;p&gt;	这个`|`竖线划分了哪些状态是属于未完结状态,哪些状态是出于已完结状态. 如果你没有提供分隔线,那么最后那个状态被认为是已完结状态. 通过上面这个配置之后,当用命令`C-c C-t`切换状态时,会先从TODO切换到FEEDBACK,然后是FEEDBACK,最后是DONE和DELEGATED状态. 你也可以使用数字前缀来快速选择特定的状态,例如`C-3 C-c C--t`会使得状态立即编程VERIFY. 你也可以使用`S-&lt;left&gt;`来在这个序列中回退状态. 如果你定义了太多的状态,你可以使用in-buffer补全(参见&lt;a href=&#34;#Completion&#34; title=&#34;补全&#34;&gt;补全&lt;/a&gt;章节)甚至是单个特定的选择键(参见章节&lt;a href=&#34;#Fast access to TODO states&#34; title=&#34;快速设定TODO状态&#34;&gt;快速设定TODO状态&lt;/a&gt;)来插入特定的TODO状态. 你也可用设定当改变TODO状态时记录下当时的时间戳数据,更多信息请参见&lt;a href=&#34;#Tracking TODO state changes&#34; title=&#34;跟踪TODO状态的改变&#34;&gt;跟踪TODO状态的改变&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;标示类型的todo关键字-这件事情我来做-其他的由fred负责&#34;&gt;标示类型的TODO关键字&lt;/h3&gt;

&lt;p&gt;	你还可以使用TODO关键字标示事项的不同类型. 例如,你可能向标示有些事情是工作事项,有些事情是生活事项. 或者当你与其他人共同合作一个项目时,你可能想分派任务給某个人,这时你可以直接把那些人的名字当作TODO关键字来使用. 配置可能如下所示&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;,(setq org-todo-keywords &#39;((type &#34;Fred&#34; &#34;Sara&#34; &#34;Lucy&#34; &#34;|&#34; &#34;DONE&#34;)))&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;p&gt;	这时,这些关键字并不是用来标示工作流程中的不同状态的,它们被用来标示不同的类型. 所以这个时候的工作流程是:先把任务分配給某个人,然后等这件事完成了之后,再标记它为DONE状态. 它也支持使用命令`C-c C-t`[fn:46]来切换状态. 若你连续按几次`C-c C-t`的话(经过了一个循环之后),`C-c C-t`会变回去,再不同人物之间切换循环. 而当你中断了连续的`C-c C-t`做了其他操作之后之后,再按`C-c C-t`,该命令又变回从人物直接跳到DONE状态了. 同样的,你也可以用前缀参数或补完功能来快速选择特定的人物. 你还可以通过在sparse tree中查看某个特定人物的所有代办事项,方法是在`C-c / t`前加前缀的数字参数. 例如,如果你想看分配給Lucy的所有事项,你可以用命令`C- C-c / t`来查看. 同样的道理,若你想在一个单独的buffer中查看Lucy在agenda中各org文件记录的代办事项,你可以用命令`C- C-c a t`&lt;/p&gt;

&lt;h3 id=&#34;在一个文件中设置多个关键字-混用所有关键字&#34;&gt;在一个文件中设置多个关键字&lt;/h3&gt;

&lt;p&gt;	有时候,你可能想使用平行的多个TODO关键字集合. 举个例子来说,你可能向保留有基本的`TODO/DONE`,但是同时需要为bug修复定义一套工作流程状态,并且你还需要一个独立的状态表示事项已经被取消了(这是事项的状态不能是DONE,但是它也没有下一步的行动了). 这时你的配置可能如下&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;(setq org-todo-keywords&lt;/p&gt;

&lt;p&gt;&#39;((sequence &#34;TODO&#34; &#34;|&#34; &#34;DONE&#34;)&lt;/p&gt;

&lt;p&gt;(sequence &#34;REPORT&#34; &#34;BUG&#34; &#34;KNOWNCAUSE&#34; &#34;|&#34; &#34;FIXED&#34;)&lt;/p&gt;

&lt;p&gt;(sequence &#34;|&#34; &#34;CANCELED&#34;)))&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;p&gt;	各个平行的关键字集合之间的关键字不能出现重复,因为Org-mode需要根据该关键字决定该事项是属于哪种流程状态的. 这样子配置之后,`C-c C-t`只会在各个子序列内部循环切换状态,在这个例子中,`DONE`会先切换到`无`再切换到`TODO`,`FIXED`会切换到`无`再切换到`REPORT`. 因此你需要一种方法来让你在最初选择错误的时候可以切换到其他平行的子序列中. 除了直接敲入关键字或者使用补全功能选择关键字之外,你还可以通过以下命令实现这个目的:&lt;/p&gt;

&lt;p&gt;	* C-u C-u C-c C-t / C-S-&lt;right&gt; / C-S-&lt;left&gt; ::&lt;/p&gt;

&lt;p&gt;	  这些按键会从一个TODO子序列跳到下一个TODO子序列中,在上一个例子中,`C-u C-u C-c C-t`和`C-S-&lt;right&gt;`会从`TODO`或`DONE`直接跳到`REPORT`状态,然后跳到`CANCELED`状态. 需要注意,这里`C-S-&lt;key&gt;`的键绑定是和`shift-selection-mode&lt;a href=&#34;# Packages that lead to conflicts with Org mode&#34; title=&#34;与Org-mode冲突的包&#34;&gt;与Org-mode冲突的包&lt;/a&gt;`冲突的&lt;/p&gt;

&lt;p&gt;	* S-&lt;right&gt; / S-&lt;left&gt; ::&lt;/p&gt;

&lt;p&gt;		 这俩命令会遍历所有子序列中的所有关键字,因此S-&lt;right&gt;会从`TODO`到`DONE`再到`REPORT`. 同样的,它也可能与`shift-selection-mode`有冲突,更多细节参见&lt;a href=&#34;#Packages that lead to conflicts with Org mode&#34; title=&#34;与Org-mode冲突的包&#34;&gt;与Org-mode冲突的包&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;快速选择todo状态-通过单个字母快速选择todo状态&#34;&gt;快速选择TODO状态&lt;/h3&gt;

&lt;p&gt;如果你想快速改变事项的状态为某个状态,而不是在各个状态之间遍历,你可以为每个状态指定一个单字母的快捷键. 方法是在每个状态后面加上用括号括住的快捷键.像这样:&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;(setq org-todo-keywords&lt;/p&gt;

&lt;p&gt;&#39;((sequence &#34;TODO(t)&#34; &#34;|&#34; &#34;DONE(d)&#34;)&lt;/p&gt;

&lt;p&gt;(sequence &#34;REPORT(r)&#34; &#34;BUG(b)&#34; &#34;KNOWNCAUSE(k)&#34; &#34;|&#34; &#34;FIXED(f)&#34;)&lt;/p&gt;

&lt;p&gt;(sequence &#34;|&#34; &#34;CANCELED(c)&#34;)))&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;你键入`C-c C-t`然后输入状态的快捷键就会立即切换到指定的状态了. 如果你想去掉事项上的状态标识,则用`空格`代替快捷键[fn:47]&lt;/p&gt;

&lt;h3 id=&#34;为各个文件设置独立的关键字-不同的文件有不同的需求&#34;&gt;为各个文件设置独立的关键字&lt;/h3&gt;

&lt;p&gt;很多时候我们需要为不同的文件设置不同的TODO关键字. 通过增加一些特殊的行,你可以为每个文件设置自己独有的TODO关键字. 例如,你可以在文件的任何一行定格写&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+TODO: TODO FEEDBACK VERIFY | DONE CANCELED&lt;/p&gt;

&lt;p&gt;,#+TYP_TODO: Fred Sara Lucy Mike | DONE&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;(你也可以使用`#+SEQ_TODO`,它的意思跟`#+TODO`一样,但是表达更清晰)&lt;/p&gt;

&lt;p&gt;若需要定义多个平行的子序列,则这样配置:&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+TODO: TODO | DONE&lt;/p&gt;

&lt;p&gt;,#+TODO: REPORT BUG KNOWNCAUSE | FIXED&lt;/p&gt;

&lt;p&gt;,#+TODO: | CANCELED&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;你可以用补全的方式保证输入的关键字无误,方法是输入`#+`然后按下`M-&lt;TAB&gt;`&lt;/p&gt;

&lt;p&gt;请注意,`|`后面的状态关键字(如果没有`|`则最后一个关键字)必须是代表完结状态的关键字(不一定需要DONE). 在输入完这些以`#+`开头的配置信息后,在配置信息行按下`C-c C-c`使该行的配置信息生效[fn:48]&lt;/p&gt;

&lt;h3 id=&#34;键字的显示方式-高亮状态&#34;&gt;&lt;span class=&#34;todo TODO&#34;&gt;TODO&lt;/span&gt; 键字的显示方式&lt;/h3&gt;

&lt;p&gt;Org-mode为不同的状态关键字分配了不同的显示方式(emacs中大概是以face这个概念来表示显示方式). 默认情况下对于那些表示还未完结状态的状态关键字使用`org-todo`这个face,对于那些表示已完结状态的状态关键字使用`org-done`这个face. 如果你用到了2个以上的不同类别的状态,你可以通过配置变量`org-todo-keyword-faces`来为不同的状态关键字分配不同的face. 举个例子&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;(setq org-todo-keyword-faces&lt;/p&gt;

&lt;p&gt;&#39;((&#34;TODO&#34; . org-warning) (&#34;STARTED&#34; . &#34;yellow&#34;)&lt;/p&gt;

&lt;p&gt;(&#34;CANCELED&#34; . (:foreground &#34;blue&#34; :weight bold))))&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;像上面例子中`CANCELED`关键字这样直接定义face属性列表的方式,有可能不能正确的显示出来. 所以最好还是定义一个face然后使用它. 像`STARTED`这样,后面输入的是一个字符串的话,该字符串被解释成是颜色. 而变量`orgfaceseasyproperties`定义了改颜色是前景色还是背景色.&lt;/p&gt;

&lt;h3 id=&#34;项之间的依赖关系-当一个任务需要等待其他任务的时候&#34;&gt;&lt;span class=&#34;todo TODO&#34;&gt;TODO&lt;/span&gt; 项之间的依赖关系&lt;/h3&gt;

&lt;p&gt;Org文件是由层级关系和列表组成的,这样的结构使得定义代办事项之间的依赖关系变得很容易. 通常在所有子任务完成之前是不能把父任务标记为完成状态的. 同时平级任务之间也可能存在一定的逻辑关系,使得后面的任务需要等待前面的任务都完成之后才能完成. 通过定义变量`org-enforce-todo-dependencies`,Org会阻止父任务在其子任务全部都完结的情况下被标记为完结状态. 此外,如果某个事项定义了`ORDERED`属性,那么它的子任务只有在前面子任务都完成之后才能被标识为已完成状态.下面是一个例子&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* TODO Blocked until (two) is done&lt;/p&gt;

&lt;p&gt;,** DONE one&lt;/p&gt;

&lt;p&gt;,** TODO two&lt;/p&gt;

&lt;p&gt;,* Parent&lt;/p&gt;

&lt;p&gt;,  :PROPERTIES:&lt;/p&gt;

&lt;p&gt;,  :ORDERED: t&lt;/p&gt;

&lt;p&gt;,  :END:&lt;/p&gt;

&lt;p&gt;,** TODO a&lt;/p&gt;

&lt;p&gt;,** TODO b, needs to wait for (a)&lt;/p&gt;

&lt;p&gt;,** TODO c, needs to wait for (a) and (b)&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;* C-c C-x o (orgtoggleorderedproperty) ::&lt;/p&gt;

&lt;p&gt;打开/关闭当前事项的`ORDERED`属性. 之所以要用给事项定义属性的方式来声明这种顺次的逻辑关系是因为这种逻辑关系往往只是对某项任务是这样的,它不像tag一样具有继承的特性. 当然如果你觉得属性常常被折叠起来不容易看到的话,也可以使用tag来跟踪该属性的变化,方法是定义变量`org-track-ordered-property-with-tag`.&lt;/p&gt;

&lt;p&gt;* C-u C-u C-u C-c C-t ::&lt;/p&gt;

&lt;p&gt;	 绕开状态的那些限制,强制更改TODO状态&lt;/p&gt;

&lt;p&gt;如果你设置了变量`org-agenda-dim-blocked-tasks`, 那么那些由于依赖关系未满足而无法关闭的代办事项在agenda视图中以灰色字体显示甚至是不显示(参见章节&lt;a href=&#34;#Agenda view&#34; title=&#34;Agenda视图&#34;&gt;Agenda视图&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;你也可以使得这种依赖关系对于checkbox也有效(参见章节&lt;a href=&#34;#Checkboxes&#34; title=&#34;checkbox&#34;&gt;checkbox&lt;/a&gt;).你可以设置变量`org-enforce-todo-checkbox-dependencies`. 然后如果某事项有未勾选掉的checkbox的话,也无法切换成完结状态&lt;/p&gt;

&lt;p&gt;如果你需要更复杂的依赖关系(例如在不同的树n型结果或文件之间的依赖关系),请使用`org-depend.el`模块&lt;/p&gt;

&lt;h2 id=&#34;记录处理过程-记录处理过程的时间点和附加信息&#34;&gt;记录处理过程&lt;/h2&gt;

&lt;p&gt;Org-mode可以在你把代办事项从未完结状态切换到完结状态的时候记录下时间戳和其他一些信息,你甚至可以让它在每次切换状态的时候就记录下这些信息. 这套系统具有很高的可配置性,你可以对某个关键字,或某个文件甚至某个子树范围进行这样的配置. 要了解如何为事项统计所花的工作时间,可以参见章节&lt;a href=&#34;#Clocking work time&#34; title=&#34;统计工作时间&#34;&gt;统计工作时间&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;结束任务-你是什么时候结束这项任务的&#34;&gt;结束任务&lt;/h3&gt;

&lt;p&gt;	能够跟踪某任务什么时候完成是最基本的记录功能. 这项功能可以通过下面这条语句开启[fn:49]&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;(setq org-log-done &#39;time)&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;p&gt;	之后,每次你把一项未完结状态的任务切换到已完结状态的时候,都会在该任务标题下插入一行`CLOSED:[时间戳]`. 如果你把该任务状态又切换回未完结状态,这一行会被删除掉. 如果你希望除了记录时间戳还可以记录一些附加信息,配置[fn:50]&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;(setq org-log-done &#39;note)&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;p&gt;	这样当你把未完结状态的任务切换到已完结状态时,会被提示输入要保存的附加信息,该附加信息会存储在该任务下面,并以`Closing Note`开头&lt;/p&gt;

&lt;p&gt;	在timeline(参见章节&lt;a href=&#34;#Timeline for a single file&#34; title=&#34;单个文件的Timeline&#34;&gt;单个文件的Timeline&lt;/a&gt;)和agenda(参见章节&lt;a href=&#34;The weekly/daily agenda&#34; title=&#34;周/日agenda&#34;&gt;周/日agenda&lt;/a&gt;)视图中,你可以使用`l`键来显示每日带有&#39;CLOSED&#39;时间戳的代办事项,它会给你一个已完成事项的总括&lt;/p&gt;

&lt;h3 id=&#34;跟踪任务状态-什么时候任务状态发生了改变&#34;&gt;跟踪任务状态&lt;/h3&gt;

&lt;p&gt;	有时候你可能想跟踪任务什么时候状态发生了改变,可能还想在状态发生改变的时候记录一些附加信息. 这些信息在插入时会插入到该事项标题的后面作为最新的信息列在第一排[fn:51]. 如果记录的附加信息太长了的话,你可能会希望把这些附加信息放入一个&#39;抽屉&#39;(&lt;a href=&#34;#Drawers&#34; title=&#34;drawer&#34;&gt;drawer&lt;/a&gt;)中. 要实现这一点,需要配置变量`org-log-into-drawer`--推荐使用名为`LOGBOOK`的drawer. 若你想为某个子树设置其他的drawer方式,你可以为这个子树定义`LOG_INTO_DRAWER`属性.&lt;/p&gt;

&lt;p&gt;	Org-mode可以为每个TODO关键字定义记录时间戳和附加信息的行为. 你可以在关键字后面用括号括住`!`(表示记录时间戳)或者`@`(表示记录时间戳和附加信息).下面是一个配置的例子&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;(setq org-todo-keywords&lt;/p&gt;

&lt;p&gt;&#39;((sequence &#34;TODO(t)&#34; &#34;WAIT(w@/!)&#34; &#34;|&#34; &#34;DONE(d!)&#34; &#34;CANCELED(c@)&#34;)))&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;p&gt;	如果你想对配置了`@`的关键字只记录时间戳,不记录附加信息的话,只需要在提示输入附加信息的时候直接按下`C-c C-c`就行,这会提交一个空白的附加信息&lt;/p&gt;

&lt;p&gt;	在上面的例子中,你不仅定义了全局的TODO关键字,定义了它们的快捷键,而且你还指定了当事项设置为`DONE`状态的时候,记录下当时的时间戳[fn:52]. 当事项状态改为`WAIT`或`CANCELED`的时候,会提示记录下附加信息. 注意到`WAIT`状态有一个`/!`标志,这表示当离开WAIT状态进入到一个不记录任何信息的状态的时候,记录下当时的时间戳. 也就是说,当从`WAIT`切换到`DONE`状态的时候,并不触发记录时间戳的动作,因为DONE已经被配置为记录时间戳了. 而当从WAIT切换到TODO状态的时候,WAIT状态的`/!`设置会触发记录一个时间戳的动作,因为TODO并没有配置任何记录动作&lt;/p&gt;

&lt;p&gt;	你也可以把上面的设置限定到一个buffer中,方法是在buffer某行定格写&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+TODO: TODO(t) WAIT(w@/!) | DONE(d!) CANCELED(c@)&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;p&gt;	如果只想为某个子树或者某一个事项定义记录动作,你需要为改子树或者事项定义`LOGGING`属性. 如果你定义了非空的`LOGGING`属性,那么原先的记录动作的设置会被清空. 在配置`LOGGING`属性的时候,你可以使用`STARTUP`关键字(例如`lognotedone`或`logrepeat`).也可以明确指定为每个状态指定不同的记录设置(例如`TODO(!)`). 下面是一个例子&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* TODO Log each state with only a time&lt;/p&gt;

&lt;p&gt;,  :PROPERTIES:&lt;/p&gt;

&lt;p&gt;,  :LOGGING: TODO(!) WAIT(!) DONE(!) CANCELED(!)&lt;/p&gt;

&lt;p&gt;,  :END:&lt;/p&gt;

&lt;p&gt;,* TODO Only log when switching to WAIT, and when repeating&lt;/p&gt;

&lt;p&gt;,  :PROPERTIES:&lt;/p&gt;

&lt;p&gt;,  :LOGGING: WAIT(@) logrepeat&lt;/p&gt;

&lt;p&gt;,  :END:&lt;/p&gt;

&lt;p&gt;,* TODO No logging at all&lt;/p&gt;

&lt;p&gt;,  :PROPERTIES:&lt;/p&gt;

&lt;p&gt;,  :LOGGING: nil&lt;/p&gt;

&lt;p&gt;,  :END:&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;h3 id=&#34;跟踪你的习惯-你能坚持习惯多久&#34;&gt;跟踪你的习惯&lt;/h3&gt;

&lt;p&gt;	Org可以用来追踪习惯的一致性,这里所谓的&#34;习惯&#34;指的是拥有下列特征的待办事项.&lt;/p&gt;

&lt;p&gt;	1) 通过配置变量`org-modules`,启用了`habits`模块&lt;/p&gt;

&lt;p&gt;	2) 是一个未完成的任务,有一个未完成的状态标示该任务有下一步的行动&lt;/p&gt;

&lt;p&gt;	3) `STYLE`属性值设置成了`habit`&lt;/p&gt;

&lt;p&gt;	4) 该事项带有规划日期,而且规划日期中可以有`.+时间间隔`用来表示两次重复之间的间隔. `++时间间隔`表示该习惯有时间上的约束(比如,必须在周末完成),`+时间间隔`则表示改习惯不是一个经常性的事项,它可以在之前积压未办之事,然后在未来补完它(比如补写周报)&lt;/p&gt;

&lt;p&gt;	5) 改习惯也可以使用类似`.+2d/3d`这样的符号标示最小/最大的间隔时间. `.+2d/3d`的意思是,你希望至少每三条做一次这个工作,但是最多每两天做一次这个工作&lt;/p&gt;

&lt;p&gt;	6) 你最好为完结状态设置记录行为,这样会保留一些历史数据,这些历史数据可以以连线图的方式展现出来. 你不是必须要这样做,但是由此产生的连线图的意义就不大了.&lt;/p&gt;

&lt;p&gt;	为了给你一个直观的感受,下面展示一个带有历史数据的习惯的例子&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,** TODO Shave&lt;/p&gt;

&lt;p&gt;,   SCHEDULED: &lt;2009-10-17 Sat .+2d/4d&gt;&lt;/p&gt;

&lt;p&gt;,   - State &#34;DONE&#34;       from &#34;TODO&#34;       [2009-10-15 Thu]&lt;/p&gt;

&lt;p&gt;,   - State &#34;DONE&#34;       from &#34;TODO&#34;       [2009-10-12 Mon]&lt;/p&gt;

&lt;p&gt;,   - State &#34;DONE&#34;       from &#34;TODO&#34;       [2009-10-10 Sat]&lt;/p&gt;

&lt;p&gt;,   - State &#34;DONE&#34;       from &#34;TODO&#34;       [2009-10-04 Sun]&lt;/p&gt;

&lt;p&gt;,   - State &#34;DONE&#34;       from &#34;TODO&#34;       [2009-10-02 Fri]&lt;/p&gt;

&lt;p&gt;,   - State &#34;DONE&#34;       from &#34;TODO&#34;       [2009-09-29 Tue]&lt;/p&gt;

&lt;p&gt;,   - State &#34;DONE&#34;       from &#34;TODO&#34;       [2009-09-25 Fri]&lt;/p&gt;

&lt;p&gt;,   - State &#34;DONE&#34;       from &#34;TODO&#34;       [2009-09-19 Sat]&lt;/p&gt;

&lt;p&gt;,   - State &#34;DONE&#34;       from &#34;TODO&#34;       [2009-09-16 Wed]&lt;/p&gt;

&lt;p&gt;,   - State &#34;DONE&#34;       from &#34;TODO&#34;       [2009-09-12 Sat]&lt;/p&gt;

&lt;p&gt;,   :PROPERTIES:&lt;/p&gt;

&lt;p&gt;,   :STYLE:    habit&lt;/p&gt;

&lt;p&gt;,   :LAST_REPEAT: [2009-10-19 Mon 00:36]&lt;/p&gt;

&lt;p&gt;,   :END:&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;p&gt;	这个例子的意思是:我希望最多每两天,最少每4天做一次这个事情(通过`SCHEDULED`日期和重复的时间间隔给定了). 假设今天是15号,那么在agenda中,该习惯会在17号(也就是2天之后)的地方显示生效. 在19号(也就是4天之后)的地方实效&lt;/p&gt;

&lt;p&gt;	把习惯用折线图展示出来可以显示在过去你坚持这项习惯的情况如何. 这个折线图显示了过去三个星期每天该习惯的完成情况,每天都根据完成情况用不同的颜色显示出来. 这些颜色有:&lt;/p&gt;

&lt;p&gt;	* 蓝色 ::&lt;/p&gt;

&lt;p&gt;	  表示当天任务没有完成&lt;/p&gt;

&lt;p&gt;	* 绿色 ::&lt;/p&gt;

&lt;p&gt;	  表示当天任务已经完成&lt;/p&gt;

&lt;p&gt;	* 黄色 ::&lt;/p&gt;

&lt;p&gt;	  表示任务在第二天就会过期了&lt;/p&gt;

&lt;p&gt;	* 红色 ::&lt;/p&gt;

&lt;p&gt;	  表示工作在当天已经延误了&lt;/p&gt;

&lt;p&gt;	另外除了用颜色标注每天的任务完成情况之外,弱于哪些任务在当天已经完成的任务会用星号标注出来. 会用感叹号标注当前日期出来.&lt;/p&gt;

&lt;p&gt;	org提供很多变量来改变agenda显示habit的方式&lt;/p&gt;

&lt;p&gt;	* org-habit-graph-column ::&lt;/p&gt;

&lt;p&gt;	  设定统计图从那一列开始画. 由于统计图会覆盖该列上的所有文本,因此最好保持你的habit标题简洁明了.&lt;/p&gt;

&lt;p&gt;	* org-habit-preceding-days ::&lt;/p&gt;

&lt;p&gt;	     指定从几天前开始统计数据&lt;/p&gt;

&lt;p&gt;	* org-habit-following-days ::&lt;/p&gt;

&lt;p&gt;	  指示统计到几天之后的数据&lt;/p&gt;

&lt;p&gt;	* org-habit-show-habits-only-for-today ::&lt;/p&gt;

&lt;p&gt;	     如果为非nil值的话,表示只在当天的agenda视图中显示habits. 默认情况下是设置为true的&lt;/p&gt;

&lt;p&gt;	最后,在agenda视图中按下`k`键会暂时让habit隐藏掉. 按&#39;K&#39;之后又会让habit显示出来. 它们也受到tag过滤的影响,例如你可以设定habit只能在某种特定的情况下才能被标记为完成.&lt;/p&gt;

&lt;h2 id=&#34;优先级-有些事情更重要一些&#34;&gt;优先级&lt;/h2&gt;

&lt;p&gt;如果你经常使用Org-mode来进行任务安排的话,就应该会发现对各项任务分配优先级是很有必要的,方法是在TODO事项的标题前放上优先级标识(` &lt;em&gt;priority cookie&lt;/em&gt; `),像这样:&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,*** TODO [#A] Write letter to Sam Fortune&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;默认情况下,Org-mode支持从高到低三个优先级,分别表示为`A`,`B`,`C`. 如果某个任务没有分配优先级,则被认为是`B`优先级. 为任务分配优先级的意义仅仅在于在agenda视图(参见&lt;a href=&#34;The weekly/daily agenda&#34; title=&#34;周/日agenda&#34;&gt;周/日agenda&lt;/a&gt;)中可以依照优先级对任务进行排序. 通过定义变量`org-priority-faces`,你可以为不同的优先级分配不同的显示方式(face)&lt;/p&gt;

&lt;p&gt;优先级标识可以放在任何大纲节点前,而不一定要放在TODO事项前&lt;/p&gt;

&lt;p&gt;* C-c , ::&lt;/p&gt;

&lt;p&gt;设置当前任务的优先级(`org-priority`). 执行该命令后,会提示你输入代表优先级的`A` `B` `C`. 如果你输入的是&lt;SPC&gt;则标识去除任务中的优先级标识. 若你在timeline或agenda视图中时,则可以使用`,`命令来改变优先级.(参见章节&lt;a href=&#34;Commands in the agenda buffer&#34; title=&#34;agenda视图中的命令&#34;&gt;agenda视图中的命令&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;* S-&lt;up&gt; (org-priority-up) / S-&lt;down&gt; (org-priority-down) ::&lt;/p&gt;

&lt;p&gt;		提升/降低当前任务的优先级[fn:53]. 需要注意的时,这些键也同样可以用来改变时间戳(参见章节&lt;a href=&#34;Creating timestamps&#34; title=&#34;创造时间戳&#34;&gt;创造时间戳&lt;/a&gt;). 同样这些按键也可能与`shift-selection-mode`相互冲突,具体情况参见&lt;a href=&#34; Packages that lead to conflicts with Org mode&#34; title=&#34;与Org-mode冲突的包&#34;&gt;与Org-mode冲突的包&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通过设置变量`org-highest-priority`,`org-lowest-priority`和`org-default-priority`的值,你可以自定义优先级的区间. 若想对某个文件设置优先级区间,你可以像下面那样设置(准照最高优先级,最低优先级,默认优先级的顺序来设置,同时请确保最高优先级在字母表上要比最低优先级靠前)&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+PRIORITIES: A C B&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;h2 id=&#34;划分子任务-划分任务为可管理的碎片&#34;&gt;划分子任务&lt;/h2&gt;

&lt;p&gt;将一件很复杂的任务分解为简单一些,更易管理的子任务是很有必要的. 你可以在任务事项下面创建新的子树大纲(子任务作为子树的各节点)的方式来表达这种分层关系[fn:54]. 若你想在父任务上显示子任务完成的情况,可以在父任务标题的任何地方插入`[/ ]`或`[% ]`. 每当有子任务被标识为已完结状态之后,这两个标识会被更新为子任务的完成进度,在这两个标识上按下`C-c C-c`也能够强制更新这两个标识的信息.下面是一个例子:&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* Organize Party [33%]&lt;/p&gt;

&lt;p&gt;,** TODO Call people [1/2]&lt;/p&gt;

&lt;p&gt;,*** TODO Peter&lt;/p&gt;

&lt;p&gt;,*** DONE Sarah&lt;/p&gt;

&lt;p&gt;,** TODO Buy food&lt;/p&gt;

&lt;p&gt;,** DONE Talk to neighbor&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;如果一个任务标题下面既有check列表,也有代办的TODO子任务,那么org就不清楚应该怎么统计子任务的完成情况了. 这时需要设置属性`COOKIE_DATA`的值为`checkbox`或者`todo`来明确指示统计时以哪个为准&lt;/p&gt;

&lt;p&gt;如果你想在统计子任务完成情况的时候,不是仅仅统计直接下属的子任务的情况,而是统计所有层级的下属子任务,那么你需要配置变量`org-hierarchical-todo-statistics`. 如果你只是对某个特定的父任务有这种需求,那么为该父任务设置`COOKIE_DATA`属性,并且确保该属性的值包含有`recursive`. 下面是一个例子&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* Parent capturing statistics [2/20]&lt;/p&gt;

&lt;p&gt;,  :PROPERTIES:&lt;/p&gt;

&lt;p&gt;,  :COOKIE_DATA: todo recursive&lt;/p&gt;

&lt;p&gt;,  :END:&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;如果你希望父任务在所有子任务都标记为完结状态后,自动也切换到完结状态,你可以用下面所示的配置:&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;(defun org-summary-todo (n-done n-not-done)&lt;/p&gt;

&lt;p&gt;&#34;Switch entry to DONE when all subentries are done, to TODO otherwise.&#34;&lt;/p&gt;

&lt;p&gt;(let (org-log-done org-log-states)   ; turn off logging&lt;/p&gt;

&lt;p&gt;(org-todo (if (= n-not-done 0) &#34;DONE&#34; &#34;TODO&#34;))))&lt;/p&gt;

&lt;p&gt;(add-hook &#39;org-after-todo-statistics-hook &#39;org-summary-todo)&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;当然,你也可以使用check列表代替子任务的作用&lt;/p&gt;

&lt;h2 id=&#34;checkbox-标记列表&#34;&gt;checkbox&lt;/h2&gt;

&lt;p&gt;如果一个事项是不是以标题的形式而是以纯文本列表[fn:55](参见&lt;a href=&#34;Plain lists&#34; title=&#34;纯文本列表&#34;&gt;纯文本列表&lt;/a&gt;)的形式展现的,同时它又是以`[ ]`开头的,那么它就被当成是一个代检查事项(checkbox)看待. checkbox跟待办事项(参见&lt;a href=&#34;TODO iterms&#34; title=&#34;待办事项&#34;&gt;待办事项&lt;/a&gt;)很类似,但是相比起来更加的轻量化.  checkbox不回显示在全局的未完成事项列表(TODO列表)中,因此它常常用来表示将一个任务分隔成几个简单的步骤,或者用来作为待购清单来使用. 要切换checkbox的状态(完成/未完成状态),需要按下`C-c C-c`,或者使用鼠标点击(多亏了Piotr Zielinski的`org-mouse.el`)&lt;/p&gt;

&lt;p&gt;下面是一个checkbox列表的例子&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* TODO Organize party [2/4]&lt;/p&gt;

&lt;p&gt;,  - [-] call people [1/3]&lt;/p&gt;

&lt;p&gt;,    - [ ] Peter&lt;/p&gt;

&lt;p&gt;,    - [X] Sarah&lt;/p&gt;

&lt;p&gt;,    - [ ] Sam&lt;/p&gt;

&lt;p&gt;,  - [X] order food&lt;/p&gt;

&lt;p&gt;,  - [ ] think about what music to play&lt;/p&gt;

&lt;p&gt;,  - [X] talk to the neighbors&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;checkbox具有继承的特性,因此如果一个checkbox具有子checkbox的话,对子checkbox的完成状态进行切换的时候,父checkbox也会自动根据是没有/部分/全部子checkbox完成状况来做出相应的改变&lt;/p&gt;

&lt;p&gt;在上面例子中,第一行和第二行的`[2/4 ]`和`[1/3 ]`展示了一共有多少个checkbox,其中多少个checkbox一件完成了. 这使得你不用展开就能知道还剩下多少个checkbox没有完成. 这种统计信息的展示可以放在标题或者文本列表的任何地方,而且它只会统计直接子任务的完成情况[fn:56]. 为了得到这种统计信息的展示,你需要自己输入`[/ ]`或`[% ]`. 如果你使用的是`[/ ]`,那么你会得到`[n/m]`这样的展示方法(n表示已完成数,m表示未完成数). 如果你输入的是`[% ]`,那么你会得到一个百分比的展示. 若在标题的子树下,既有TODO事项,又有checkbox,那么展示的可能为TODO事项的统计结果(若触发改变的是由于子TODO事项的状态改变而引起的)也可能是checkbox的统计结果(若触发改变的结果是由于checkbox的状态改变引起的),这样就显得很混乱. 要解决这个问题,设置该标题的`COOKIE_DATA`属性值为`checkbox`或者`todo`即刻&lt;/p&gt;

&lt;p&gt;如果在当前的大纲节点上加了`ORDERED`属性,这就告诉orgcheckbox必须从上到下一个一个的被完结, 否则会有报错.&lt;/p&gt;

&lt;p&gt;关于checkbox的命令有以下这些:&lt;/p&gt;

&lt;p&gt;* C-c C-c (org-toggle-checkbox) ::&lt;/p&gt;

&lt;p&gt;	 切换光标所在checkbox的完结状态. 如果加了一个前置参数(也就是用按键`C-u C-c c-c`)则增加/移除checkbox标志(使它在checkbox和普通列表之间切换)[fn:57], 如果加了两个前置参数(`C-u C-u C-c C-c`)则checkbox的标志设为`[-]`,这种标志的意思是其为一种中间状态&lt;/p&gt;

&lt;p&gt;* C-c C-x C-b (org-toggle-checkbox) ::&lt;/p&gt;

&lt;p&gt;		切换光标所在checkbox的完结状态. 如果加了两个前置参数(`C-u C-u C-c C-c`)则checkbox的标志设为`[-]`,这种标志的意思是其为一种中间状态&lt;/p&gt;

&lt;p&gt;* M-s-&lt;RET&gt; (org-insert-todo-heading) ::&lt;/p&gt;

&lt;p&gt;	 插入一个新的checkbox,这只有当光标处于普通列表中时才有效(参见&lt;a href=&#34;Plain lists&#34; title=&#34;普通列表&#34;&gt;普通列表&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;* C-c C-x o (org-toggle-ordered-property) ::&lt;/p&gt;

&lt;p&gt;		切换是否具有`ORDERED`属性. 如果你希望能够以tag的形式来最终`ORDERED`属性的值,你可以设置变量`org-track-ordered-property-with-tag`&lt;/p&gt;

&lt;p&gt;* C-c # (org-update-statistics-cookies) ::&lt;/p&gt;

&lt;p&gt;		更新当前大纲项的统计信息, 若使用了`C-u`前缀,则更新整个文件的统计信息. 当你用`C-c C-c`切换一个checkbox的完结状态或者用`M-S-&lt;RET&gt;`新增加一个checkbox的时候,会自动更新checkbox的统计信息. 同样,当改变TODO事项的状态时,也会自动更新TODO事项的统计信息. 但是如果你删除checkbox和TODO事项,或者手工增加/修改checkbox和TODO事项,那你就需要手工调用这个命令,以强制同步更新统计数据&lt;/p&gt;

&lt;p&gt;	 *&lt;/p&gt;

&lt;h1 id=&#34;tags&#34;&gt;Tags&lt;/h1&gt;

&lt;p&gt;每个标题都可以包含多个tag; 这些tag应该放在标题的末尾位置. tag通常由字母,汉字,数字,-和@组成. tag的前后必须被冒号包括,像这样`:work:`. 可以同时指定多个tag,像这样`:work:urgent:`. tag默认是用跟标题一样的颜色,但是加粗显示. 你也可以为特定的tag定义特定的显示方式(face),方法是配置变量`org-tag-faces`, 这跟配置TODO关键字的face的方法差不多(参见&lt;a href=&#34;Faces for TODO keywords&#34; title=&#34;TODO关键字的显示方式&#34;&gt;TODO关键字的显示方式&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&#34;tag的继承特性-tag在大纲中具有继承的特性&#34;&gt;Tag的继承特性&lt;/h2&gt;

&lt;p&gt;tag具有继承的特性. 如果一个标题具有某个tag,那么它的所有子标题自动继承了这个tag,例如,&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* Meeting with the French group      :work:&lt;/p&gt;

&lt;p&gt;,** Summary by Frank                  :boss:notes:&lt;/p&gt;

&lt;p&gt;,*** TODO Prepare slides for him      :action:&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;上例中,最后那一行的标题虽然看起来只有一个tag,但是其实它有4个tag:`:work:`,`:boss:`,`:notes:`和`:action:`. 你也可以设置文件级的tag,这样所有该文件的标题,自动继承了这些文件级的tag. 方法为在文件中加入这样一行[fn:58]&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+FILETAGS: :Peter:Boss:Secret:&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果存在一个选择域,则切换该选择区域的第一个checkbox的完结状态,同时选择区域的其他checkbox的完结状态都改为以第一个checkbox的完结状态为准. 如果调用该命令时带了一个前置参数(`C-u C-c C-x C-b`)则增加/删除该区域中所有事项的checkbox标志&lt;/li&gt;
&lt;li&gt;如果对一个标题进行该操作, 则切换该标题到下一标题间的所有checkbox的状态(不是整个子树)&lt;/li&gt;
&lt;li&gt;如果没有选择区域,则切换光标所在的checkbox的状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你想只限定某几个tag具有继承性,或者根本就不想让tag具有继承性,那么你可以通过配置变量`org-use-tag-inheritance`和`org-tags-exclude-from-inheritance`来实现&lt;/p&gt;

&lt;p&gt;如果tag的继承特性被打开,那么在作tag搜索的时候,若某个父标题匹配了这次搜索,那么它的子树也同样匹配这次搜索[fn:59],这样的话,匹配列表恐怕就会过长. 如果你只想让子树中第一个匹配项可见,请配置变量`org-tags-match-list-sublevels`(我们不推荐这么做)&lt;/p&gt;

&lt;h2 id=&#34;设置tag-如何为标题分配tag&#34;&gt;设置Tag&lt;/h2&gt;

&lt;p&gt;你可以直接通过在标题后面输入tag的方式給标题打tag. 输入冒号之后,按下`M-&lt;TAB&gt;`,会提供对tag的补全. 你也可以用下面的命令来插入tag&lt;/p&gt;

&lt;p&gt;* C-c C-q (org-set-tags-command) ::&lt;/p&gt;

&lt;p&gt;	 为当前标题输入新的tag. Org-mode同时也提供补全功能,或給key设定单字符的快捷键,具体内容见下文. 在按下&lt;RET&gt;之后,就会插入tag,并且tag自动与`org-tags-column`代表的列对齐. 当调用时带了`C-u`前缀参数时, 当前buffer中的所有tag都会与该列对齐,这样会显得很工整. 另外,当你对标题进行升级/降级,或者改变TODO状态的时候,也会自动对齐tag的位置,参见章节&lt;a href=&#34;Basic TODO functionality&#34; title=&#34;最基本的TODO功能&#34;&gt;最基本的TODO功能&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;* C-c C-c (org-set-tags-command) ::&lt;/p&gt;

&lt;p&gt;		当光标位于标题上时,这个功能与`C-c C-q`一样.&lt;/p&gt;

&lt;p&gt;	Org在插入tag时维护了一个tag列表. 默认情况下,这个tag列表动态的包含了当前buffer中的所有tag. 你也可以通过变量`org-tag-alist`来设置一个全局的固定的tag列表. 当然你也可以单独为一个文件设置默认的tag列表.&lt;/p&gt;

&lt;p&gt;		#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+TAGS: @work @home @tennisclub&lt;/p&gt;

&lt;p&gt;,#+TAGS: laptop car pc sailboat&lt;/p&gt;

&lt;p&gt;		#+END_SRC&lt;/p&gt;

&lt;p&gt;	如果你通过变量`org-tag-alist`设置了一个全局的tag列表,但是在某些文件中,又希望能够动态获取tag列表,你只需要在文件中加入一个空白的TAG选项即刻&lt;/p&gt;

&lt;p&gt;		#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+TAGS:&lt;/p&gt;

&lt;p&gt;		#+END_SRC&lt;/p&gt;

&lt;p&gt;	如果你有一些tag是每个文件都要用到的,你可以把这些tag放入变量`org-tag-persistent-alist`中,这样org文件除了具有TAGS选项所设定的tag外,还具有这个变量所定义的那些tag. 如果某个文件不想包含该变量所定义的tag,只需要在STARTUP选项行中添加:&lt;/p&gt;

&lt;p&gt;		#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+STARTUP: noptag&lt;/p&gt;

&lt;p&gt;		#+END_SRC&lt;/p&gt;

&lt;p&gt;	默认情况下,Org-mode在输入tag时提供的是标准minibuffer补全方式. 然而其实它具有另一个更快捷的tag选择方法名叫`快速tag选择法(fast tag selection)`. 它可以让你只用一个按键就可以选择/取消一个tag. 为了让该方法能够很好的工作,你需要为你最常用的tag都分配唯一的单独键. 你可以通过在`.emacs`文件中配置变量`org-tag-alist`来实现. 例如你可能在许多文件中都会用到`:@home:`这个tag,你就可以这样定义&lt;/p&gt;

&lt;p&gt;		#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,(setq org-tag-alist &#39;((&#34;@work&#34; . ?w) (&#34;@home&#34; . ?h) (&#34;laptop&#34; . ?l)))&lt;/p&gt;

&lt;p&gt;		#+END_SRC&lt;/p&gt;

&lt;p&gt;	如果tag只是在当前文件中有效,你可以在文件中设置TAGS选项行像这样:&lt;/p&gt;

&lt;p&gt;		#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+TAGS: @work(w)  @home(h)  @tennisclub(t)  laptop(l)  pc(p)&lt;/p&gt;

&lt;p&gt;		#+END_SRC&lt;/p&gt;

&lt;p&gt;	插入tag时会在一个新窗口中显示可用的tag供你选择. 若你想在某个tag之后换行显示,你只需要在它之后插入`\n`即刻:&lt;/p&gt;

&lt;p&gt;		#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+TAGS: @work(w)  @home(h)  @tennisclub(t) \n laptop(l)  pc(p)&lt;/p&gt;

&lt;p&gt;		#+END_SRC&lt;/p&gt;

&lt;p&gt;	或者你也可用写成两行&lt;/p&gt;

&lt;p&gt;		#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+TAGS: @work(w)  @home(h)  @tennisclub(t)&lt;/p&gt;

&lt;p&gt;,#+TAGS: laptop(l)  pc(p)&lt;/p&gt;

&lt;p&gt;		#+END_SRC&lt;/p&gt;

&lt;p&gt;	用大括号括起来的tag,相互之间只能选择一个标识,例如&lt;/p&gt;

&lt;p&gt;		#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+TAGS: { @work(w)  @home(h)  @tennisclub(t) }  laptop(l)  pc(p)&lt;/p&gt;

&lt;p&gt;		#+END_SRC&lt;/p&gt;

&lt;p&gt;	上面的例子说明了,最多只能选择`@work`,`@home`和`@tennisclub`三个之中的一个,作为tag标识. 当然多个组之间的tag可用放在一起&lt;/p&gt;

&lt;p&gt;	当然,别忘了,在这些配置行上按下`C-c C-c`才回使这些改动生效.&lt;/p&gt;

&lt;p&gt;	若想在设置变量`org-tags-alist`时也表达这种组内相互排斥的tag,你需要用`:startgroup`和`:endgroup`来代替`{`和`}`. 同样的,你也可用用`:newline`来标识断行. 要把上面哪个例子中的tag设置变成全局性的,可用使用如下配置&lt;/p&gt;

&lt;p&gt;		#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,(setq org-tag-alist &#39;((:startgroup . nil)&lt;/p&gt;

&lt;p&gt;,                      (&#34;@work&#34; . ?w) (&#34;@home&#34; . ?h)&lt;/p&gt;

&lt;p&gt;,                      (&#34;@tennisclub&#34; . ?t)&lt;/p&gt;

&lt;p&gt;,                      (:endgroup . nil)&lt;/p&gt;

&lt;p&gt;,                      (&#34;laptop&#34; . ?l) (&#34;pc&#34; . ?p)))&lt;/p&gt;

&lt;p&gt;		#+END_SRC&lt;/p&gt;

&lt;p&gt;	如果至少有一个tag分配了快捷键,那么在按下`C-c C-c`之后会显示给你一个特殊的界面,在这里列出了继承到的tag,当前标题行所明确指定的tag和所有其他可用tag,以及这些tag的对应快捷键[fn:60].  在这个界面中,你可以使用如下快捷键:&lt;/p&gt;

&lt;p&gt;	 * a-z... ::&lt;/p&gt;

&lt;p&gt;	   按下分配給tag的快捷键会添加/删除当前行的相应tag. 如果你选择的tag刚好跟其他tag处于同一个相互排斥的组,那么其他的tag会自动被移除.&lt;/p&gt;

&lt;p&gt;	 * &lt;TAB&gt; ::&lt;/p&gt;

&lt;p&gt;				会在minibuffer中提示你输入tag,这个tag可用是全新的. 你也可以同时添加多个tag:只需要用冒号将它们分开就行&lt;/p&gt;

&lt;p&gt;	 * &lt;SPC&gt; ::&lt;/p&gt;

&lt;p&gt;				清空当前行的所有tag&lt;/p&gt;

&lt;p&gt;	 * &lt;RET&gt; ::&lt;/p&gt;

&lt;p&gt;				保存当前的tag修改&lt;/p&gt;

&lt;p&gt;	 * C-g ::&lt;/p&gt;

&lt;p&gt;			  放弃当前的修改&lt;/p&gt;

&lt;p&gt;	 * q ::&lt;/p&gt;

&lt;p&gt;			如果`q`没有被分配給tag当快捷键,那么它跟`C-g`一样&lt;/p&gt;

&lt;p&gt;	 * ! ::&lt;/p&gt;

&lt;p&gt;			关闭相互排斥组的约束,用这个命令可用将相互排斥组的多个tag放在一起&lt;/p&gt;

&lt;p&gt;	 * C-c ::&lt;/p&gt;

&lt;p&gt;			  开/闭自动退出模式,如果打开自动退出模式,则org只接收下一个tag的命令,然后就自动退出(见下文). 如果你处于expert mode下,那么这个`C-c`会显示tag选择窗口(也就是说,在expert模式下,C-c C-c默认也不显示tag选择窗口)&lt;/p&gt;

&lt;p&gt;	 这些命令使得你可用用很少的按键就可以为标题分配tag. 举例来说,如果你使用了上面的配置,你可以用`C-c C-c &lt;SPC&gt; h l p &lt;RET&gt;`来清空当前行的tag,然后为当前行分配‘@home’,‘laptop’和‘pc’标签. 使用`C-c C-c w &lt;RET&gt;`或`C-c C-c C-c w`来将`@home`变成`@work`标签. 通过` C-c C-c &lt;TAB&gt; S a r a h &lt;RET&gt; &lt;RET&gt;`来为当前行分配新标签`sarah`&lt;/p&gt;

&lt;p&gt;	 如果你发现你对tag的修改大多数时候只需要按一个键就可用完成,这时,你可以设置变量`org-fast-tag-selection-single-key`. 设置之后你不再需要按`&lt;RET&gt;`来退出快速tag选择窗口--它会在你做出第一次修改之后立即退出. 如果偶尔你需要作多处修改,你只需要按下`C-c`来取消自动退出模式即可(其实设置了`org-fast-tag-selection-single-key`之后,再按下`C-c C-c`,其效果跟`C-c C-c C-c`一样). 如果你设置该变量的值为`expert`,那么这个tag选择窗口甚至不会出现,除非你再按一次`C-c`才会出现&lt;/p&gt;

&lt;h2 id=&#34;tag-group-org8-x的特性&#34;&gt;Tag group(Org8.x的特性)&lt;/h2&gt;

&lt;p&gt;在一系列相互排斥的tag列表中,第一个tag可以定义为group tag. 当你搜索group tag时,实际搜索的是该group中的所有tag. 在agenda视图中过滤出来group tag的结果是将带有group中任何一个tag的headline給过滤出来. 这个特性使得tag搜索和过滤更为便利.&lt;/p&gt;

&lt;p&gt;你可以通过在group tag和其他tag之间插入`:`的方式来设置group tag. 这种方式下,各tag之间只能使用空格来进行分隔. 例如&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+TAGS: { @read : @read_book @read_ebook }&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;在上面的例子中,`@read`就是`@read`,`@read_book`和`@read_ebook`这三个tag集合的goup tag.&lt;/p&gt;

&lt;p&gt;你也可以在设置变量`org-tag-alist`时使用`:grouptags`关键字:&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;(setq org-tag-alist &#39;((:startgroup . nil)&lt;/p&gt;

&lt;p&gt;(&#34;@read&#34; . nil)&lt;/p&gt;

&lt;p&gt;(:grouptags . nil)&lt;/p&gt;

&lt;p&gt;(&#34;@read_book&#34; . nil)&lt;/p&gt;

&lt;p&gt;(&#34;@read_ebook&#34; . nil)&lt;/p&gt;

&lt;p&gt;(:endgroup . nil)))&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;你不能嵌套group tag,也不能作为其他group中的普通tag&lt;/p&gt;

&lt;p&gt;若你想临时禁用group tag特性,可以按`C-c C-x q`(org-toggle-tags-groups)来开关group tag支持. 如果你想完全禁用tag group功能,设置变量`org-group-tags`为nil&lt;/p&gt;

&lt;h2 id=&#34;搜索tag-搜索tag的组合&#34;&gt;搜索Tag&lt;/h2&gt;

&lt;p&gt;一旦完善的tag系统建立起来了,我们就可以利用它将相关联的信息搜集起来&lt;/p&gt;

&lt;p&gt;* C-c / m 或 C-c \ (org-match-sparse-tree) ::&lt;/p&gt;

&lt;p&gt;	 将所有匹配tag搜索的标题搜集起来放到一个sparse tree中. 如果带了`C-u`前缀参,则会忽略哪些不是TODO事项的标题&lt;/p&gt;

&lt;p&gt;* C-c a m (org-tags-view) ::&lt;/p&gt;

&lt;p&gt;		从agenda文件中搜集所有匹配tag搜索的标题. 参见章节&lt;a href=&#34;Matching tags and properties&#34; title=&#34;匹配tag和属性&#34;&gt;匹配tag和属性&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;* C-c a M (org-tags-view) ::&lt;/p&gt;

&lt;p&gt;		从agenda文件中搜索所有匹配tag搜索的标题,但是只搜索TODO事项,并且强制进行子树的匹配(参见变量`org-tags-match-list-sublevels`)&lt;/p&gt;

&lt;p&gt;所有这些命令都会提示你输入匹配字符串, 在输入时,允许你使用基本的布尔逻辑,比如`+boss_urgent-project1`的意思是找tag中带有`boss`和`urgent`但是没有`project1`的事项. 而`Kathy|Sally`的意思是照tag中包含`Kathy`或者`Sally`的事项. 还有其他许多的表达式可以用来匹配TODO关键字,事项的层次和属性的. 更多内容请参见&lt;a href=&#34;Matching tags and properties&#34; title=&#34;匹配tag和属性&#34;&gt;匹配tag和属性&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;属性和column&#34;&gt;属性和column&lt;/h1&gt;

&lt;p&gt;属性其实就是一个键值对,它与org文件中的条目相关联. 属性可用设置为与Org文件中的某个特定条目,或者某棵树下的所有条目,或者整个buffer中的条目相关联.&lt;/p&gt;

&lt;p&gt;在Org-mode中,属性有两种主要的功能. 第一个功能是类似于带值的tag. 想象一下你需要维护一个记录bug和发布版本的文档. 你可以使用类似`:release_1:`或`release_2`这样的tag来标注,或者你可以可用使用一个名叫`:Release:`的属性,但是在不同的子树中给它分配不同的值(比如`1.0`,`2.0`). 第二个功能是使用属性来实现数据库的基本功能. 例如你在记录你的CD,給它分配的属性可用是`专辑,演唱者,发布日期`等等&lt;/p&gt;

&lt;p&gt;通过column视图(参见&lt;a href=&#34;Column view&#34; title=&#34;Column视图&#34;&gt;Column视图&lt;/a&gt;),可用很方便的编辑和查看属性&lt;/p&gt;

&lt;h2 id=&#34;属性的语法规则-如何声明属性&#34;&gt;属性的语法规则&lt;/h2&gt;

&lt;p&gt;属性是以键值对的形式出现的. 当需要分配属性时,属性需要放入一个名为`PROPERTIES`的特殊抽屉(&lt;a href=&#34;Drawers&#34; title=&#34;drawer&#34;&gt;drawer&lt;/a&gt;)中. 每个属性一行,键(用冒号括起来)在前,值在后. 下面是一个例子&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* CD collection&lt;/p&gt;

&lt;p&gt;,** Classic&lt;/p&gt;

&lt;p&gt;,*** Goldberg Variations&lt;/p&gt;

&lt;p&gt;,    :PROPERTIES:&lt;/p&gt;

&lt;p&gt;,    :Title:     Goldberg Variations&lt;/p&gt;

&lt;p&gt;,    :Composer:  J.S. Bach&lt;/p&gt;

&lt;p&gt;,    :Artist:    Glen Gould&lt;/p&gt;

&lt;p&gt;,    :Publisher: Deutsche Grammophon&lt;/p&gt;

&lt;p&gt;,    :NDisks:    1&lt;/p&gt;

&lt;p&gt;,    :END:&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;根据变量`org-use-property-inheritance`的值的不同,属性可能具有也可能不具有继承性,详见&lt;a href=&#34;Property Inheritance&#34; title=&#34;继承的继承性&#34;&gt;继承的继承性&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;你可能想设定属性`:Xyz:`只能有哪些值,你可以通过定义一个名为`:Xyz_ALL`的属性来做到这一点. `:Xyz_ALL:`是一类特殊的属性,该属性具有继承性,因此如果你在第一层条目上设置了这样的属性,它会对整个树生效. 通过约束属性的所有值,可以减少设置属性时输入错误的概率. 举个例子,要记录收集的CD,你可以预定义好出版人和碟片数量,向下面一样:&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* CD collection&lt;/p&gt;

&lt;p&gt;,  :PROPERTIES:&lt;/p&gt;

&lt;p&gt;,  :NDisks_ALL:  1 2 3 4&lt;/p&gt;

&lt;p&gt;,  :Publisher_ALL: &#34;Deutsche Grammophon&#34; Philips EMI&lt;/p&gt;

&lt;p&gt;,  :END:&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;如果你向定义在全file中都有效的属性,在文件中加入这么一行:&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+PROPERTY: NDisks_ALL 1 2 3 4&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;如果你想对一个已经存在的属性,添加一个值,只需要在定义时在属性名称后面附上一个`+`号. 例如下面的例子中,属性`var`的值为`foo=1 bar=2`&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+PROPERTY: var  foo=1&lt;/p&gt;

&lt;p&gt;,#+PROPERTY: var+ bar=2&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;你不仅可以对定义的属性添加值,还能对继承过来的属性添加值. 下面的例子中,`Goldberg Variations`子树中的`genres`属性的值为`Classic Baroque`&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* CD collection&lt;/p&gt;

&lt;p&gt;,** Classic&lt;/p&gt;

&lt;p&gt;,    :PROPERTIES:&lt;/p&gt;

&lt;p&gt;,    :GENRES: Classic&lt;/p&gt;

&lt;p&gt;,    :END:&lt;/p&gt;

&lt;p&gt;,*** Goldberg Variations&lt;/p&gt;

&lt;p&gt;,    :PROPERTIES:&lt;/p&gt;

&lt;p&gt;,    :Title:     Goldberg Variations&lt;/p&gt;

&lt;p&gt;,    :Composer:  J.S. Bach&lt;/p&gt;

&lt;p&gt;,    :Artist:    Glen Gould&lt;/p&gt;

&lt;p&gt;,    :Publisher: Deutsche Grammophon&lt;/p&gt;

&lt;p&gt;,    :NDisks:    1&lt;/p&gt;

&lt;p&gt;,    :GENRES+:   Baroque&lt;/p&gt;

&lt;p&gt;,    :END:&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;需要注意的是,每个Drawer中的每个属性只能定义一行.&lt;/p&gt;

&lt;p&gt;全局变量`org-global-peroperties`定义的属性被所有的Org文件中的所有条目所继承&lt;/p&gt;

&lt;p&gt;下面有一些关于属性的命令&lt;/p&gt;

&lt;p&gt;* M-&lt;TAB&gt; (pcomplete) ::&lt;/p&gt;

&lt;p&gt;	 再输入冒号之后按下这个命令键,会列出当前文件可用所有属性名,可用直接用鼠标点击要加入的属性名即可&lt;/p&gt;

&lt;p&gt;* C-c C-x p (org-set-property) ::&lt;/p&gt;

&lt;p&gt;		设置属性. 这个命令会提示你输入要编辑的属性名称和属性值. 如果输入的新的属性名,则会新增该属性&lt;/p&gt;

&lt;p&gt;* S-&lt;right&gt; (org-peroperty-next-allowed-value) 或 S-&lt;left&gt; (org-peroperty-previous-allowed-value) ::&lt;/p&gt;

&lt;p&gt;		将光标所在的属性切换到上一个/下一个可选值&lt;/p&gt;

&lt;p&gt;* C-c C-c (org-peroperty-action) ::&lt;/p&gt;

&lt;p&gt;		在属性抽屉中按下这个命令键,会显示出各种操作属性的命令,可进行设置属性,删除属性,全局删除属性,计算属性值等操作. 具体说明见下文&lt;/p&gt;

&lt;p&gt;* C-c C-c s (org-set-peroperty) ::&lt;/p&gt;

&lt;p&gt;		设置当前抽屉中的的任选某个属性. 属性名和属性值都可以以计算的方式插入&lt;/p&gt;

&lt;p&gt;* C-c C-c d (org-delete-peroperty) ::&lt;/p&gt;

&lt;p&gt;		删除当前抽屉中的某个属性&lt;/p&gt;

&lt;p&gt;* C-c C-c D (org-delete-property-globally) ::&lt;/p&gt;

&lt;p&gt;		全局删除某个属性,对当前文件中的所有条目都生效&lt;/p&gt;

&lt;p&gt;* C-c C-c c (org-compute-peroperty-at-point) ::&lt;/p&gt;

&lt;p&gt;		计算光标所在的属性,&lt;/p&gt;

&lt;h2 id=&#34;特殊的属性-org-mode的其他特性说明&#34;&gt;特殊的属性&lt;/h2&gt;

&lt;p&gt;一些特定的属性被定义用来开启Org-mode的一些特性(比如前面章节中讲到的TODO状态和优先级). 之所以提供这些特殊的属性,是为了让你可以在column视图中查看到这些状态,还可以在搜索时匹配这些状态. 下面列出的这些特殊属性名,这些属性(除了`:CATEGORY:`)不应该放入属性抽屉中中&lt;/p&gt;

&lt;p&gt;#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;TODO         The TODO keyword of the entry.&lt;/p&gt;

&lt;p&gt;TAGS         The tags defined directly in the headline.&lt;/p&gt;

&lt;p&gt;ALLTAGS      All tags, including inherited ones.&lt;/p&gt;

&lt;p&gt;CATEGORY     The category of an entry.&lt;/p&gt;

&lt;p&gt;PRIORITY     The priority of the entry, a string with a single letter.&lt;/p&gt;

&lt;p&gt;DEADLINE     The deadline time string, without the angular brackets.&lt;/p&gt;

&lt;p&gt;SCHEDULED    The scheduling timestamp, without the angular brackets.&lt;/p&gt;

&lt;p&gt;CLOSED       When was this entry closed?&lt;/p&gt;

&lt;p&gt;TIMESTAMP    The first keyword-less timestamp in the entry.&lt;/p&gt;

&lt;p&gt;TIMESTAMP_IA The first inactive timestamp in the entry.&lt;/p&gt;

&lt;p&gt;CLOCKSUM     The sum of CLOCK intervals in the subtree.  org-clock-sum&lt;/p&gt;

&lt;p&gt;must be run first to compute the values in the current buffer.&lt;/p&gt;

&lt;p&gt;BLOCKED      &#34;t&#34; if task is currently blocked by children or siblings&lt;/p&gt;

&lt;p&gt;ITEM         The content of the entry.&lt;/p&gt;

&lt;p&gt;FILE         The filename the entry is located in.&lt;/p&gt;

&lt;p&gt;#+END_EXAMPLE&lt;/p&gt;

&lt;h2 id=&#34;搜索属性-匹配属性值&#34;&gt;搜索属性&lt;/h2&gt;

&lt;p&gt;属性搜索的命令和tag搜索(参见章节&lt;a href=&#34;Tag searches&#34; title=&#34;tag搜索&#34;&gt;tag搜索&lt;/a&gt;)的命令一样的&lt;/p&gt;

&lt;p&gt;* C-c / m 或 C-c \ (org-match-sparse-tree) ::&lt;/p&gt;

&lt;p&gt;	 将所有匹配tag搜索的标题搜集起来放到一个sparse tree中. 如果带了`C-u`前缀参,则会忽略哪些不是TODO事项的标题&lt;/p&gt;

&lt;p&gt;* C-c a m (org-tags-view) ::&lt;/p&gt;

&lt;p&gt;		从agenda文件中搜集所有匹配tag/属性搜索的标题. 参见章节&lt;a href=&#34;Matching tags and properties&#34; title=&#34;匹配tag和属性&#34;&gt;匹配tag和属性&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;* C-c a M (org-tags-view) ::&lt;/p&gt;

&lt;p&gt;		从agenda文件中搜索所有匹配tag搜索的标题,但是只搜索TODO事项,并且强制进行子树的匹配(参见变量`org-tags-match-list-sublevels`)&lt;/p&gt;

&lt;p&gt;关于搜索串的语法参见&lt;a href=&#34;Matching%20tags%20and%20properties&#34; title=&#34;匹配tag和属性&#34;&gt;匹配tag和属性&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;还有一个搜索单个属性的命令:&lt;/p&gt;

&lt;p&gt;* C-c / p&lt;/p&gt;

&lt;p&gt;	 该命令根据属性值进行搜索匹配. 它首先提示你输入要搜索的属性名,然后是要匹配的值. 然后就会查找出所有拥有该属性并且属性值为指定值的条目. 在输入待匹配的属性值时,用`{}`括起来的值被当作是正则表达式处理.&lt;/p&gt;

&lt;h2 id=&#34;属性继承-下级继承上级的属性值&#34;&gt;属性继承&lt;/h2&gt;

&lt;p&gt;属性可以具有继承性.但是默认情况下,Org-mode不打开该特性,因为它会极大地拖慢属性搜索的速度并且实用性也不大. 然而如果你觉得很有必要打开它的继承性,你可以通过设置`org-use-property-inheritance`来实现. `org-use-property-inheritance`的值为`t`表示开启继承性,为`nil`表示关闭继承性&lt;/p&gt;

&lt;p&gt;Org-mode中也有一些属性是强制具有继承性的.&lt;/p&gt;

&lt;p&gt;* COLUMNS ::&lt;/p&gt;

&lt;p&gt;	 `:COLUMNS:`属性定义了column视图的格式(参见章节&lt;a href=&#34;Column view&#34; title=&#34;Column视图&#34;&gt;Column视图&lt;/a&gt;). 它的继承性的意义为:定义了`:COLUMNS:`属性的层次被认为是column视图表格的开始部分.它与子树中column视图被开启的位置相互独立(independently of the location in the subtree from where columns view is turned on. )&lt;/p&gt;

&lt;p&gt;* CATEGORY ::&lt;/p&gt;

&lt;p&gt;				 在agenda视图中显示时,通过`:CATEGORY:`属性设置的类别对整个子树都有效&lt;/p&gt;

&lt;p&gt;* ARCHIVE ::&lt;/p&gt;

&lt;p&gt;				在归档时有用,`:ARCHIVE:`属性定义了整个子树中的归档位置(参见章节&lt;a href=&#34;Moving a tree to the archive file&#34; title=&#34;移动树到归档文件中&#34;&gt;移动树到归档文件中&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;* LOGGING ::&lt;/p&gt;

&lt;p&gt;				`:LOGGING:`属性为条目或子树定义了记录日志的设置情况(参见章节&lt;a href=&#34;Tracking TODO state changes&#34; title=&#34;追踪TODO状态的改变&#34;&gt;追踪TODO状态的改变&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&#34;column视图-以表格的方式浏览与编辑&#34;&gt;Column视图&lt;/h2&gt;

&lt;p&gt;要查看和编辑一个大纲树中的属性,有一个很好的方法,那就是column视图. 在column视图中,每个大纲节点都被转换为表格中的一行. 各条目的属性就是表格中的列. Org-mode并不实际修改buffer,而只是通过在标题上多现实出一个表格结构体的方式实现column视图的. 因此,即使标题被转换成了表格的行了,但是你依然可以切换大纲树的可视性. 例如,你通过切换到目录(CONTENTS)视图模式(通过`S-&lt;TAB&gt; S-&lt;TAB&gt;`切换,若在column视图中,则直接按`c`即可),得到一个紧凑的概况表格. 这时,你依然可以打开,阅读和编辑每个标题下面的各个条目. 你也可以在执行sparse树命令之后再切换到column视图,通过这种方式,你可以在表格中只现在筛选出来的内容. 你也可以在&lt;a href=&#34;Agenda views&#34; title=&#34;agengda&#34;&gt;agengda&lt;/a&gt;视图中切换成Column显示方法,这样你可以在表格中同时显示多个文件中的筛选内容.&lt;/p&gt;

&lt;h3 id=&#34;定义列-columns格式属性&#34;&gt;定义列&lt;/h3&gt;

&lt;p&gt;	要想使用column视图,先得定义列. 这是通过定义列格式行(column format line)的方式来进行的&lt;/p&gt;

&lt;h4 id=&#34;列定义的范围-在哪里定义-作用的范围有哪些&#34;&gt;列定义的范围&lt;/h4&gt;

&lt;p&gt;	 要定义整个文件范围的列格式,使用类似下面的行&lt;/p&gt;

&lt;p&gt;	 #+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+COLUMNS: %25ITEM %TAGS %PRIORITY %TODO&lt;/p&gt;

&lt;p&gt;	 #+END_SRC&lt;/p&gt;

&lt;p&gt;	 如果只想对某颗树的范围内定义列格式,对这棵树的最顶层节点添加`:COLUMNS:`属性,例如&lt;/p&gt;

&lt;p&gt;	 #+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,** Top node for columns view&lt;/p&gt;

&lt;p&gt;,   :PROPERTIES:&lt;/p&gt;

&lt;p&gt;,   :COLUMNS: %25ITEM %TAGS %PRIORITY %TODO&lt;/p&gt;

&lt;p&gt;,   :END:&lt;/p&gt;

&lt;p&gt;	 #+END_SRC&lt;/p&gt;

&lt;p&gt;	 `:COLUMNS:`属性具有继承性,因此你可以在上层为各子层定义足够普遍的格式定义,然后在编辑更深层次时定义更特化的格式定义&lt;/p&gt;

&lt;h4 id=&#34;列属性-列的内容和展示&#34;&gt;列属性&lt;/h4&gt;

&lt;p&gt;	 column的定义式中可以包含有列的属性. 一般来说列的定义式看起来是这样做的&lt;/p&gt;

&lt;p&gt;	 #+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,%[width]property[(title)][{summary-type}]&lt;/p&gt;

&lt;p&gt;	 #+END_SRC&lt;/p&gt;

&lt;p&gt;	 除了百分号和属性名之外,所有的都是可选的. 各部分的意思如下所示&lt;/p&gt;

&lt;p&gt;	 #+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;width           整型,代表了列的宽度,如果忽略则由org自动决定&lt;/p&gt;

&lt;p&gt;property        该列所表示的属性,可以是上文提到的哪些特殊属性&lt;/p&gt;

&lt;p&gt;title           列的标题,如果忽略,则会使用属性名代替&lt;/p&gt;

&lt;p&gt;{summary-type}  总和的类型,如果指定了,那么父节点的列值由其下子节点的值计算得到&lt;/p&gt;

&lt;p&gt;支持的总和类型包括:&lt;/p&gt;

&lt;p&gt;{+}       Sum numbers in this column.&lt;/p&gt;

&lt;p&gt;{+;%.1f}  Like ‘+’, but format result with ‘%.1f’.&lt;/p&gt;

&lt;p&gt;{$}       Currency, short for ‘+;%.2f’.&lt;/p&gt;

&lt;p&gt;{:}       Sum times, HH:MM, plain numbers are hours.&lt;/p&gt;

&lt;p&gt;{X}       Checkbox status, ‘[X]’ if all children are ‘[X]’.&lt;/p&gt;

&lt;p&gt;{X/}      Checkbox status, ‘[n/m]’.&lt;/p&gt;

&lt;p&gt;{X%}      Checkbox status, ‘[n%]’.&lt;/p&gt;

&lt;p&gt;{min}     Smallest number in column.&lt;/p&gt;

&lt;p&gt;{max}     Largest number.&lt;/p&gt;

&lt;p&gt;{mean}    Arithmetic mean of numbers.&lt;/p&gt;

&lt;p&gt;{:min}    Smallest time value in column.&lt;/p&gt;

&lt;p&gt;{:max}    Largest time value.&lt;/p&gt;

&lt;p&gt;{:mean}   Arithmetic mean of time values.&lt;/p&gt;

&lt;p&gt;{@min}    Minimum age (in days/hours/mins/seconds).&lt;/p&gt;

&lt;p&gt;{@max}    Maximum age (in days/hours/mins/seconds).&lt;/p&gt;

&lt;p&gt;{@mean}   Arithmetic mean of ages (in days/hours/mins/seconds).&lt;/p&gt;

&lt;p&gt;{est+}    区间的总和&lt;/p&gt;

&lt;p&gt;	 #+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;	 需要注意的是,一个属性只能有一种总和类型. 低层列当涉及到相同的属性时,会显示一样的总和信息.&lt;/p&gt;

&lt;p&gt;	 `est+`这种总和类型需要多做一些说明. 它常常用来合计那些范围数据. 例如你在评估一项任务的时候可能不会说就是5天搞定,相反你可能会说大概5-6天的时候能搞定,甚至如果你对这个任务一无所知的化可能估计要1-10天才能搞定. 这两种区间平均来说都是5.5天搞定,但是第一种表达明显更精确一点.&lt;/p&gt;

&lt;p&gt;	 当在计算这种区间的的总和时,一般的做法是把各区间的最低值和最高值相加形成一个区间,然而这个区间往往跨度太大而没什么用. `est+`则不采用这种计算方法. 它会计算各区间的平均值和方差,并根据总和生成一个最终估计. 举个例子, 假设你有10项任务,每项任务估计都要话0.5-2天才能昨晚. 如果采用一般的方法直接累计的结果是完成这10项任务需要花5-20天的时间. 然而如果使用`est+`这种计算方式则估计出值为10-15天,这个值明显更真实一些.&lt;/p&gt;

&lt;p&gt;	 下面是一个完整的列定义的例子.[fn:61]&lt;/p&gt;

&lt;p&gt;	 #+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,:COLUMNS:  %25ITEM %9Approved(Approved?){X} %Owner %11Status %10Time_Estimate{:} %CLOCKSUM&lt;/p&gt;

&lt;p&gt;,:Owner_ALL:    Tammy Mark Karl Lisa Don&lt;/p&gt;

&lt;p&gt;,:Status_ALL:   &#34;In progress&#34; &#34;Not started yet&#34; &#34;Finished&#34; &#34;&#34;&lt;/p&gt;

&lt;p&gt;,:Approved_ALL: &#34;[ ]&#34; &#34;[X]&#34;&lt;/p&gt;

&lt;p&gt;	 #+END_SRC&lt;/p&gt;

&lt;p&gt;	 第一列`%25ITEM`的意思是取条目(例如标题)的前25个字节为内容. 基本上你在定义列定义时都应该以`ITEM列`开头. 其他的列定义部分则定义了一个名为`Owner`的列,该列限定了几个可选值. 定义了一个名为`Status`的列并定义了4个可选值, 还有放置checkbox的列`Approved`. 若`%`之后没有定义列宽,则列宽会刚好足够显示所有的值. `Approved`列有一个被修改过的标题(`Approved?`,这里有个问号). 对于列`Time_Estimate`会自动累计时间段,格式为`HH:MM`, 而对于列`Approved`来说,如果所有的子节点都check过了,则会显示一个`[X]`表示完结状态. `CLOCKSUM`列比较特殊,它列出子树中的CLOCK间隔时间的总和&lt;/p&gt;

&lt;h3 id=&#34;使用column视图-如何创建和使用column视图&#34;&gt;使用column视图&lt;/h3&gt;

&lt;p&gt;	  * C-c C-x C-c (org-columns) ::&lt;/p&gt;

&lt;p&gt;		打开column视图模式. 如果执行命令时光标在文件第一个标题上面,那么整个文件都会开启column视图模式,column视图现实时是参照`#+COLUMNS`的定义来现实的. 如果光标是在大纲内部的化,命令会从改点开始往下搜索所有子树,查找`:COLUMNS:`属性. 当找到一个`:COLUMNS:`属性后,会为以带有该属性的条目为起点的子树建立column视图表格. 如果没有找到`:COLUMNS:`属性,那么会以光标所在条目为起点的子树建立column视图,其参照的格式为`#+COLUMNS`行或变量`org-columns-default-format`中的定义&lt;/p&gt;

&lt;p&gt;	  * r (org-columns-redo) ::&lt;/p&gt;

&lt;p&gt;		   刷新column视图,让它反应最近的修改&lt;/p&gt;

&lt;p&gt;	  * g (org-columns-redo) ::&lt;/p&gt;

&lt;p&gt;		   跟`r`一样&lt;/p&gt;

&lt;p&gt;	  * q (org-columns-quit) ::&lt;/p&gt;

&lt;p&gt;		   退出column视图&lt;/p&gt;

&lt;p&gt;	  * &lt;left&gt; &lt;right&gt; &lt;up&gt; &lt;down&gt; ::&lt;/p&gt;

&lt;p&gt;		在column视图中的域之间跳转&lt;/p&gt;

&lt;p&gt;	  * S-&lt;left&gt; /S-&lt;right&gt;  ::&lt;/p&gt;

&lt;p&gt;		   切换域中的值为下一个/上一个可能的值,因此你必须要为该属性定义好可选的值&lt;/p&gt;

&lt;p&gt;	  * 1...9,0 ::&lt;/p&gt;

&lt;p&gt;				   直接选择第N个可选值,0表示选择第10个可选值&lt;/p&gt;

&lt;p&gt;	  * n (org-columns-next-allowed-value) /p (org-columns-previous-allowed-value) ::&lt;/p&gt;

&lt;p&gt;		   跟S-&lt;left&gt; /S-&lt;right&gt;一样&lt;/p&gt;

&lt;p&gt;	  * e (org-columns-edit-value) ::&lt;/p&gt;

&lt;p&gt;		   编辑光标所在的属性值.&lt;/p&gt;

&lt;p&gt;	  * C-c C-c (org-columns-set-tags-or-toggle) ::&lt;/p&gt;

&lt;p&gt;		   当光标处于checkbox处时,切换它的勾选状态&lt;/p&gt;

&lt;p&gt;	  * v (org-columns-show-value) ::&lt;/p&gt;

&lt;p&gt;		   查看属性的完整值,这在当列宽度比值宽度要小的时候很有用&lt;/p&gt;

&lt;p&gt;	  * a (org-columns-edit-allowed) ::&lt;/p&gt;

&lt;p&gt;		   编辑该属性的可选值. 如果之前就已经设定了可选值,那么修改过的值就存储在之前设定可选值的位置.否则的话新的可选值会记录在当前column视图的第一个条目处.&lt;/p&gt;

&lt;p&gt;	  * &lt; (org-columns-narrow) / &gt; (org-columns-widen) ::&lt;/p&gt;

&lt;p&gt;		缩小/放大列的宽度&lt;/p&gt;

&lt;p&gt;	  * S-M-&lt;right&gt; (org-columns-new) ::&lt;/p&gt;

&lt;p&gt;		在当前列的左边插入一行新列&lt;/p&gt;

&lt;p&gt;	  * S-M-&lt;left&gt; (org-columns-delete) ::&lt;/p&gt;

&lt;p&gt;		   删除当前列&lt;/p&gt;

&lt;h3 id=&#34;捕捉column视图-column视图的动态区块&#34;&gt;捕捉column视图&lt;/h3&gt;

&lt;p&gt;	由于column视图并不正真修改buffer,它只是一种显示方式而已,因此它不能直接被导出或者被打印出来. 如果你需要捕获column视图的内容,你需要定义`columnview`动态区块(dynamic block). 这种动态区块的框架类似于这样的:&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* The column view&lt;/p&gt;

&lt;p&gt;,#+BEGIN: columnview :hlines 1 :id &#34;label&#34;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开/关column视图&lt;/li&gt;
&lt;li&gt;编辑值&lt;/li&gt;
&lt;li&gt;修改表column视图格结构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;,#+END:&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;p&gt;	定义动态区块时可以使用以下这些参数:&lt;/p&gt;

&lt;p&gt;	* :id ::&lt;/p&gt;

&lt;p&gt;	  这是最重要的参数. 因为动态区块所处的位置跟要捕获的column视图的位置很可能不一致,这就要求用一种方法来定义那部分的column视图需要被捕获. 这个参数有4个值&lt;/p&gt;

&lt;p&gt;	  #+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;local     use the tree in which the capture block is located&lt;/p&gt;

&lt;p&gt;global    make a global view, including all headings in the file&lt;/p&gt;

&lt;p&gt;&#34;file:path-to-file&#34;&lt;/p&gt;

&lt;p&gt;run column view at the top of this file&lt;/p&gt;

&lt;p&gt;&#34;ID&#34;      call column view in the tree that has an :ID:&lt;/p&gt;

&lt;p&gt;property with the value label.  You can use&lt;/p&gt;

&lt;p&gt;M-x org-id-copy to create a globally unique ID for&lt;/p&gt;

&lt;p&gt;the current entry and copy it to the kill-ring.&lt;/p&gt;

&lt;p&gt;	  #+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;	* :hlines ::&lt;/p&gt;

&lt;p&gt;				 如果为`t`,则表示每一行后面都插入一条横线. 若设置为数字N,则表示对于所有层级&lt;=N的标题,在标题前插入一条横线&lt;/p&gt;

&lt;p&gt;	* vlines ::&lt;/p&gt;

&lt;p&gt;				若设置为`t`,则表示强制用竖线分隔各属性列&lt;/p&gt;

&lt;p&gt;	* :maxlevel ::&lt;/p&gt;

&lt;p&gt;				   若设置为数字N,表示不捕捉层级在N级以下的条目&lt;/p&gt;

&lt;p&gt;	* :skip-empty-rows ::&lt;/p&gt;

&lt;p&gt;		 若设置为`t`,则会跳过那些除了`ITEM`属性列外,其他属性列都是空值的行&lt;/p&gt;

&lt;p&gt;	下面还有一些命令是用来插入或更新动态区块(dynamic block)的&lt;/p&gt;

&lt;p&gt;	* C-c C-x i (org-insert-columns-dblock) ::&lt;/p&gt;

&lt;p&gt;	  插入一个dynamic block,你需要输入要捕获的column视图的范围或ID&lt;/p&gt;

&lt;p&gt;	* C-c C-c / C-c C-x C-u (org-dblock-update) ::&lt;/p&gt;

&lt;p&gt;		 更新光标所在的dynamic block. 光标的位置需要在dynamic block的`#+BEGIN`这一行&lt;/p&gt;

&lt;p&gt;	* C-u C-c C-x C-u (org-update-all-dblocks) ::&lt;/p&gt;

&lt;p&gt;		 更新所有的dynamic blocks. 当你在一个buffer中有多个dynamic block时很有用&lt;/p&gt;

&lt;p&gt;	你可以在column视图表格中插入公式并且你可以在表格前插入绘图说明--这些操作会随着block的更新而一起更新. 如果表格后面有用`#+TBLFM:`定义计算公式,那么这些公式也会随着block的更新而重新计算&lt;/p&gt;

&lt;p&gt;	另一个捕获和处理属性值的方法是使用Eric Schulte的`org-collector.el`,这是一个第三方包[fn:62]. 它提供了大量的API来获得某个条目或者某个范围的属性. 并且可以使用任意的Lisp表达式来处理这些属性值然后再插入到表格或者动态区块(dynamic block)中去&lt;/p&gt;

&lt;h2 id=&#34;属性api-提供給lisp程序员的属性相关的api&#34;&gt;属性API&lt;/h2&gt;

&lt;p&gt;有大量的API提供来获取和修改属性. Emacs Lisp程序员可以使用这些API来编辑属性或实现与这些属性相关的特性. 更多信息参见&lt;a href=&#34; Using the property API&#34; title=&#34;使用属性API&#34;&gt;使用属性API&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;日期与时间&#34;&gt;日期与时间&lt;/h1&gt;

&lt;p&gt;为了协助进行项目计划. TODO事项可以加上日期和时间的标签. 这种带有日期和时间信息的特定字符串在Org-mode中被称呼为时间戳(timestamp). 这可能会让人有点迷糊,因为时间戳常常用来标识事情是什么时候创建或改变的. 然而,在Org-mode中,该名称的意义更加广泛&lt;/p&gt;

&lt;h2 id=&#34;时间戳-最后期限和规划日期-給事项分配时间&#34;&gt;时间戳,最后期限和规划日期				:給事项分配时间&lt;/h2&gt;

&lt;p&gt;时间戳以一种特定的格式来标识日期(也可能是时间或一个时间段),比如想这样:`&#34;&lt; 2003-09-16 Tue &gt;&#34;[fn:63] ,`&lt; 2003-09-16 Tue09:39 &gt;`,`‘&lt; 2003-09-16 Tue 12:00-12:30 &gt;`[fn:64]. 时间戳可以放在标题和条目的任意位置处. 带有时间戳的条目在agenda视图中会显示在特定的日期区域(参见&lt;a href=&#34;The weekly/daily agenda&#34; title=&#34;周/日agenda&#34;&gt;周/日agenda&lt;/a&gt;). 时间戳有以下几种格式:&lt;/p&gt;

&lt;p&gt;* 单纯的一个时间点,一般用于单次的约会,会议等&lt;/p&gt;

&lt;p&gt;	 时间戳最基本的作用就是为某事项分配一个日期/时间. 这就好像在日程表中安排一项日程一样. 当用timeline或agenda视图查看安排时,带有时间戳的事项就会出现在时间戳指示的日期处.&lt;/p&gt;

&lt;p&gt;	 #+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* Meet Peter at the movies &lt;2006-11-01 Wed 19:15&gt;&lt;/p&gt;

&lt;p&gt;,* Discussion on climate change &lt;2006-11-02 Thu 20:00-22:00&gt;&lt;/p&gt;

&lt;p&gt;	 #+END_SRC&lt;/p&gt;

&lt;p&gt;* 带有重复间隔的时间戳&lt;/p&gt;

&lt;p&gt;	 如果你想标识某件事不仅仅是在指定的那天需要去办,而且在之后的时间里,每隔N天(d),周(w),月(m)或年(y)也需要重复的做这件事情. 这时你可以在时间戳中包含重复间隔的信息. 例如下面的例子说明了每周周三都要去作的事情&lt;/p&gt;

&lt;p&gt;	 #+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* Pick up Sam at school &lt;2007-05-16 Wed 12:30 +1w&gt;&lt;/p&gt;

&lt;p&gt;	 #+END_SRC&lt;/p&gt;

&lt;p&gt;* diary风格的类lisp表达式(Diary-style sexp entries)&lt;/p&gt;

&lt;p&gt;	 要表达更复杂的时间需求, Org-mode可以使用diary风格的类lisp表达式来表示时间,这种表达式是由Emacs内置的calendar/diary包实现的.[fn:65]. 下面是一个例子&lt;/p&gt;

&lt;p&gt;	 #+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* 22:00-23:00 The nerd meeting on every 2nd Thursday of the month&lt;/p&gt;

&lt;p&gt;,  &lt;%%(org-float t 4 2)&gt;&lt;/p&gt;

&lt;p&gt;	 #+END_SRC&lt;/p&gt;

&lt;p&gt;* 时间段&lt;/p&gt;

&lt;p&gt;	 用`--`连接起来的两个时间戳就表示一个时间段. 下面是一个例子&lt;/p&gt;

&lt;p&gt;	 #+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,** Meeting in Amsterdam&lt;/p&gt;

&lt;p&gt;,   &lt;2004-08-23 Mon&gt;--&lt;2004-08-26 Thu&gt;&lt;/p&gt;

&lt;p&gt;	 #+END_SRC&lt;/p&gt;

&lt;p&gt;* 无效的时间戳&lt;/p&gt;

&lt;p&gt;	 跟一般的时间戳差不多,只是用方括号代替尖括号. 这种时间戳不会影响事项在agenda中的显示&lt;/p&gt;

&lt;p&gt;	 #+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* Gillian comes late for the fifth time [2006-11-01 Wed]&lt;/p&gt;

&lt;p&gt;	 #+END_SRC&lt;/p&gt;

&lt;h2 id=&#34;创建时间戳-插入时间戳的命令&#34;&gt;创建时间戳&lt;/h2&gt;

&lt;p&gt;Org-mode中的时间戳必须是复合特定的格式的. 因此Org提供了下面这些命令生成正确格式的时间戳&lt;/p&gt;

&lt;p&gt;* C-c . (org-time-stamp) ::&lt;/p&gt;

&lt;p&gt;	 该命令提示你输入日期然后插入对应的时间戳. 如果执行该命令时,光标已经处于时间戳上,则该命令修改时间戳,而不是插入新的时间戳. 如果连续两次成果执行该命令,则插入的是一个时间段.&lt;/p&gt;

&lt;p&gt;* C-c ! (org-time-stamp-inactive) ::&lt;/p&gt;

&lt;p&gt;		类似于C-c . 但是插入的是一个无效的(inactive)时间戳,这种时间戳不会影响事项在agenda上的显示&lt;/p&gt;

&lt;p&gt;* C-u C-c . /C-u C-c ! ::&lt;/p&gt;

&lt;p&gt;	类似`C-c .`和`C-c !`,但是包含日期和时间. 默认的时间会自动四舍五入到每5分钟为单位.参见选项`org-time-stamp-rounding-minutes`&lt;/p&gt;

&lt;p&gt;* C-c C-c  ::&lt;/p&gt;

&lt;p&gt;				 更正时间戳,如果星期数错了或者没有,就会修正或者插入正确的星期数&lt;/p&gt;

&lt;p&gt;* C-c &lt; (org-date-from-calendar) ::&lt;/p&gt;

&lt;p&gt;		插入Calendar窗口中光标所处的日期所对应的时间戳&lt;/p&gt;

&lt;p&gt;* C-c &gt; (org-goto-calendar) ::&lt;/p&gt;

&lt;p&gt;		打开Emacs Calendar窗口并定为到今天. 若光标处于时间戳处,则定为到时间戳表示的位置&lt;/p&gt;

&lt;p&gt;* C-c C-o (org-open-at-point) ::&lt;/p&gt;

&lt;p&gt;		在agenda窗口中打开时间戳所指定的日期或时间段(参见章节&lt;a href=&#34; The weekly/daily agenda&#34; title=&#34;周/日agenda&#34;&gt;周/日agenda&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;* S-&lt;left&gt; (org-timestamp-down-day) / S-&lt;right&gt; (org-timestamp-up-day) ::&lt;/p&gt;

&lt;p&gt;	 减少/增加光标所在的日期一天. 这些按键序列与shift-selecton及相关模式相互冲突(参见章节&lt;a href=&#34; Packages that lead to conflicts with Org mode&#34; title=&#34;与org-mode冲突的包&#34;&gt;与org-mode冲突的包&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;* S-&lt;up&gt; (org-timestamp-up) / S-&lt;down&gt; (org-timestamp-down) ::&lt;/p&gt;

&lt;p&gt;		更改光标所处的时间戳中的各个部分(年,月,日,时,分). 若时间戳是一个类似‘15:30-16:30’的时间段,则修改第一个时间也会同时改变第二个时间,为的是保持时间跨度不变. 若想修改时间跨度,请直接修改第二个时间. 需要注意的是,若光标不是处于时间戳中,而是处于标题上,则该键序列会修改事项的优先级(参见章节&lt;a href=&#34;Priorities&#34; title=&#34;优先级&#34;&gt;优先级&lt;/a&gt;).这些按键序列与shift-selecton及相关模式相互冲突(参见章节&lt;a href=&#34; Packages that lead to conflicts with Org mode&#34; title=&#34;与org-mode冲突的包&#34;&gt;与org-mode冲突的包&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;* C-c C-y (org-evaluate-time-range) ::&lt;/p&gt;

&lt;p&gt;		根据时间段计算出时间跨度显示在minibuffer上. 如果带有前缀参数,则将结果写道时间段的后面(若是在表格中,则写到下一列的位置)&lt;/p&gt;

&lt;h3 id=&#34;日期-时间的提示窗口-org-mode是如何帮助你输入日期和时间的&#34;&gt;日期/时间的提示窗口&lt;/h3&gt;

&lt;p&gt;	当Org-mode提示输入日期/时间时,会有一个默认值,这个默认值是以缺省的格式来显示的,这给人的感觉似乎只能输入这种特定的格式的时间才行. 其实Org-mode可用处理任何包含有日期/时间信息的字符串,并且很智能的提取出其中的日期/时间信息. 例如你可以使用`C-y`粘贴email中的内容(可能有多行). Org-mode会丢弃任何不符合默认日期/时间格式的字符串,从而提取出其中的日期/时间信息. 提示的默认值一般来说是当前日期,但是如果是在修改一个已经存在的时间戳或者输入时间段的第二个时间戳信息时,默认值使用的是buffer中的哪个时间戳信息. 当输入日期信息时, Org-mode假设大多数时候你想要输入的都是未来的日期,因此如果你没有输入月/年,同时你输入的天/月又比今天要早时,Org-mode会基于&#34;你输入的是未来的日期&#34;这个假设自动填充月/年信息[fn:66]. 如果输入的日期被自动调整到未来的日期,时间提示符会出现`(=&gt;F)`以此来提醒你&lt;/p&gt;

&lt;p&gt;	举个例子,假设今天是2006年6月13日. 下面列出一些输入和实际解释的对应关系&lt;/p&gt;

&lt;p&gt;	#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;3-2-5         ⇒ 2003-02-05&lt;/p&gt;

&lt;p&gt;2/5/3         ⇒ 2003-02-05&lt;/p&gt;

&lt;p&gt;14            ⇒ 2006-06-14&lt;/p&gt;

&lt;p&gt;12            ⇒ 2006-07-12&lt;/p&gt;

&lt;p&gt;2/5           ⇒ 2007-02-05&lt;/p&gt;

&lt;p&gt;Fri           ⇒ nearest Friday (default date or later)&lt;/p&gt;

&lt;p&gt;sep 15        ⇒ 2006-09-15&lt;/p&gt;

&lt;p&gt;feb 15        ⇒ 2007-02-15&lt;/p&gt;

&lt;p&gt;sep 12 9      ⇒ 2009-09-12&lt;/p&gt;

&lt;p&gt;12:45         ⇒ 2006-06-13 12:45&lt;/p&gt;

&lt;p&gt;22 sept 0:34  ⇒ 2006-09-22 0:34&lt;/p&gt;

&lt;p&gt;w4            ⇒ ISO week for of the current year 2006&lt;/p&gt;

&lt;p&gt;2012 w4 fri   ⇒ Friday of ISO week 4 in 2012&lt;/p&gt;

&lt;p&gt;2012-w04-5    ⇒ Same as above&lt;/p&gt;

&lt;p&gt;	#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;	另外,你还可以输入相对日期,格式是第一个字符用加减号开头,随后是一个用来表示时间长度的数字和一个用来表示天(d)/周(w)/月(m)/年(y)这种时间单位的字符. 如果以一个`+/-`开头,则表示日期是相对于今天来说的. 如果是以两个`+/-`开头,则表示是相对于默认日期来说的. 如果你省略了表示时间单位的哪个字符,则默认为天. 下面是一些例子&lt;/p&gt;

&lt;p&gt;	#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;+0            ⇒ today&lt;/p&gt;

&lt;p&gt;.             ⇒ today&lt;/p&gt;

&lt;p&gt;+4d           ⇒ four days from today&lt;/p&gt;

&lt;p&gt;+4            ⇒ same as above&lt;/p&gt;

&lt;p&gt;+2w           ⇒ two weeks from today&lt;/p&gt;

&lt;p&gt;++5           ⇒ five days from default date&lt;/p&gt;

&lt;p&gt;+2tue         ⇒ second Tuesday from now.&lt;/p&gt;

&lt;p&gt;	#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;	时间函数能够理解英文中的月份了星期几的缩写形式. 如果你像是用英文全称或其他语言,请配置变量`parse-time-months`和`parse-times-weekdays`&lt;/p&gt;

&lt;p&gt;	由于当前的Emacs实现并不能合理的表示所有的日期,因此默认情况下Org-mode强制日期的合理区间为1970年-2037年,因为这区间的时间对于所有的Emacs实现都是可处理的. 如果你想使用超过这个时间段的日期,请先阅读变量`org-read-date-force-complatible-dates`的文档字符串&lt;/p&gt;

&lt;p&gt;	定义一个时间段有两种方式,一中方式是用一个或两个`-`将开始和结束时间连接起来. 另一种是用`+`将开始时间与时间段长度连接起来. 举例子如下&lt;/p&gt;

&lt;p&gt;	#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;11am-1:15pm    ⇒ 11:00-13:15&lt;/p&gt;

&lt;p&gt;11am--1:15pm   ⇒ same as above&lt;/p&gt;

&lt;p&gt;11am+2:15      ⇒ same as above&lt;/p&gt;

&lt;p&gt;	#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;	除了minibuffer中的提示符,Org-mode也可能会弹出一个calendar窗口让你选择日期[fn:67]. 在calendar窗口中,你可以通过单击日期或直接安回车的方式选择日期,随后该日期会插入到提示符中去. 你可以在光标不离开minibuffer的同时控制calendar. 命令如下:&lt;/p&gt;

&lt;p&gt;	#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;&lt;RET&gt;           Choose date at cursor in calendar.&lt;/p&gt;

&lt;p&gt;mouse-1        Select date by clicking on it.&lt;/p&gt;

&lt;p&gt;S-&lt;right&gt;/&lt;left&gt;     One day forward/backward.&lt;/p&gt;

&lt;p&gt;S-&lt;down&gt;/&lt;up&gt;     One week forward/backward.&lt;/p&gt;

&lt;p&gt;M-S-&lt;right&gt;/&lt;left&gt;   One month forward/backward.&lt;/p&gt;

&lt;p&gt;&gt; / &lt;          Scroll calendar forward/backward by one month.&lt;/p&gt;

&lt;p&gt;M-v / C-v      Scroll calendar forward/backward by 3 months.&lt;/p&gt;

&lt;p&gt;	#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;	日期/时间提示符的这些操作看起来很复杂,但是你很快就能适应它们, 随后你会觉得使用其他方式输入日期/时间很不方便. 为了帮助你理解你输入的到底是什么日期,对你输入的实时解释会显示在minibuffer中[fn:68]&lt;/p&gt;

&lt;h3 id=&#34;定制时间格式-让时间看起来与众不同&#34;&gt;定制时间格式							:让时间看起来与众不同&lt;/h3&gt;

&lt;p&gt;	Org-mode使用ISO8601的日期和时间规范. 如果你不习惯此规范想换成其他格式的显示方式,你需要配置变量`org-display-custom-times`和`org-time-stamp-custom-formats`&lt;/p&gt;

&lt;p&gt;	* C-c C-x C-t (org-toggle-time-stamp-overlays)&lt;/p&gt;

&lt;p&gt;	  切换客户化定制的日期/时间显示的格式&lt;/p&gt;

&lt;p&gt;	在输入时间/日期时,Org-mode还是修安排使用默认的格式. 实际上,客户化定制的时间格式并不会正在改变文件中的实际时间格式(存入文件的还是以默认格式存入的). 它只是在显示时转换成客户化定制的格式显示而已. 因此就会造成下面这些后果&lt;/p&gt;

&lt;p&gt;	* 你不能把光标移动到时间戳内部了,你只能从时间戳前面直接跳到时间戳的后面&lt;/p&gt;

&lt;p&gt;	* `S-&lt;up&gt;`,`S-&lt;down&gt;`不能再用于调整时间戳的内部组件了. 如果光标在时间戳前面,则`S-&lt;up&gt;/&lt;down&gt;`跟`S-&lt;left&gt;/&lt;right&gt;`一样,增减一天. 如果光标在时间戳后面,则时间戳增减一分钟&lt;/p&gt;

&lt;p&gt;	* 如果时间段或包含了重复间隔信息的时间戳是不会被转换显示的,还是保留原样&lt;/p&gt;

&lt;p&gt;	* 若在表格中包含了日期,则若定制的时间格式比原格式长,表格的对齐会被搞乱,如果比原格式短,则可用正常对齐&lt;/p&gt;

&lt;h2 id=&#34;最后期限和规划日期-制定工作计划&#34;&gt;最后期限和规划日期		 		 		:制定工作计划&lt;/h2&gt;

&lt;p&gt;* 最后期限(DEADLINE)&lt;/p&gt;

&lt;p&gt;	 当到达最后期限时,该任务会显示在agenda中. 另外在today这个agenda上也会警示一些快要(由变量org-deadline-warning-days决定提前多少天开始警告)或者已经逾期的任务,该警示会一直持续到任务标识为完成后才消失. DEADLINE的一个例子如下:&lt;/p&gt;

&lt;p&gt;	 #+begin_src org&lt;/p&gt;

&lt;p&gt;*** TODO write article about the Earth for the Guide&lt;/p&gt;

&lt;p&gt;DEADLINE: &lt;2004-02-29 Sun&gt;&lt;/p&gt;

&lt;p&gt;The editor in charge is &lt;a href=&#34;bbdb:Ford Prefect&#34; title=&#34;bbdb:Ford Prefect&#34;&gt;bbdb:Ford Prefect&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;	 #+end_src&lt;/p&gt;

&lt;p&gt;	 你可以在设置DEADLINE的同时设置提前多少天发出警示,例如下面的例子表示提前5天发出警示&lt;/p&gt;

&lt;p&gt;	 #+begin_src org&lt;/p&gt;

&lt;p&gt;DEADLINE: &lt;2004-02-29 Sun -5d&gt;&lt;/p&gt;

&lt;p&gt;	 #+end_src&lt;/p&gt;

&lt;p&gt;* 规划日期(SCHEDULED)&lt;/p&gt;

&lt;p&gt;	 当到达规划日期及之后,该任务会在agenda中一直显示[fn:69]. 另外在today这个agenda上会显示今天距离规划日期已经过去多少天了. 该显示会一直持续到任务被标记为完成状态为止. 下面是一个例子&lt;/p&gt;

&lt;p&gt;	 #+begin_src org&lt;/p&gt;

&lt;p&gt;*** TODO Call Trillian for a date on New Years Eve.&lt;/p&gt;

&lt;p&gt;SCHEDULED: &lt;2004-12-25 Sat&gt;&lt;/p&gt;

&lt;p&gt;	 #+end_src&lt;/p&gt;

&lt;h3 id=&#34;插入最后期限和规划日期&#34;&gt;插入最后期限和规划日期&lt;/h3&gt;

&lt;p&gt;	下面的命令使你可以快速插入[fn:70]最后期限和规划日期&lt;/p&gt;

&lt;p&gt;	* C-c C-d (org-deadline)&lt;/p&gt;

&lt;p&gt;	  在标题的下一行插入DEADLINE关键字,该关键字用来标识最后期限信息. 除了插入DEADLINE关键字外,任何CLOSED时间戳都会被删除调.&lt;/p&gt;

&lt;p&gt;	  若调用该命令时带了前缀参数,则表示删除DEADLINE关键字.&lt;/p&gt;

&lt;p&gt;	  根据变量`org-log-redeadline`[fn:71]的值,当更改已经存在的最终期限时,可能会记录日志&lt;/p&gt;

&lt;p&gt;	* C-c C-s (org-schedule)&lt;/p&gt;

&lt;p&gt;	  在标题的下一行插入SCHEDULED关键字,该关键字标识了规划日期的信息. 除了插入SCHEDULED关键字外,任何CLOSED时间戳都会被删除.&lt;/p&gt;

&lt;p&gt;	  若调用该命令时带了前缀参数,则标识删除SCHEDULED关键字.&lt;/p&gt;

&lt;p&gt;	  根据变量`org-log-reschedule`[fn:72]的值,当更改已经存在的规划日期时,可能会记录日志&lt;/p&gt;

&lt;p&gt;	* C-c C-x C-k (org-mark-entry-for-agenda-action)&lt;/p&gt;

&lt;p&gt;	  标记当前任务为agenda action的目标. 执行该命令后,可以打开agenda或calenda,把光标定位到何时的日期处,然后按下k键,会有一系列的agenda action提供来选择.&lt;/p&gt;

&lt;p&gt;	* C-c / d (org-check-deadlines)&lt;/p&gt;

&lt;p&gt;	  创建一颗sparse tree,在该sparse tree中包含了哪些已经超期或者快要超期(根据变量org-deadline-warning-days决定)的任务.&lt;/p&gt;

&lt;p&gt;	  若带有C-u前缀,则显示当前文件中的所有带有deadline的条目.&lt;/p&gt;

&lt;p&gt;	  若带有数字前缀N,则显示N天内超期的和已经超期的条目,例如`C－1 C-c / d`显示所有明天就会超期的条目.&lt;/p&gt;

&lt;p&gt;	* C-c / b (org-check-before-date)&lt;/p&gt;

&lt;p&gt;	  创建一颗sparse tree,在该sparse tree中包含了那些最终期限或规划日期在给定日期之前的条目&lt;/p&gt;

&lt;p&gt;	* C-c / a (org-check-after-date)&lt;/p&gt;

&lt;p&gt;	  创建一颗sparse tree,在该sparse tree中包含了那些最终期限或规划日期在给定日期之前的条目&lt;/p&gt;

&lt;p&gt;	注意:org-shedule和org-deadline支持通过指定相对时间来标识日期,例如+1d意思是当前时间戳的下一天,-1w意思是当前时间戳的上一个星期&lt;/p&gt;

&lt;h3 id=&#34;重复的任务&#34;&gt;重复的任务&lt;/h3&gt;

&lt;p&gt;	有些任务是重复性的. Org mode通过在DEADLINE,SCHEDULED或普通的时间戳中放置所谓的`repeater`来标识这种重复性的任务. 例如&lt;/p&gt;

&lt;p&gt;	#+begin_src org&lt;/p&gt;

&lt;p&gt;, ** TODO Pay the rent&lt;/p&gt;

&lt;p&gt;,   DEADLINE: &lt;2005-10-01 Sat +1m&gt;&lt;/p&gt;

&lt;p&gt;	#+end_src&lt;/p&gt;

&lt;p&gt;	这里的+1m就是repeater. 意思是每个月重复一次. 如果你需要在一个DEADLINE中同时表明repeater和指定预警期的话,则repeater需要放在前面,预警期放在后面,例如&lt;/p&gt;

&lt;p&gt;	#+begin_src org&lt;/p&gt;

&lt;p&gt;,DEADLINE: &lt;2005-10-01 Sat +1m -3d&gt;.&lt;/p&gt;

&lt;p&gt;	#+end_src&lt;/p&gt;

&lt;p&gt;	当任务的最后期限和规划时间超期后,就会在agenda中出现. 因此即使标记带有DEADLINE和SCHEDULE的任务为DONE状态就很重要了. 当你将这种任务标记为DONE状态后,该任务就不会在agenda中出现了.&lt;/p&gt;

&lt;p&gt;	然而这么作带来一个问题,带有repeater的任务被标识为DONE之后,下一个循环的任务不会自动被激活. 为了解决这个问题,Org mode通过如下方法来绕过这个限制:当你使用命令C-c C-t将任务标记为DONE时, 它会将时间戳信息改为下一个重复的时间. 然后将任务标记回为TODO[fn:73].同时原时间戳会被复制并放在deadline的下一行处[fn:74],这样做的目的是保留一个记录告诉你,该任务其实是在上一个循环任务处完结后而来的. 举例来说,如果把上一个例子中的任务标记为DONE,则该任务会变成:&lt;/p&gt;

&lt;p&gt;	#+begin_src org&lt;/p&gt;

&lt;p&gt;, ** TODO Pay the rent&lt;/p&gt;

&lt;p&gt;,   DEADLINE: &lt;2005-11-01 Tue +1m&gt;&lt;/p&gt;

&lt;p&gt;	#+end_src&lt;/p&gt;

&lt;p&gt;	当使用`+1m`作为repeater时,循环日期的增加会严格第一个月一个月地进行. 这样的话,假设你连续三个月忘了付账单了,你再把这个任务标记为DONE后,这个任务的deadline只会增加一个月,因此该任务还是被认为是超期的. 另外,还有一些任务--比如说更换电池,它只需要你在最后一次完成任务的时间点之后开始计算重复时间间隔. 为了应付这些情况,Org mode提供了另外两种repeater:`++`和`.+`. 例如&lt;/p&gt;

&lt;p&gt;	#+begin_src org&lt;/p&gt;

&lt;p&gt;,** TODO Call Father&lt;/p&gt;

&lt;p&gt;,   DEADLINE: &lt;2008-02-10 Sun ++1w&gt;&lt;/p&gt;

&lt;p&gt;,   Marking this DONE will shift the date by at least one week,&lt;/p&gt;

&lt;p&gt;,   but also by as many weeks as it takes to get this date into&lt;/p&gt;

&lt;p&gt;,   the future.  However, it stays on a Sunday, even if you called&lt;/p&gt;

&lt;p&gt;,   and marked it done on Saturday.&lt;/p&gt;

&lt;p&gt;,** TODO Check the batteries in the smoke detectors&lt;/p&gt;

&lt;p&gt;,   DEADLINE: &lt;2005-11-01 Tue .+1m&gt;&lt;/p&gt;

&lt;p&gt;,   Marking this DONE will shift the date to one month after&lt;/p&gt;

&lt;p&gt;,   today.&lt;/p&gt;

&lt;p&gt;	#+end_src&lt;/p&gt;

&lt;p&gt;	若你在某项任务上同时设置了最后期限和规划日期,请保持两者的repater间隔一致.&lt;/p&gt;

&lt;p&gt;	另一种替代repeater的方法是创建一系列的任务拷贝,每隔拷贝使用不同的日期. 命令`C-c C-x c`可以实现这个功能,参见&lt;a href=&#34;Structure editing&#34; title=&#34;结构编辑&#34;&gt;结构编辑&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;计时工作时间-跟踪你在一项任务上花了多少时间&#34;&gt;计时工作时间&lt;/h2&gt;

&lt;p&gt;Org mode可以帮助你记录下某项任务花了多少时间. 当你开始工作时,你可以打开计时功能. 当你停止工作或者标识该任务为DONE时,则停止计时并记录下相应的时间间隔. 它还能计算出每项任务所花的总共时间. 同时它还会记录下最近计时任务的历史,这样你可以在这些任务之间快速跳转.&lt;/p&gt;

&lt;p&gt;要在不同的Emacs session之间保存计时历史,使用如下配置&lt;/p&gt;

&lt;p&gt;#+begin_src elisp&lt;/p&gt;

&lt;p&gt;(setq org-clock-persist &#39;history)&lt;/p&gt;

&lt;p&gt;(org-clock-persistence-insinuate)&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;

&lt;p&gt;在恢复Emacs后,当你开始对一个新任务进行计时时,此时若有上次未完成的计时[fn:75],则会提示你如何处理,详见&lt;a href=&#34;Resolving i&#34; title=&#34;分辨空闲时间&#34;&gt;分辨空闲时间&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;计时命令-开始-停止计时&#34;&gt;计时命令&lt;/h3&gt;

&lt;p&gt;	* C-c C-x C-i (org-clock-in)&lt;/p&gt;

&lt;p&gt;	  开始对当前任务计时,该命令会插入CLOCK关键字和时间戳. 如果插入的CLOCK不是该任务的第一个计时记录,那么这些CLOCK记录都会放入一个名为`LOGBOOK`的drawer中(由变量`org-clock-into-drawer`设定). 你也可以通过设置`CLOCK_INTO_DRAWER`或`LOG_INTO_DRAWER`属性的方式来覆盖全局设置.&lt;/p&gt;

&lt;p&gt;	  若调用该命令时加了C-u前缀参数,则会让你从最近计时的几个任务中选择一个任务进行计时.&lt;/p&gt;

&lt;p&gt;	  若调用命令时加了两个C-u前缀参数,则会对光标所在的任务开始计时,并把该任务设置为默认任务. 设置为默认任务后,使用C-u前缀参数调用命令时,可以用d来进行选择.&lt;/p&gt;

&lt;p&gt;	  当计时开始后,mode-line上会显示任务及子任务总计所花的时间和正在计时的任务标题. 如果正在进行的任务需要进行工作量评估&lt;a href=&#34;#Effort estimates&#34; title=&#34;参见章节Effort estimates&#34;&gt;参见章节Effort estimates&lt;/a&gt;. mode-line上会同时显示预计时间和实际时间[fn:76].  如果任务是重复任务&lt;a href=&#34;#Repeated tasks&#34; title=&#34;参见章节Repeated tasks&#34;&gt;参见章节Repeated tasks&lt;/a&gt;. 则计时只从最后一次重复开始算起[fn:77]. 要进一步控制显示在mode-line上的时间,可以配置属性`CLOCK_MODELINE_TOTAL`. 该属性的值为`current`标示只显示当前的计时实例,值为`today`则显示今天所有任务的统计信息(也可以参见变量`org-extend-today-until`),属性值为`all`则统计所有的计时信息,该属性默认值为`auto`[fn:78].&lt;/p&gt;

&lt;p&gt;	  在mode-line上点击鼠标左键,会弹出计时选项相关的菜单&lt;/p&gt;

&lt;p&gt;	* C-c C-x C-o (org-clock-out)&lt;/p&gt;

&lt;p&gt;	  结束计时. 该命令会在计时开始的那一行插入另一个时间戳并自动计算所花费的时间,然后以`=&gt;HH:MM`的形式插入到两个时间戳之间. 通过配置变量`org-log-note-clock-out`可以在记录clock-out时间戳的同时记录其他附加信息.[fn:79]&lt;/p&gt;

&lt;p&gt;	* C-c C-x C-e (org-clock-modify-effort-estimate)&lt;/p&gt;

&lt;p&gt;	  更新当前计时任务的工作量评估信息&lt;/p&gt;

&lt;p&gt;	* C-c C-c / C-c C-y (org-evaluate-time-range)&lt;/p&gt;

&lt;p&gt;	  更改时间戳之后重新计算时间间隔. 该命令只在手工修改了时间戳的时候才有用. 如果你用S-&lt;cursor&gt;来更改时间戳,会自动更新时间间隔.&lt;/p&gt;

&lt;p&gt;	* C-S-&lt;up/down&gt; (org-clock-timestamps-up/down)&lt;/p&gt;

&lt;p&gt;	  同步增加/减少CLOCK行的结束和开始的时间戳,保持时间段不变&lt;/p&gt;

&lt;p&gt;	* C-c C-t (org-todo)&lt;/p&gt;

&lt;p&gt;	  改变正在计时的任务为完成状态会自动停止计时&lt;/p&gt;

&lt;p&gt;	* C-c C-x C-x (org-clock-cancel)&lt;/p&gt;

&lt;p&gt;	  取消当前计时&lt;/p&gt;

&lt;p&gt;	* C-c C-x C-d (org-clock-display)&lt;/p&gt;

&lt;p&gt;	  展示当前buffer中所有子树的计时统计信息. 该命令会在每隔标题的后面添加上总计的计时时间,每隔总计时间等于该标题下各子标题的总计时间之和. 当你切换到其他buffer(参见变量`org-remove-highlights-with-change`)或按下`C-c C-c`后,该总计时间就会消失&lt;/p&gt;

&lt;p&gt;	在timeline(参见章节&lt;a href=&#34;#Timeline for a single file&#34; title=&#34;Timeline for a single file&#34;&gt;Timeline for a single file&lt;/a&gt;)和agenda(参见章节&lt;a href=&#34;#The weekly/daily agenda&#34; title=&#34;The weekly/daily agenda&#34;&gt;The weekly/daily agenda&lt;/a&gt;)模式下,按下`l`键可以查看当天做过哪些任务或者哪些任务今天结束了.&lt;/p&gt;

&lt;h3 id=&#34;计时报告-详细报告&#34;&gt;计时报告&lt;/h3&gt;

&lt;p&gt;	Org-mode可以基于计时信息统计出复杂的报表,这种报表是以Org表格的形式展示的,因此也叫做clock table&lt;/p&gt;

&lt;p&gt;	* C-c C-x C-r (org-clock-report)&lt;/p&gt;

&lt;p&gt;	  在当前文件插入一个dynamic block,内涵一个clock report. 如果执行命令时光标位于一个已经存在的clock table内,则更新该clock table. 如果执行该命令时带了个前缀参数,则跳到第一个clock report并更新之. The clock table always includes also trees with :ARCHIVE: tag&lt;/p&gt;

&lt;p&gt;	* C-c / C-c C-x C-u (org-dblock-update)&lt;/p&gt;

&lt;p&gt;	  更新光标所在的dynamic block. 光标需要位于dynamic block的#+BEGIN这一行&lt;/p&gt;

&lt;p&gt;	* C-u C-c C-x C-u&lt;/p&gt;

&lt;p&gt;	  更新所有的dynamic blocks. 如果在buffer中有多个clock table block,则该命令非常有用.&lt;/p&gt;

&lt;p&gt;	* S-&lt;left&gt; /S-&lt;right&gt; (org-clocktable-try-shift)&lt;/p&gt;

&lt;p&gt;	  更改当前clock table的:block参数并更新之. 执行该命令时光标需要处于#+BEGIN: clocktable这一行. 如果:block是`today`,则会切到`today-1`,依次类推.&lt;/p&gt;

&lt;p&gt;	下面是一个clock table的框架&lt;/p&gt;

&lt;p&gt;	#+begin_src org&lt;/p&gt;

&lt;p&gt;,#+BEGIN: clocktable :maxlevel 2 :emphasize nil :scope file&lt;/p&gt;

&lt;p&gt;,#+END: clocktable&lt;/p&gt;

&lt;p&gt;	#+end_src&lt;/p&gt;

&lt;p&gt;	BEGIN行及后面一系列的选项定义了范围,结构和报告的格式. 这些选项的默认值可以通过变量`org-clocktable-defaults`来配置.&lt;/p&gt;

&lt;p&gt;	第一类选项决定了哪些clock entry会被选入统计&lt;/p&gt;

&lt;p&gt;	#+begin_quote&lt;/p&gt;

&lt;p&gt;: maxlevel    Maximum level depth to which times are listed in the table.&lt;/p&gt;

&lt;p&gt;:              Clocks at deeper levels will be summed into the upper level.&lt;/p&gt;

&lt;p&gt;: scope       The scope to consider.  This can be any of the following:&lt;/p&gt;

&lt;p&gt;:              nil        the current buffer or narrowed region&lt;/p&gt;

&lt;p&gt;:              file       the full current buffer&lt;/p&gt;

&lt;p&gt;:              subtree    the subtree where the clocktable is located&lt;/p&gt;

&lt;p&gt;:              treeN      the surrounding level N tree, for example tree3&lt;/p&gt;

&lt;p&gt;:              tree       the surrounding level 1 tree&lt;/p&gt;

&lt;p&gt;:              agenda     all agenda files&lt;/p&gt;

&lt;p&gt;:              (&#34;file&#34;..) scan these files&lt;/p&gt;

&lt;p&gt;:              file-with-archives    current file and its archives&lt;/p&gt;

&lt;p&gt;:              agenda-with-archives  all agenda files, including archives&lt;/p&gt;

&lt;p&gt;: block       The time block to consider.  This block is specified either&lt;/p&gt;

&lt;p&gt;:              absolute, or relative to the current time and may be any of&lt;/p&gt;

&lt;p&gt;:              these formats:&lt;/p&gt;

&lt;p&gt;:              2007-12-31    New year eve 2007&lt;/p&gt;

&lt;p&gt;:              2007-12       December 2007&lt;/p&gt;

&lt;p&gt;:              2007-W50      ISO-week 50 in 2007&lt;/p&gt;

&lt;p&gt;:              2007-Q2       2nd quarter in 2007&lt;/p&gt;

&lt;p&gt;:              2007          the year 2007&lt;/p&gt;

&lt;p&gt;:              today, yesterday, today-N          a relative day&lt;/p&gt;

&lt;p&gt;:              thisweek, lastweek, thisweek-N     a relative week&lt;/p&gt;

&lt;p&gt;:              thismonth, lastmonth, thismonth-N  a relative month&lt;/p&gt;

&lt;p&gt;:              thisyear, lastyear, thisyear-N     a relative year&lt;/p&gt;

&lt;p&gt;:              Use S-&lt;left&gt;/&lt;right&gt; keys to shift the time interval.&lt;/p&gt;

&lt;p&gt;: tstart      A time string specifying when to start considering times.&lt;/p&gt;

&lt;p&gt;: tend        A time string specifying when to stop considering times.&lt;/p&gt;

&lt;p&gt;: step        week or day, to split the table into chunks.&lt;/p&gt;

&lt;p&gt;:              To use this, :block or :tstart, :tend are needed.&lt;/p&gt;

&lt;p&gt;: stepskip0   Do not show steps that have zero time.&lt;/p&gt;

&lt;p&gt;: fileskip0   Do not show table sections from files which did not contribute.&lt;/p&gt;

&lt;p&gt;: tags        A tags match to select entries that should contribute.  See&lt;/p&gt;

&lt;p&gt;:              Matching tags and properties for the match syntax.&lt;/p&gt;

&lt;p&gt;:&lt;/p&gt;

&lt;p&gt;	#+end_quote&lt;/p&gt;

&lt;p&gt;	第二类选项指定了table的展示形式. 这些选项默认由函数`org-clocktable-write-default`解释,但是我们也可以使用`:formatter`参数来指定由我们自定义的函数来解释[fn:80]&lt;/p&gt;

&lt;p&gt;	#+begin_quote&lt;/p&gt;

&lt;p&gt;: :emphasize   When t, emphasize level one and level two items.&lt;/p&gt;

&lt;p&gt;: :lang        Language(80) to use for descriptive cells like &#34;Task&#34;.&lt;/p&gt;

&lt;p&gt;: :link        Link the item headlines in the table to their origins.&lt;/p&gt;

&lt;p&gt;: :narrow      An integer to limit the width of the headline column in&lt;/p&gt;

&lt;p&gt;:              the org table.  If you write it like ‘50!’, then the&lt;/p&gt;

&lt;p&gt;:              headline will also be shortened in export.&lt;/p&gt;

&lt;p&gt;: :indent      Indent each headline field according to its level.&lt;/p&gt;

&lt;p&gt;: :tcolumns    Number of columns to be used for times.  If this is smaller&lt;/p&gt;

&lt;p&gt;:              than :maxlevel, lower levels will be lumped into one column.&lt;/p&gt;

&lt;p&gt;: :level       Should a level number column be included?&lt;/p&gt;

&lt;p&gt;: :compact     Abbreviation for :level nil :indent t :narrow 40! :tcolumns 1&lt;/p&gt;

&lt;p&gt;:              All are overwritten except if there is an explicit :narrow&lt;/p&gt;

&lt;p&gt;: :timestamp   A timestamp for the entry, when available.  Look for SCHEDULED,&lt;/p&gt;

&lt;p&gt;:              DEADLINE, TIMESTAMP and TIMESTAMP_IA, in this order.&lt;/p&gt;

&lt;p&gt;: :properties  List of properties that should be shown in the table.  Each&lt;/p&gt;

&lt;p&gt;:              property will get its own column.&lt;/p&gt;

&lt;p&gt;: :inherit-props When this flag is t, the values for :properties will be inherited.&lt;/p&gt;

&lt;p&gt;: :formula     Content of a #+TBLFM line to be added and evaluated.&lt;/p&gt;

&lt;p&gt;:              As a special case, ‘:formula %’ adds a column with % time.&lt;/p&gt;

&lt;p&gt;:              If you do not specify a formula here, any existing formula&lt;/p&gt;

&lt;p&gt;:              below the clock table will survive updates and be evaluated.&lt;/p&gt;

&lt;p&gt;: :formatter   A function to format clock data and insert it into the buffer.&lt;/p&gt;

&lt;p&gt;:&lt;/p&gt;

&lt;p&gt;	#+end_quote&lt;/p&gt;

&lt;p&gt;	要得到当天中当前level 1 tree的计时总计信息,你可以这样写&lt;/p&gt;

&lt;p&gt;	#+begin_src org&lt;/p&gt;

&lt;p&gt;,#+BEGIN: clocktable :maxlevel 2 :block today :scope tree1 :link t&lt;/p&gt;

&lt;p&gt;,#+END: clocktable&lt;/p&gt;

&lt;p&gt;	#+end_src&lt;/p&gt;

&lt;p&gt;	要统计指定的时间段的信息,则可以这样写[fn:81]&lt;/p&gt;

&lt;p&gt;	#+begin_src org&lt;/p&gt;

&lt;p&gt;,#+BEGIN: clocktable :tstart &#34;&lt;2006-08-10 Thu 10:00&gt;&#34;&lt;/p&gt;

&lt;p&gt;,                    :tend &#34;&lt;2006-08-10 Thu 12:00&gt;&#34;&lt;/p&gt;

&lt;p&gt;,#+END: clocktable&lt;/p&gt;

&lt;p&gt;,&lt;/p&gt;

&lt;p&gt;	#+end_src&lt;/p&gt;

&lt;p&gt;	要以百分比的形式展示当前子树的计时统计,可以这样写&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+BEGIN: clocktable :scope subtree :link t :formula %&lt;/p&gt;

&lt;p&gt;,#+END: clocktable&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;p&gt;	要水平地以紧凑模式来展示至上个星期以来的计时统计,可以这样写&lt;/p&gt;

&lt;p&gt;	#+begin_src org&lt;/p&gt;

&lt;p&gt;,#+BEGIN: clocktable :scope agenda :block lastweek :compact t&lt;/p&gt;

&lt;p&gt;,#+END: clocktable&lt;/p&gt;

&lt;p&gt;,&lt;/p&gt;

&lt;p&gt;	#+end_src&lt;/p&gt;

&lt;h3 id=&#34;识别空闲时间-识别出你未做工作的空闲时间&#34;&gt;识别空闲时间&lt;/h3&gt;

&lt;p&gt;	如果你正在对某项任务计时,在期间你离开电脑去接了个电话,通常情况下,你需要识别出你离开的那段时间并从计时统计中减去这段时间,或许还需要把这段时间计入其他的计时统计中.&lt;/p&gt;

&lt;p&gt;	通过配置变量`org-clock-idle-time`的值为某个整数,例如10或15,当你空闲时间超过这么多分钟之后[fn:82],Emacs会提醒你,并询问你要怎么处理这段空闲的时间. 你可以看到空闲时间的长度(不断的持续更新)和一系列的操作选项:&lt;/p&gt;

&lt;p&gt;	* k&lt;/p&gt;

&lt;p&gt;	  要将部分或者全部的离开时间计入正在计时的当前任务中,则键入k. Org随后会询问要将其中的多少分钟计入当前任务. 直接按回车表示所有时间都计入当前任务.&lt;/p&gt;

&lt;p&gt;	* K&lt;/p&gt;

&lt;p&gt;	  类似k,但会立刻停止对任务的计时&lt;/p&gt;

&lt;p&gt;	* s&lt;/p&gt;

&lt;p&gt;	  空闲时间不计入当前任务,并从你离开的时刻接着计时&lt;/p&gt;

&lt;p&gt;	* S&lt;/p&gt;

&lt;p&gt;	  类似s,但是会立刻停止计时. 记住无论哪个选项,连上shift键,都会立刻停止计时&lt;/p&gt;

&lt;p&gt;	* C&lt;/p&gt;

&lt;p&gt;	  撤销当前的计时统计. 需要注意的是,如果没有用C撤销计时,然而在把离开的时间剔除出去后发现剩余时间少于1分钟,则Emacs也会取消这次计时,这么做的目的是为了防止太多零散的计时统计.&lt;/p&gt;

&lt;p&gt;	那么,如果想把这段离开的时间作为一项新的计时统计又该怎么处理呢? 只要在减去这段离开时间后立刻对新任务进行计时,Org会注意到你有一段被减去的计时登记在册,然后它会询问是否要将这段计时信息计入新任务的计时中.&lt;/p&gt;

&lt;p&gt;	还存在这么一种可能,假设你正在对某项任务计时,突然电脑电源被关了,一瞬间,所有的buffer都消失了. 通过emacs的auto-saving机制,你可能恢复了最近的一些Org-mode的改变,包括最后的哪个clock in操作.&lt;/p&gt;

&lt;p&gt;	在这种情况下,如果你重启了Emacs,并且对任一任务进行计时时,Org会注意到上次session中留有一个悬空的clock in操作,然后Emacs会把该悬空的开始时间戳到现在的这段时间识别为空闲时间,并询问你的下一步操作. 其逻辑和行为与普通的空闲时间一致.&lt;/p&gt;

&lt;p&gt;	你也可以通过命令`M-x org-resolve-clocks`一次性检查所有在Org Agenda中注册过的Org文件中的悬挂clock in操作.&lt;/p&gt;

&lt;h2 id=&#34;工作量评估-提前规划工作成果&#34;&gt;工作量评估		   		   		   		:提前规划工作成果&lt;/h2&gt;

&lt;p&gt;如果你习惯以非常细致的方式作计划,或者你需要提供一份进度评估文档,则你会对每个任务进行进度上的评估. 如果你同时对你的工作进行计时,则随后可以对比进度计划与实际所费时间,这是改进进度评估的一个好方法. 评估所需时间的进度信息存储在属性`Effort`中[fn:83]. 你可以用一下命令来为任务设置进度安排(耗时评估)&lt;/p&gt;

&lt;p&gt;* C-c C-x e (org-set-effort)&lt;/p&gt;

&lt;p&gt;	 为当前任务设置进度安排(可以输入一个时间). 如果带有一个数字类型的前缀参数,则表示设置第N个可以的值(具体内容见下文). 也可以在agenda视图中用e快捷键调用该函数&lt;/p&gt;

&lt;p&gt;* C-c C-x C-e (org-clock-modify-effort-estimate)&lt;/p&gt;

&lt;p&gt;	 修改正在计时的任务的耗时评估&lt;/p&gt;

&lt;p&gt;很明显,最好是使用Column视图的方式来展示进度评估(参见&lt;a href=&#34;#Column视图&#34; title=&#34;Column视图&#34;&gt;Column视图&lt;/a&gt;). 你可以为耗时评估设定多个值,再加上一个COLUMNS格式属性用来展示这些估计值与相关的计时信息(如果你想要对任务进行计时的话). 例如你可以这样设置:&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+PROPERTY: Effort_ALL 0 0:10 0:30 1:00 2:00 3:00 4:00 5:00 6:00 7:00&lt;/p&gt;

&lt;p&gt;,#+COLUMNS: %40ITEM(Task) %17Effort(Estimated Effort){:} %CLOCKSUM&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;你也可以全局地设定这两个值,方法是分别设定变量`org-global-properties`和`org-columns-default-format`. 这在当你想在agenda中使用该配置时特别有用.&lt;/p&gt;

&lt;p&gt;一种为任务分配耗时评估的方法是切换到column-mode,然后用S-&lt;right&gt;和S-&lt;left&gt;来改变耗时评估的值. 子任务的耗时评估会自动累加到父任务的耗时评估中. 在耗时评估的后一列会显示实际的计时统计信息.&lt;/p&gt;

&lt;p&gt;如果你在daily/weekly agenda中切换到column view的话, effort这一列会累加每天的耗时评估[fn:84],你可以使用这项功能来找出计划安排中的空闲时间. 如果想查看指定日期的总体情况,可以设置选项`org-agenda-columns-add-appointments-to-effort-sum`. 则那一天已经开始一段时间的会议也会添加到负荷评估中&lt;/p&gt;

&lt;p&gt;耗时评估也可以在secondary agenda filtering(次要日程过滤??)中使用,在agenda中使用`/`键就能出发该过滤功能(参见&lt;a href=&#34;#Commands in the agenda buffer&#34; title=&#34;Commands in the agenda buffer&#34;&gt;Commands in the agenda buffer&lt;/a&gt;). If you have these estimates defined consistently, two or three key presses will narrow down the list to stuff that fits into an available time slot. (这句话的意思,我是连猜都猜不出来了~)&lt;/p&gt;

&lt;h2 id=&#34;作记录的同时打开相对计时器-带计时器的笔记&#34;&gt;作记录的同时打开相对计时器&lt;/h2&gt;

&lt;p&gt;当作会议纪要时,可能会需要记录会议开始后的xx时间某某发了一个什么言. Org提供了一个相对计时器的功能可以帮助记录xx时间.&lt;/p&gt;

&lt;p&gt;* C-c C-x . (org-timer) ::&lt;/p&gt;

&lt;p&gt;		插入相对时间. 第一次执行该命令时会同时启动相对计时器,并把即使重置为0. 若带了prefix argument则将相对计时器重置为0&lt;/p&gt;

&lt;p&gt;* C-c C-x - (org-timer-item) ::&lt;/p&gt;

&lt;p&gt;		插入一段description list item,同时也记录下相对时间. 若带了prefix argument,则首先将相对计时器重置为0&lt;/p&gt;

&lt;p&gt;* M-&lt;RET&gt; (org-insert-heading) ::&lt;/p&gt;

&lt;p&gt;		一旦已经插入list item,则可以用M-&lt;RET&gt;插入新的list item&lt;/p&gt;

&lt;p&gt;* C-c C-x , (org-timer-pause-or-continue) ::&lt;/p&gt;

&lt;p&gt;		暂停/继续相对计时器&lt;/p&gt;

&lt;p&gt;* Cu C-c C-x , ::&lt;/p&gt;

&lt;p&gt;		停止相对计时器. 之后你就只能重新开始一个新计时器了. 该命令也会把计时器从mode-line上移除&lt;/p&gt;

&lt;p&gt;* C-c C-x 0 (org-timer-start) ::&lt;/p&gt;

&lt;p&gt;		重置相对计时器,但并不将相对时间插入到buffer中. 默认情况下相对计时器重置为0,但可以带C-u的方式来重置相对计时器到特定的开始时间. 使用C-u C-u双prefix argument的方式调用该命令,则会同时对选中范围的所有相对时间信息进行修改.&lt;/p&gt;

&lt;h2 id=&#34;倒计时计时器-为任务倒计时&#34;&gt;倒计时计时器&lt;/h2&gt;

&lt;p&gt;在Org-mode下运行`org-timer-set-timer`会调起一个倒计时计时器. 若你在agenda buffer中可以用键`;`调用,其他情况下可以用键序列`C-c Cx ;`.&lt;/p&gt;

&lt;p&gt;命令`org-timer-set-timer`会提示用户输入倒计时的时间,然后在mode-line上显示倒计时的信息. 变量`org-timer-default-timer`设置了默认的倒计时的时间值. 使用prefix numeric argument会覆盖该值.&lt;/p&gt;

&lt;h1 id=&#34;capture-捕获-refile-整理-archive-归档&#34;&gt;Capture(捕获) - Refile(整理) - Archive(归档)&lt;/h1&gt;

&lt;p&gt;任何一个整理系统都需要具有快速快速捕获创意和任务,并将其与相关资料链接的能力. Org为该功能实现了名为capture的流程. 它还能够将任务(附件)相关的文件存储在某个特定目录下. 在这套系统中,被处理的对象是任务和项目. 通过将已完成的项目整个移动到归档文件中,可以保持系统的紧凑和快速.&lt;/p&gt;

&lt;h2 id=&#34;capture-捕获新事物&#34;&gt;Capture&lt;/h2&gt;

&lt;p&gt;Capture使得你能够在几乎不打断工作流的情况下快速存储记录. Org捕获新事物的方式深受John Wiegley的remember.el的影响. 自从version6.36开始,org通过配置与remember.el协同工作,随后用org-rembember.el替代rembember.el. 到了8.0版本,org-remember.el完全被org-capture.el所代替.&lt;/p&gt;

&lt;p&gt;如果你的配置文件还是以org-remember.el为基础进行配置的,则你需要用一下方法来升级你的配置文件. 要转换你的org-remember-templates变量,执行命令&lt;/p&gt;

&lt;p&gt;#+BEGIN_QUOTE&lt;/p&gt;

&lt;p&gt;M-x org-capture-import-remember-templates,然后保存org-capture-templates的值&lt;/p&gt;

&lt;p&gt;#+END_QUOTE&lt;/p&gt;

&lt;h3 id=&#34;配置capture-记录保存在哪里&#34;&gt;配置capture&lt;/h3&gt;

&lt;p&gt;	下面的配置设置了一个默认的记录文件并且定义一个全局热键[fn:85]来捕获新资料.&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;(setq org-default-notes-file (concat org-directory &#34;/notes.org&#34;))&lt;/p&gt;

&lt;p&gt;(define-key global-map &#34;\C-cc&#34; &#39;org-capture)&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;h3 id=&#34;使用capture-调用和结束capture的命令&#34;&gt;使用capture&lt;/h3&gt;

&lt;p&gt;	* C-c c (org-capture) ::&lt;/p&gt;

&lt;p&gt;		 注意,该键绑定是全局性的,然而默认情况下却没有激活:你需要手工安装该键绑定. 如果你定义了capture模板,则它会提示你选择其中一个模板或这使用默认模板,当你选择了某个模板后会进入一个新的capture buffer. 随后你可以在其中输入要保存的信息.&lt;/p&gt;

&lt;p&gt;	* C-c C-c (org-capture-finalize) ::&lt;/p&gt;

&lt;p&gt;		 在capture buffer中输入完了要保存的信息后,按C-c C-c会保存记录并退出capture buffer,并且会还原capture前的工作状态,这样你可以继续以前的工作. 若带有prefix arg,则该命令保存好记录后,会跳转到保存新记录的地方.&lt;/p&gt;

&lt;p&gt;	* C-c C-w (org-capture-refile) ::&lt;/p&gt;

&lt;p&gt;		 使用refile&lt;a href=&#34;Refile and copy&#34; title=&#34;(参见Refile and copy)&#34;&gt;(参见Refile and copy)&lt;/a&gt;流程代替capture流程. 该命令实际执行的是普通的refile命令,因此执行该命令时需要注意光标所在的位置. 该命令会把接收到的prefix argument传递給org-refile命令&lt;/p&gt;

&lt;p&gt;	* C-c C-k (org-capture-kill) ::&lt;/p&gt;

&lt;p&gt;		 取消capture这个动作,还原到之前的状态&lt;/p&gt;

&lt;p&gt;	在agenda中按k键也可以调用org-capture命令. 通过这种方式调用的org-capture,模板中的日期会插入agenda中光标所处的日期,而不是当前日期.&lt;/p&gt;

&lt;p&gt;	要找到最后存储的capture的位置,使用带prefix arg的org-capture命令&lt;/p&gt;

&lt;p&gt;	* C-u C-c c&lt;/p&gt;

&lt;p&gt;	  定位到指定capture模板的最后存储位置&lt;/p&gt;

&lt;p&gt;	* C-u C-u C-c c&lt;/p&gt;

&lt;p&gt;	  在当前buffer地打开最后一次capture存储的位置&lt;/p&gt;

&lt;p&gt;	要在当前buffer插入capture的记录,使用C-0 prefix argument来调用org-capture命令&lt;/p&gt;

&lt;h3 id=&#34;capture模版-定义不同类型记录的大纲结构&#34;&gt;capture模版&lt;/h3&gt;

&lt;p&gt;	你可以为不同类型的记录定义不同的模板和存储位置. 创建模板的最简单的方法就是通过customize界面进行.&lt;/p&gt;

&lt;p&gt;	* C-c c C&lt;/p&gt;

&lt;p&gt;	  用customize界面自定义变量`org-capture-templates`&lt;/p&gt;

&lt;p&gt;	在对模板定义进行正式描述之前,让我们来看一个例子. 假设你向定义一个模板来创建一个TODO事项,创建的TODO事项放到名为`Tasks`的heading下并存储在文件`~/org/gtd.org`中, 同时你需要捕获日记并以datetree的形式存入journal.org中,则你可以使用下面的配置信息.&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;(setq org-capture-templates&lt;/p&gt;

&lt;p&gt;&#39;((&#34;t&#34; &#34;Todo&#34; entry (file+headline &#34;~/org/gtd.org&#34; &#34;Tasks&#34;)&lt;/p&gt;

&lt;p&gt;&#34;* TODO %?\n  %i\n  %a&#34;)&lt;/p&gt;

&lt;p&gt;(&#34;j&#34; &#34;Journal&#34; entry (file+datetree &#34;~/org/journal.org&#34;)&lt;/p&gt;

&lt;p&gt;&#34;* %?\nEntered on %U\n  %i\n  %a&#34;)))&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;p&gt;	这时,如果你按下C-c c t,Org会自动生产一个模板:&lt;/p&gt;

&lt;p&gt;	#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;	* TODO&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;link to where you initiated capture&#34; alt=&#34;link to where you initiated capture&#34; title=&#34;link to where you initiated capture&#34; /&gt;&lt;/p&gt;

&lt;p&gt;	#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;	在扩展模板时,%a的表示你调用capture命令时的位置链接. 当你从email中派生任务时,该链接就特别有用.&lt;/p&gt;

&lt;p&gt;	要为某个特定的模板定义快捷键而不用经过模板选择界面,你可以这样定义键绑定:&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;(define-key global-map &#34;\C-cx&#34;&lt;/p&gt;

&lt;p&gt;(lambda () (interactive) (org-capture nil &#34;x&#34;)))&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;h4 id=&#34;组成模板的各个元素-一个完整的模板有哪些部分组成&#34;&gt;组成模板的各个元素&lt;/h4&gt;

&lt;p&gt;	 CLOCK: [2014-06-15 周日 11:52]--[2014-06-15 周日 11:54] =&gt;  0:02&lt;/p&gt;

&lt;p&gt;	 CLOCK: [2014-06-15 周日 11:47]--[2014-06-15 周日 11:50] =&gt;  0:03&lt;/p&gt;

&lt;p&gt;	 现在让我们来看看模板定义中的各个元素. `org-capture-templates`中的每个entry都是一个列表,由下面几个部分组成:&lt;/p&gt;

&lt;p&gt;	 * Keys&lt;/p&gt;

&lt;p&gt;	   keys用来选择某个特定的模板,它是一个由字母组成的字符串,例如&#34;a&#34;表示按下a键就会选择对应的模板,而&#34;bt&#34;表示按下&#34;bt&#34;这两个键会选择对应的模板. 拥有相同prefix key的keys必须依次排列在list中,并且预先要有一个由2个元素组成的entry来解释prefix key. 下面是一个解释prefix key的entry的例子&lt;/p&gt;

&lt;p&gt;	   #+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;(&#34;b&#34; &#34;Templates for marking stuff to buy&#34;)&lt;/p&gt;

&lt;p&gt;	   #+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;	   若你没有手工将&#34;C&#34;定义为某个模板的key,则它会用来自定义`org-capture-templates`变量.&lt;/p&gt;

&lt;p&gt;	 * description&lt;/p&gt;

&lt;p&gt;	   关于模板的简短描述,会在选择template界面上显示.&lt;/p&gt;

&lt;p&gt;	 * type&lt;/p&gt;

&lt;p&gt;	   type为一个symbol,有效值为:&lt;/p&gt;

&lt;p&gt;	   * entry&lt;/p&gt;

&lt;p&gt;		 表示Org-mode下的一个heading节点. 若target中定义了节点,则会在target节点下创建子节点,否则创建一个顶级节点. 这里target文件必须是一个Org-mode文件.&lt;/p&gt;

&lt;p&gt;	   * item&lt;/p&gt;

&lt;p&gt;		 表示plain list item. 会添加在target location下的第一个plain list位置处. 同样的,target file必须是Org文件&lt;/p&gt;

&lt;p&gt;	   * checkitem&lt;/p&gt;

&lt;p&gt;		 类似item,但是它表示checkbox item&lt;/p&gt;

&lt;p&gt;	   * table-line&lt;/p&gt;

&lt;p&gt;		 表示表格的一行. 它会添加到target location的第一个表格中. 根据属性(下面会提到)为`:prepend` 和`:table-line-pos`的不同,决定该行放置在表格的具体哪个位置.&lt;/p&gt;

&lt;p&gt;	   * plain&lt;/p&gt;

&lt;p&gt;		 纯文本&lt;/p&gt;

&lt;p&gt;	 * target&lt;/p&gt;

&lt;p&gt;	   指定被捕获的记录所存放的位置. 在Org-mode文件中,targets通常定义为一个node,被捕获的entry放到该node下. 它还可以是一个table或者是一个list. 大多数target定义时都会包含一个文件名. 但若该文件名为空字符串,则默认使用`org-default-notes-file`表示的文件. 该指定的文件不仅可以由变量指代,还能由函数,Emacs Lisp Form指代.&lt;/p&gt;

&lt;p&gt;	   target的可选格式有:&lt;/p&gt;

&lt;p&gt;	   * (file &#34;path/to/file&#34;)&lt;/p&gt;

&lt;p&gt;		 被捕获的内容会被放置在file的开头/结尾处&lt;/p&gt;

&lt;p&gt;	   * (id &#34;id of existing org entry&#34;)&lt;/p&gt;

&lt;p&gt;		 被捕获的内容作为该entry的子节点,或插入到entry的body中&lt;/p&gt;

&lt;p&gt;	   * (file+heading &#34;path/to/file&#34; &#34;node heading&#34;)&lt;/p&gt;

&lt;p&gt;		 被捕获的内容放置在该file的指定heading下,但需要保证指定的heading在file中是唯一的.&lt;/p&gt;

&lt;p&gt;	   * (file+olp &#34;path/to/file&#34; &#34;level 1 heading&#34; &#34;level 2 heading&#34; ...)&lt;/p&gt;

&lt;p&gt;		 若file中存在同名的heading,则使用该方法加以明确&lt;/p&gt;

&lt;p&gt;	   * (file+regexp &#34;path/to/file&#34; &#34;regexp to find location&#34;)&lt;/p&gt;

&lt;p&gt;		 使用正则表达式来定位&lt;/p&gt;

&lt;p&gt;	   * (file+datetree &#34;path/to/file&#34;)&lt;/p&gt;

&lt;p&gt;		 在date tree上用今天的日期创建一个heading&lt;/p&gt;

&lt;p&gt;	   * (file+datetree+prompt &#34;path/to/file&#34;)&lt;/p&gt;

&lt;p&gt;		 在date tree上用指定的日期创建一个heading,会提示你输入日期&lt;/p&gt;

&lt;p&gt;	   * (file+function &#34;path/to/file&#34; function-finding-location)&lt;/p&gt;

&lt;p&gt;		  用函数来定位&lt;/p&gt;

&lt;p&gt;	   * (clock)&lt;/p&gt;

&lt;p&gt;		 定位到正在被计时的entry处&lt;/p&gt;

&lt;p&gt;	   * (function function-finding-location)&lt;/p&gt;

&lt;p&gt;		 用函数来定位存储文件和位置&lt;/p&gt;

&lt;p&gt;	 * template&lt;/p&gt;

&lt;p&gt;	   模板内容. 若内容为空,则会使用默认的模板内容. 模板内容可以是一个字符串,也可以通过(file &#34;path/to/template&#34;)这样的语法表示从外部文件中读取模板内容.&lt;/p&gt;

&lt;p&gt;	 * properties&lt;/p&gt;

&lt;p&gt;	   剩下的内容是一些附加属性list:&lt;/p&gt;

&lt;p&gt;	   * :prepend&lt;/p&gt;

&lt;p&gt;		 通常情况下,新捕获的内容会附加在target location的后面,而该属性会添加在target location的前面&lt;/p&gt;

&lt;p&gt;	   * :immediate-finish&lt;/p&gt;

&lt;p&gt;		 该属性表示不需要显示capture buffer给用户输入更多的信息.直接返回就好. 若所有的信息都能够通过模板变量自动获得的情况下可以使用&lt;/p&gt;

&lt;p&gt;	   * :empty-lines&lt;/p&gt;

&lt;p&gt;		 插入新捕获的内容时,前后空出多少个空行.&lt;/p&gt;

&lt;p&gt;	   * :clock-in&lt;/p&gt;

&lt;p&gt;		 为新捕获的item开始计时&lt;/p&gt;

&lt;p&gt;	   * :clock-keep&lt;/p&gt;

&lt;p&gt;		 若设置了clock-in,则在capture动作完成后,依然保持计时器的继续运行&lt;/p&gt;

&lt;p&gt;	   * :clock-resume&lt;/p&gt;

&lt;p&gt;		 若capture操作中断了对之前任务的计时,则在完成capture操作之后继续对之前任务进行计时.&lt;/p&gt;

&lt;p&gt;		 需要注意的是,:clock-keep的优先级高于:clock-resume,若两者都设置为t,则当前计时器会启动,而前一个计时器不会继续运行.&lt;/p&gt;

&lt;p&gt;	   * :unnarrowed&lt;/p&gt;

&lt;p&gt;		 不要narrow target buffer,显示target buffer的所有内容. 默认情况下会narrow target buffer,让它只显示捕获新事物的那节点内容&lt;/p&gt;

&lt;p&gt;	   * :table-line-pos&lt;/p&gt;

&lt;p&gt;		 设置capture的内容插入到table的位置. 它的格式类似于&#34;II-3&#34;,表示它是表格中第二部分(以-------分隔)的第三行&lt;/p&gt;

&lt;p&gt;	   * :kill-buffer&lt;/p&gt;

&lt;p&gt;		 若target file是未打开的状态,则在capture完成之后,自动kill掉新打开的buffer&lt;/p&gt;

&lt;h4 id=&#34;模板扩展-插入时间和上下文的相关信息&#34;&gt;模板扩展&lt;/h4&gt;

&lt;p&gt;	 模板内容中可以有一些以%[fn:86]开头的特殊变量,当对模板进行扩展时,会动态插入它所表示的值&lt;/p&gt;

&lt;p&gt;	 #+CAPTION:通用变量&lt;/p&gt;

&lt;p&gt;| %[file]    | 插入file的内容能够                                                                                                                              |&lt;/p&gt;

&lt;p&gt;| %(sexp)    | 插入sexp的返回值,sexp必须返回字符串                                                                                                             |&lt;/p&gt;

&lt;p&gt;| %&lt;...&gt;     | 按...表示的格式插入时间戳信息....的格式参见format-time-string函数说明                                                                           |&lt;/p&gt;

&lt;p&gt;| %t         | 插入日期                                                                                                                                        |&lt;/p&gt;

&lt;p&gt;| %T         | 插入日期与时间                                                                                                                                  |&lt;/p&gt;

&lt;p&gt;| %u, %U     | 类似%t和%T,但是插入的时间戳是inactive的(以[]括起来的)                                                                                           |&lt;/p&gt;

&lt;p&gt;| %a         | 注释,一般情况下是函数org-store-link创建的链接.                                                                                                  |&lt;/p&gt;

&lt;p&gt;| %i         | 若调用capture命令时,有选中内容,则插入选中内容                                                                                                   |&lt;/p&gt;

&lt;p&gt;| %A         | 类似%a,但会提示输入链接的描述部分                                                                                                               |&lt;/p&gt;

&lt;p&gt;| %c         | kill-ring中的当前内容能够                                                                                                                       |&lt;/p&gt;

&lt;p&gt;| %x         | 粘贴板的内容                                                                                                                                    |&lt;/p&gt;

&lt;p&gt;| %k         | 当前正在计时的任务title                                                                                                                         |&lt;/p&gt;

&lt;p&gt;| %K         | 当前正在计时的任务的链接                                                                                                                        |&lt;/p&gt;

&lt;p&gt;| %n         | 用户名,变量(user-full-name的值                                                                                                                  |&lt;/p&gt;

&lt;p&gt;| %f         | capture命令调用时当前buffer所对应的文件名                                                                                                       |&lt;/p&gt;

&lt;p&gt;| %F         | 类似%f,但显示全路径                                                                                                                             |&lt;/p&gt;

&lt;p&gt;| %^g        | 提示输入tag,使用target file中的tags列表作为可选项                                                                                               |&lt;/p&gt;

&lt;p&gt;| %^G        | 提示输入tag,使用agenda中所有注册的file中的tags列表作为可选项                                                                                    |&lt;/p&gt;

&lt;p&gt;| %^t        | 类似 %t, 但是会提示你输入日期.  同样的还%^T, %^u, %^U. 这几个变量. 还可以用类似%^{birthday}t这样的格式来为提示做出说明                          |&lt;/p&gt;

&lt;p&gt;| %^C        | Interactive selection of which kill or clip to use.                                                                                             |&lt;/p&gt;

&lt;p&gt;| %^L        | Like %^C, but insert as link.                                                                                                                   |&lt;/p&gt;

&lt;p&gt;| %^{prop}p  | 提示用户为名为prop的属性赋值                                                                                                                    |&lt;/p&gt;

&lt;p&gt;| %^{prompt} | 提示用户输入某个字符串. 还可以为用户提供默认值和补全值,格式为%^{prompt竖线default竖线completion2竖线completion3...}. 使用方向键可以选择历史数据 |&lt;/p&gt;

&lt;p&gt;|            |                                                                                                                                                 |&lt;/p&gt;

&lt;p&gt;	 还有一些变量是与特定的link type[fn:87]所特有的&lt;/p&gt;

&lt;p&gt;	 #+CAPTION:与link type有关的变量&lt;/p&gt;

&lt;p&gt;| Link type              | Available keywords                                     |&lt;/p&gt;

&lt;p&gt;|------------------------+--------------------------------------------------------|&lt;/p&gt;

&lt;p&gt;| bbdb                   | %:name %:company                                       |&lt;/p&gt;

&lt;p&gt;| irc                    | %:server %:port %:nick                                 |&lt;/p&gt;

&lt;p&gt;| vm, wl, mh, mew, rmail | %:type %:subject %:message-id                          |&lt;/p&gt;

&lt;p&gt;|                        | %:from %:fromname %:fromaddress                        |&lt;/p&gt;

&lt;p&gt;|                        | %:to   %:toname   %:toaddress                          |&lt;/p&gt;

&lt;p&gt;|                        | %:date (message date header field)                     |&lt;/p&gt;

&lt;p&gt;|                        | %:date-timestamp (date as active timestamp)            |&lt;/p&gt;

&lt;p&gt;|                        | %:date-timestamp-inactive (date as inactive timestamp) |&lt;/p&gt;

&lt;p&gt;|                        | %:fromto (either &#34;to NAME&#34; or &#34;from NAME&#34;)[fn:88]      |&lt;/p&gt;

&lt;p&gt;| gnus                   | %:group, for messages also all email fields            |&lt;/p&gt;

&lt;p&gt;| w3, w3m                | %:url                                                  |&lt;/p&gt;

&lt;p&gt;| info                   | %:file %:node                                          |&lt;/p&gt;

&lt;p&gt;| calendar               | %:date                                                 |&lt;/p&gt;

&lt;p&gt;	 要定义扩展模板后,光标所在的位置,用%?表示光标的位置.&lt;/p&gt;

&lt;h4 id=&#34;与上下文相关的模板-只在特定的上下文环境中显示模板&#34;&gt;与上下文相关的模板&lt;/h4&gt;

&lt;p&gt;	 通过定义变量`org-capture-templates-contexts`可以让模板只在特定的上下文环境中才有效.&lt;/p&gt;

&lt;h2 id=&#34;attachments-为任务增加附件&#34;&gt;Attachments&lt;/h2&gt;

&lt;p&gt;:PROPERTIES:&lt;/p&gt;

&lt;p&gt;:ID:       cce16e0b-f200-436f-bcf8-3f47ef3feca5&lt;/p&gt;

&lt;p&gt;:END:&lt;/p&gt;

&lt;p&gt;通常我们会为任务/节点添加相关材料. 少量的纯文本说明可以存储在节点内. 使用超链接可以连接到云端/本地的其他文件上.&lt;/p&gt;

&lt;p&gt;还有一种方法就是为任务/节点添加附件. 所谓附件是指存储在outline node所属目录中的文件. Org使用每个entry的unique ID作为目录名称,这些目录存放在org文件所属目录的data子目录下. 若该目录纳入了git版本控制中,则org会在目录发生改变后,自动commit&lt;/p&gt;

&lt;p&gt;文件和目录都可以作为附件添加到某个entry上. 甚至还可以让子节点继承父节点的attachment directory(存放附件的目录),这样整个子树都使用相同的存放附件的目录&lt;/p&gt;

&lt;p&gt;下面是附件相关的命令&lt;/p&gt;

&lt;p&gt;* C-c C-a (org-attach)&lt;/p&gt;

&lt;p&gt;	 为entry添加附件的同一接口,该命令会提示你选择用哪种方法为entry添加附件&lt;/p&gt;

&lt;p&gt;* a (org-attach-attach)&lt;/p&gt;

&lt;p&gt;	   选择附件文件,并将它移动到该entry存放附件的目录中. 根据变量`org-attach-method`的不同,附件会拷贝/移动/链接到attachment directory中. 需要注意的是,不是所有的操作系统都支持硬链接.&lt;/p&gt;

&lt;p&gt;	 * c/m/l&lt;/p&gt;

&lt;p&gt;	   指定用拷贝/移动/链接的方式将附件存放在该entry存放附件的目录中.&lt;/p&gt;

&lt;p&gt;	 * n (org-attach-new)&lt;/p&gt;

&lt;p&gt;	   创建一个Emacs buffer作为新附件&lt;/p&gt;

&lt;p&gt;	 * z (org-attach-sync)&lt;/p&gt;

&lt;p&gt;	   同步attachment directory中的附件信息. 若你手工添加了附件到attachment directory中则该命令很有用&lt;/p&gt;

&lt;p&gt;	 * o (org-attach-open)&lt;/p&gt;

&lt;p&gt;	   打开当前entry的附件. 若有多个附件,则会提示你具体打开那个附件. 用来打开附件的程序由变量`org-file-apps`决定.&lt;/p&gt;

&lt;p&gt;	 * O (org-attach-open-in-emacs)&lt;/p&gt;

&lt;p&gt;	   类似o,但是强制用emacs打开附件&lt;/p&gt;

&lt;p&gt;	 * f (org-attach-reveal)&lt;/p&gt;

&lt;p&gt;	   打开当前entry用来存放附件的目录&lt;/p&gt;

&lt;p&gt;	 * F (org-attach-reveal-in-emacs)&lt;/p&gt;

&lt;p&gt;	   类似f,但是前置用emacs的dired打开目录&lt;/p&gt;

&lt;p&gt;	 * d (org-attach-delete-one)&lt;/p&gt;

&lt;p&gt;	   删除某个附件&lt;/p&gt;

&lt;p&gt;	 * D (org-attach-delete-all)&lt;/p&gt;

&lt;p&gt;	   删除该entry的所有附件. 一个更安全的方法是用dired打开存放附件的目录,然后手工删除所有附件&lt;/p&gt;

&lt;p&gt;	 * s (org-attach-set-directory)&lt;/p&gt;

&lt;p&gt;	   为该entry设置指定的目录作为存放附件的目录. 该命令通过为entry设置ATTACH_DIR属性来完成这一任务.&lt;/p&gt;

&lt;p&gt;	 * i (org-attach-set-inherit)&lt;/p&gt;

&lt;p&gt;	   设置ATTACH_DIR_INHERIT属性,这样所有的子节点会使用父节点的attachement directory&lt;/p&gt;

&lt;h2 id=&#34;rss-feeds-从rss-feeds中获取输入&#34;&gt;RSS Feeds&lt;/h2&gt;

&lt;p&gt;通过配置`org-feed-alist`的至，Org可以根据RSS feeds和Atom feeds中的数据新增/改变entry的内容。下面是一个配置的例子&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;(setq org-feed-alist&lt;/p&gt;

&lt;p&gt;&#39;((&#34;Slashdot&#34;&lt;/p&gt;

&lt;p&gt;&#34;http://rss.slashdot.org/Slashdot/slashdot&#34;&lt;/p&gt;

&lt;p&gt;&#34;~/txt/org/feeds.org&#34; &#34;Slashdot Entries&#34;)))&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;上面的例子会使得rss.slashdot.org的feed中的item同步到文件～/org/feeds.org的名为`Slashdot Entries`的heading下。&lt;/p&gt;

&lt;p&gt;下面是一些相关的命令&lt;/p&gt;

&lt;p&gt;* C-c C-x g (org-feed-update-all)&lt;/p&gt;

&lt;p&gt;同步org-feed-alist中配置feeds的item到Org文件中&lt;/p&gt;

&lt;p&gt;* C-c C-x G (org-feed-goto-inbox)&lt;/p&gt;

&lt;p&gt;提示你输入一个feed的名称，然后跳转到对于的Org文件&lt;/p&gt;

&lt;p&gt;在同名的heading下，Org会创建一个名为`FEEDSTATUS`的drawer，并在其中存储关于feed中item的状态，这样就能避免同一个item多次添加的情况出现。 因此你需要添加`FEEDSTATUS`到Org文件的drawer列表中。例如&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+DRAWERS: LOGBOOK PROPERTIES FEEDSTATUS&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;更详细的信息请阅读org-feed.el和org-feed-alist的docstring&lt;/p&gt;

&lt;h2 id=&#34;protocols-从外部程序-例如浏览器-获取信息&#34;&gt;Protocols&lt;/h2&gt;

&lt;p&gt;外部程序可以根据一定的协议规则通过emacsserver向Org传递要处理的消息。 详细信息请参见 http://orgmode.org/worg/org-contrib/org-protocol.php&lt;/p&gt;

&lt;h2 id=&#34;refile-and-copy-移动-拷贝tree从一个地方到另一个地方&#34;&gt;Refile and copy&lt;/h2&gt;

&lt;p&gt;当回顾捕获到的资料时，常常会对资料进行整理。若要手工完成那些剪切，定位，复制操作则显得太繁琐了。Org提供了以下一些命令帮助我们完成整理的动作&lt;/p&gt;

&lt;p&gt;* C-c C-w (org-refile)&lt;/p&gt;

&lt;p&gt;移动当前entry/region到其他地方。 该命令会告诉你有哪些可以被转移的位置（target）可选，并提供相关的补全功能。 被移动的item（或region中所有的item）会移动到target heading下作为它的子节点。 而根据变量`org-reverse-note-order`的值的不同，可能是作为第一个子节点或最后一个子节点。&lt;/p&gt;

&lt;p&gt;默认情况下，被转移到的target位置为当前buffer的一级heading，但是你也可以自定义target到其他文件。要了解详细信息，请参见变量`org-refile-targets`. 若你希望在选择target location时以路径的方式表示文件内的heading（例如file.org/Heading1/heaindg2表示file.org中的一级标题heading1下的二级标题heading2），请配置变量`org-refile-use-outline-path`和`org-outline-path-complete-in-steps`。 如果你希望移动到一个不存在target location时可以新建node，则配置变量`org-refile-allow-creating-parent-nodes`。 若设置了变量`org-log-refile`，则当一个entry被refile时会记录下当前的时间戳信息。&lt;/p&gt;

&lt;p&gt;* C-c M-w （org-copy）&lt;/p&gt;

&lt;p&gt;类似org-refile，但源entry/region不会被删除&lt;/p&gt;

&lt;p&gt;* C-u C-c C-w&lt;/p&gt;

&lt;p&gt;使用refile界面来跳转到target的heading处&lt;/p&gt;

&lt;p&gt;* C-u C-u C-c C-w (org-refile-goto-last-stored)&lt;/p&gt;

&lt;p&gt;跳转到最后refile的target location&lt;/p&gt;

&lt;p&gt;* C-2 C-c C-w&lt;/p&gt;

&lt;p&gt;把entry/region移动到正在计时的item之下&lt;/p&gt;

&lt;p&gt;* C-3 C-c C-w&lt;/p&gt;

&lt;p&gt;移动entry时保留原entry在原处（Refile and keep the entry in place.） 通过配置变量`org-refile-keep`可以设置该动作为refile的默认动作。 不过需要注意的是，该操作可能会导致重复的ID属性。&lt;/p&gt;

&lt;p&gt;* C-0 C-c C-w / C-u C-u C-u C-c C-w (org-refile-cache-clear)&lt;/p&gt;

&lt;p&gt;清理target cache。 通过设置变量`org-refile-use-cache`可以开启缓存refile target的功能。 开始了该功能后，需要用该命令清空refile target缓冲区才能让命令看见新的refile target&lt;/p&gt;

&lt;h2 id=&#34;archiving-处理已完成的项目&#34;&gt;Archiving&lt;/h2&gt;

&lt;p&gt;若某个项目完成了，你可能会把代表该项目的tree移开，不要让它再在agenda中出现。 该动作由归档命令来完成。&lt;/p&gt;

&lt;p&gt;* C-c C-x C-a (org-archive-subtree-defaut)&lt;/p&gt;

&lt;p&gt;使用变量`org-archive-defaullt-command`中定义的命令对当前entry进行归档&lt;/p&gt;

&lt;h3 id=&#34;移动tree到另一个归档文件中&#34;&gt;移动tree到另一个归档文件中&lt;/h3&gt;

&lt;p&gt;最常用的归档动作是将某project tree移动到另一个归档文件中&lt;/p&gt;

&lt;p&gt;* C-c C-x C-s / C-c $ (org-archive-subtree)&lt;/p&gt;

&lt;p&gt;将光标位置为起始位置的子树归档到变量`org-archive-location`指定的位置&lt;/p&gt;

&lt;p&gt;* C-u C-c C-x C-s&lt;/p&gt;

&lt;p&gt;检查当前headline是否有可以归档的直接子节点。 Org通过对每个subtree检查是否有未完成事项，若未找到，则该命令提示你是否将其归档。 若调用该命令时光标不在headline的位置，则第一级的tree会被检查。&lt;/p&gt;

&lt;p&gt;默认情况下，归档的地址是同一目录下的当前文件名后接`_archive`的文件。你也可以为某个heading指定单独的归档地址。更详细的信息请参见变量`org-archive-location`的docstring。&lt;/p&gt;

&lt;p&gt;也可以为单个buffer设置该变量的值，例如&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;,#+ARCHIVE: %s_done::&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;若你想为单个的entry或subtree定义自己的归档地址，则给他们定义名为`：ARCHIVE：`属性，并使用归档地址作为其值&lt;/p&gt;

&lt;p&gt;subtree被归档时，同时会有大量的属性记录下当时的上下文信息。例如被归档的entry所属的文件，大纲路径，归档时间等。 可以通过配置变量`org-archive-save-context-info`来调整有哪些附加信息会在归档时被记录&lt;/p&gt;

&lt;h3 id=&#34;内部归档&#34;&gt;内部归档&lt;/h3&gt;

&lt;p&gt;	若你只是不想让某个subtree不出现在agenda,但是又不想把它移动到其他文件中,你可以使用ARCHIVE tag&lt;/p&gt;

&lt;p&gt;	带有ARCHIVE tag的headline具有以下几个特点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用visiblitiy cycling命令不会展开该headline. 若你想强制展开该headline,则可以使用C-TAB,或者设置选项`org-cycle-open-archived-trees`. 当然像`show-all`这样的普通outline命令也会展开被归档的subtree&lt;/li&gt;
&lt;li&gt;在agenda试图中不会显示被归档tree的内容,除非你配置了选项`org-agenda-skip-archived-trees`. 当然,在agenda中,你也可以使用v a来临时把归档tree的内容显示进来&lt;/li&gt;
&lt;li&gt;被归档的tree在导出时只会导出headline而不会导出内容. 具体细节参见变量`org-export-with-archived-trees`&lt;/li&gt;
&lt;li&gt;被归档的tree不会在column视图中显示,除非变量`org-columns-skip-archived-tree`的值为nil&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;	下面是操作ARCHIVE标签的命令&lt;/p&gt;

&lt;p&gt;	* C-c C-x a (org-toggle-archive-tag)&lt;/p&gt;

&lt;p&gt;	  为当前headline添加/去除ARCHIVE标签. 当设置了ARCHIVE标签后,该headline变为灰色,其内容也被隐藏&lt;/p&gt;

&lt;p&gt;	* C-u C-c C-x a&lt;/p&gt;

&lt;p&gt;	  检查当前headline下的是否有哪个直接子节点可以被归档. 类似C-u C-c C-x C-s&lt;/p&gt;

&lt;p&gt;	* C-TAB (org-force-cycle-archived)&lt;/p&gt;

&lt;p&gt;	  即使是被归档的tree也会被展开&lt;/p&gt;

&lt;p&gt;	* C-c C-x A (org-archive-to-archive-sibling)&lt;/p&gt;

&lt;p&gt;	  移动当前entry到Archive Sibling下. 该sibling名为`Archive`,且带有`ARCHIVE`标签.&lt;/p&gt;

&lt;h1 id=&#34;agenda视图&#34;&gt;Agenda视图&lt;/h1&gt;

&lt;p&gt;鉴于Org的工作方式,待办事项,定时事项,各种带标签的headline被分散到各个Org文件中. 要查看整个整体的情况,就需要把这些分散的信息整合起来.&lt;/p&gt;

&lt;p&gt;Org可以根据各种条件从各个分散的Org文件中抽取出复核条件的内容,并在一个新buffer中显示. Org为此提供了多种不同的类型的视图:&lt;/p&gt;

&lt;p&gt;* agenda ::&lt;/p&gt;

&lt;p&gt;			 它看起来跟日历类似,并能显示特定日期的相关信息&lt;/p&gt;

&lt;p&gt;* TODO list ::&lt;/p&gt;

&lt;p&gt;				 显示所有未完成的事项&lt;/p&gt;

&lt;p&gt;* match view ::&lt;/p&gt;

&lt;p&gt;				  显示标签,属性,工作状态符合匹配条件的事项&lt;/p&gt;

&lt;p&gt;* timeline view ::&lt;/p&gt;

&lt;p&gt;将某个Org文件的所有事项按时间排序&lt;/p&gt;

&lt;p&gt;* text search view ::&lt;/p&gt;

&lt;p&gt;	   从多个文件中查找包含指定关键字的所有事项&lt;/p&gt;

&lt;p&gt;* stuck projects view ::&lt;/p&gt;

&lt;p&gt;	   显示没有继续前进的项目&lt;/p&gt;

&lt;p&gt;* custom view ::&lt;/p&gt;

&lt;p&gt;				   自定义搜索,它可以结合多种不同的视图&lt;/p&gt;

&lt;p&gt;这些抽取出来的信息会同一展现在一个名为`agenda buffer`的特别buffer中. 该bufer是只读的,但是提供了访问/修改对应原Org文件内容的命令.&lt;/p&gt;

&lt;p&gt;有两个变量控制了agenda buffer是如何显示的,以及agenda退出时,是否还原之前的窗口配置状态. 这两个变量分别为`org-agenda-window-setup`和`org-agenda-restore-windows-after-quit`&lt;/p&gt;

&lt;h2 id=&#34;agenda-files-从哪些文件中搜索提供給agenda展示的信息&#34;&gt;Agenda files&lt;/h2&gt;

&lt;p&gt;agenda视图从agenda文件中抽取数据来展示,所谓agenda文件是指列在变量`org-agenda-files`中的文件. 如果agenda文件为一个目录,则表少该目录下所有的org文件都为agenda文件.&lt;/p&gt;

&lt;p&gt;因此,即使你只使用一个org文件,也需要把该文件列入变量`org-agenda-files`中. 你可以手工修改该变量,但Org也提供了很多方便的命令方便你维护该变量&lt;/p&gt;

&lt;p&gt;* C-c [ (org-agenda-file-to-front)&lt;/p&gt;

&lt;p&gt;	 添加当前文件到`org-agenda-files`的首部. 若当前文件以及在变量`org-agenda-files`中了,则将它移动到首部. 使用prefix argument调用该命令,则会添加/移动到变量`org-agenda-files`的尾部&lt;/p&gt;

&lt;p&gt;* C-c ] (org-remove-file)&lt;/p&gt;

&lt;p&gt;	 将当前文件从`org-agenda-files`中删除&lt;/p&gt;

&lt;p&gt;* C-&#39; / C-, (org-cycle-agenda-files)&lt;/p&gt;

&lt;p&gt;	 循环遍历agenda文件列表(org-agenda-files),打开其中的org文件&lt;/p&gt;

&lt;p&gt;* org-iswitchb&lt;/p&gt;

&lt;p&gt;	 使用类似iswitchb的界面来在各org buffer之间切换&lt;/p&gt;

&lt;p&gt;Org=&gt;File list for agenda菜单列出了当前agenda文件列表中的所有org文件,你可以用该菜单访问这些org文件&lt;/p&gt;

&lt;p&gt;若你只想查看某个文件甚至是某个文件的部分subtree的agenda视图,而不管该文件是否在agenda文件列表中,你可以在agenda面板显示时按下一次或多次的&lt;键. 若想永久限制agenda的范围,可以使用以下命令:&lt;/p&gt;

&lt;p&gt;* C-c C-x &lt; (org-agenda-set-restriction-lock)&lt;/p&gt;

&lt;p&gt;	 永久性的限制agenda范围为当前subtree. 若待用该命令时带了prefix argument或者光标在第一个headline的之前时,agenda的范围被限制为整个这个文件. 若调用该命令时已经有window展示了agenda视图,则新的限制立刻作用在该agenda视图上.&lt;/p&gt;

&lt;p&gt;* C-c C-x &gt; (org-agenda-remove-restriction-lock)&lt;/p&gt;

&lt;p&gt;	 删除由C-c C-x &gt;所创建的限制.&lt;/p&gt;

&lt;p&gt;若你启用了speedbar,则在speedbar frame中还能使用以下命令&lt;/p&gt;

&lt;p&gt;* &lt; (org-speedbar-set-agenda-restriction)&lt;/p&gt;

&lt;p&gt;	 永久性的约束agenda视图范围,类似C-c C-x &lt;&lt;/p&gt;

&lt;p&gt;* &gt; (org-agenda-remove-restriction-lock)&lt;/p&gt;

&lt;p&gt;	 删除&lt;产生的约束,类似C-c C-x &gt;&lt;/p&gt;

&lt;h2 id=&#34;agenda-dispatcher-调用agenda视图的面板&#34;&gt;Agenda dispatcher&lt;/h2&gt;

&lt;p&gt;各种agenda视图都是通过一个同一的agenda面板来调用的,这个agenda面板推荐绑定到一个全局键序列上(推荐C-c a). 在angenda面板上提供了如下命令来调用不同的agenda视图:&lt;/p&gt;

&lt;p&gt;* a ::&lt;/p&gt;

&lt;p&gt;		 创建类似日历那样的agenda视图(agenda) (参见&lt;a href=&#34;Weekly/daily agenda&#34; title=&#34;Weekly/daily agenda&#34;&gt;Weekly/daily agenda&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;* t / T ::&lt;/p&gt;

&lt;p&gt;			  创建代办事项列表(TODO list)(参见&lt;a href=&#34;Global TODO list&#34; title=&#34;Global TODO list&#34;&gt;Global TODO list&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;* m / M ::&lt;/p&gt;

&lt;p&gt;			  显示标签,属性,工作状态符合匹配条件的事项(match view)&lt;/p&gt;

&lt;p&gt;* L ::&lt;/p&gt;

&lt;p&gt;		  为当前buffer创建timeline view&lt;/p&gt;

&lt;p&gt;* s ::&lt;/p&gt;

&lt;p&gt;		  显示匹配/不匹配某关键字表达式/正则表达式的事项&lt;/p&gt;

&lt;p&gt;* / ::&lt;/p&gt;

&lt;p&gt;		  使用`multi-occur`命令来对变量`org-agenda-files`和`org-agenda-text-search-extra-files`中所列出的文件进行正则查找. 使用prefix argument可以定义每次查找匹配多少行,默认为1行&lt;/p&gt;

&lt;p&gt;* # 或 ! ::&lt;/p&gt;

&lt;p&gt;			 显示无进展的project&lt;/p&gt;

&lt;p&gt;* &lt; ::&lt;/p&gt;

&lt;p&gt;		 限定接下来调用的agenda视图的显示范围为当前buffer&lt;/p&gt;

&lt;p&gt;* &lt;&lt; ::&lt;/p&gt;

&lt;p&gt;		   如果有active region,则该命令限制接下来agenda视图的显示范围为该region. 否则显示接下来要显示的agenda视图的范围为当前的subtree&lt;/p&gt;

&lt;p&gt;* * ::&lt;/p&gt;

&lt;p&gt;		  开启/关闭sticky agenda views. 默认情况下,Org只维护唯一的一个agenda buffer. 当你更改agenda view时,该buffer会自动更新显示新的agenda view的内容. 若你经常在不同的视图之间切换,则更新agenda buffer会消耗大量的时间和资源.  通过开启sticky agenda view(通过配置变量`org-agenda-sticky`可以默认打开该行为),Org会停止agenda buffer的自动更新,你需要手工按r或g来手动更新agenda buffer的内容.  此外,在任何使用都可以通过运行`org-toggle-sticky-agenda`来切换sticky agenda view&lt;/p&gt;

&lt;p&gt;出了内置的agenda视图,你还可以自定义自己的agenda视图,并通过agenda面板进入自定义的agenda视图.&lt;/p&gt;

&lt;h2 id=&#34;built-in-agenda-views-哪些agenda视图是天然可用的&#34;&gt;Built-in agenda views&lt;/h2&gt;

&lt;p&gt;该章节,我们描述哪些Org内建的agenda视图&lt;/p&gt;

&lt;h3 id=&#34;weekly-daily-agenda-带任务信息的日历&#34;&gt;Weekly/daily agenda&lt;/h3&gt;

&lt;p&gt;	Weekly/daily agenda看起来就像是一张日程表似的,它显示了当前周/日的所有任务.&lt;/p&gt;

&lt;p&gt;	* C-c a a (org-agenda-list)&lt;/p&gt;

&lt;p&gt;	  从一系列Org文件中抽取当前周的信息并以日程表的形式展现出来. 该日程表展示了每一天的事项. 使用numeric prefix argument(比如C-u 2 1 C-c a a),可以设置生成的日程表显示多少天的事项&lt;/p&gt;

&lt;p&gt;若不带numeric prefix argument调用该命令,则默认显示的天数由变量`org-agenda-span`决定,该变量的值可以是数字N表示N天,也可以是类似day,week,month,year这样的值. 默认该值为week,这时默认的显示起始时间为前一个周一(参见变量`org-agenda-start-on-weekday`). 你也可以用时间偏移值来表示时间的开始日期,例如(setq org-agenda-start-day &#34;+10d&#34;)表示以10天后的日期作为起始日期.&lt;/p&gt;

&lt;p&gt;	agenda buffer还提供了很多远程编辑原Org文件的命令,这些命令的详细说明请参见&lt;a href=&#34;Agenda commands&#34; title=&#34;Agenda commands&#34;&gt;Agenda commands&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;	*与Calendar/Diary整合在一起*&lt;/p&gt;

&lt;p&gt;	Calendar与Diary的功能与Org非常互补,若能将Org的输出与diary整合起来将是十分受用的.&lt;/p&gt;

&lt;p&gt;	要让Org-mode的agenda也能显示Emacs diary中的事务,需要作如下配置&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;(setq org-agenda-include-diary t)&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;p&gt;	做了如上的配置之后,包括假期,纪念日等等,所有的diary事项都会在agenda视图中显示出来. 在agenda buffer中可以使用&lt;SPC&gt; &lt;TAB&gt; &lt;RET&gt;来跳转到diary文件. 使用i命令创建一个今日事项. 使用S命令查看日出/日落的时间,M来看月相,C用来转换历法格式. c用来在agenda和calendar之间切换&lt;/p&gt;

&lt;p&gt;	Org甚至不用做任何配置就天然支持diary sexp entry. 下面是一个例子&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* Birthdays and similar stuff&lt;/p&gt;

&lt;p&gt;,#+CATEGORY: Holiday&lt;/p&gt;

&lt;p&gt;%%(org-calendar-holiday)   ; special function for holiday names&lt;/p&gt;

&lt;p&gt;,#+CATEGORY: Ann&lt;/p&gt;

&lt;p&gt;%%(org-anniversary 1956  5 14) Arthur Dent is %d years old&lt;/p&gt;

&lt;p&gt;%%(org-anniversary 1869 10  2) Mahatma Gandhi would be %d years old&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;p&gt;	*从BBDB中读取周年纪念日*&lt;/p&gt;

&lt;p&gt;	要使Org在agenda视图中显示存储于BBDB的周年纪念信息,你只需要添加如下代码到Org文件中&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,* Anniversaries&lt;/p&gt;

&lt;p&gt;:PROPERTIES:&lt;/p&gt;

&lt;p&gt;:CATEGORY: Anniv&lt;/p&gt;

&lt;p&gt;:END:&lt;/p&gt;

&lt;p&gt;%%(org-bbdb-anniversaries)&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;p&gt;	*Appointment reminders*&lt;/p&gt;

&lt;p&gt;	通过使用命令`org-agenda-to-appt`,Org可以使用Emacs appointment的通知功能. 该命令默认从agenda files文件中抽取带有起始时间(时间不能只精确到日,一定要精确到几点几分),结束时间,时间戳信息的entry,并添加到appointment中. 另外,你也能够只抽取哪些处于特定的分类,匹配特定的正则的entry(具体信息参见命令`org-agenda-to-appt`的docstring). appointment会提前一段时间发出提醒,这个提前的时间默认由变量`appt-message-warning`决定,但若agenda files中的entry定义了`APPT_WARNTIME`属性,则使用该属性值代替.&lt;/p&gt;

&lt;h3 id=&#34;global-todo-list-显示所有未完成的事项&#34;&gt;Global TODO list&lt;/h3&gt;

&lt;p&gt;	Global TODO list视图将所有未完成的事项整合在一个地方显示.&lt;/p&gt;

&lt;p&gt;	* C-c a t (org-todo-list)&lt;/p&gt;

&lt;p&gt;	  该命令进入Global TODO list视图,该视图从agenda files中抽取所有未完成事项并展示在一个buffer中. 此外该buffer为agenda-mode,你可以直接使用agenda命令来查看/处理这些未完成事项&lt;/p&gt;

&lt;p&gt;	* C-c a T (org-todo-list)&lt;/p&gt;

&lt;p&gt;	  类似C-c a t .但支持只选择特定TODO关键字的事项.&lt;/p&gt;

&lt;p&gt;	  当调用该命令时会提示你你输入TODO关键字,你也可以用`|`同时选择多个TODO关键字.&lt;/p&gt;

&lt;p&gt;	  若调用该命令时带了numeric prefix argument,则会选择`org-todo-keywords`中的第N个todo关键字.&lt;/p&gt;

&lt;p&gt;	  在该视图中,可以使用r来刷选显示. 也可以使用N r来刷新第N个TODO关键字.&lt;/p&gt;

&lt;p&gt;	在该视图模式下,还可以通过单击某个按键来更改原Org文件中的待办事项的完成状态.&lt;/p&gt;

&lt;p&gt;	默认情况下,该视图会将所有的未完成事项都列出来,这使得列表会非常长. 有两种方式进行更进一步的筛选	&lt;/p&gt;

&lt;p&gt;	* 若想根据entry的scheduled,deadline,timestamp来进行过滤,配置如下变量`org-agenda-todo-ignore-scheduled`,`org-agenda-todo-ignore-deadlines`,`org-aegnda-todo-ignore-timestamp`和`org-agenda-todo-ignore-with-date`&lt;/p&gt;

&lt;p&gt;	* 若想只显示最高层次的TODO headline,而不现实sublevel的TODO entry,配置变量`org-agenda-todo-list-sublevels`&lt;/p&gt;

&lt;h3 id=&#34;matching-tags-and-properties-依规则搜索事项&#34;&gt;Matching tags and properties&lt;/h3&gt;

&lt;p&gt;	如果agenda files中的headline标记了tags 和properties,则你可以根据这些元数据作为匹配条件来抽取事项. 这里使用的匹配规则语法与创建sparse tree时使用的语法是一样的.&lt;/p&gt;

&lt;p&gt;	* C-c a m (org-tag-view)&lt;/p&gt;

&lt;p&gt;	  该命令抽取出tag符合给定tag集合的事项. 该命令会提示你输入选择条件,该选择条件是关于tag的逻辑表达式,像`+work+urgent-withboss`这样或`work|home`这样(具体语法请参见&lt;a href=&#34;tags&#34; title=&#34;tags&#34;&gt;tags&lt;/a&gt;).  若你经常使用某个条件作为查询条件,你可以自定义一个命令来专门进行这种查询(方法参见&lt;a href=&#34;Agenda dispatcher&#34; title=&#34;Agenda dispatcher&#34;&gt;Agenda dispatcher&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;	* C-c a M (org-tags-view)&lt;/p&gt;

&lt;p&gt;	  类似C-c a m, 但是搜索的范围只局限于未完成的事项,并且强制检查子事项(参见变量`org-agenda-tags-todo-honor-ignore-options`). 要排除scheduled / deadline事项,配置变量`org-agenda-tags-todo-honor-ignore-options`. 若想同时对TODO关键字和tag作匹配筛选,请参见&lt;a href=&#34;Tag searches&#34; title=&#34;tag searches&#34;&gt;tag searches&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;	要了解tags list视图中的可用命令,请参见&lt;a href=&#34;Agenda commands&#34; title=&#34;Agenda commands&#34;&gt;Agenda commands&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;	*匹配语法(Match syntax)*&lt;/p&gt;

&lt;p&gt;	搜索字符串可以使用布尔运算. `&amp;`表示`与`,`|`表示`或`. 并且`&amp;`的优先级要高于`|`,而且不能用使用括号. 查询字符串中的每个要素可以是要匹配的tag或是一个类似带比较操作符的`PROPERTY OPERATOR VALUE`的表达式. 在元素前家`-`表示不能匹配,而`+`则是主动选择(positive selection?)的语法糖.  当使用`+`或`-`时,不需要使用`&amp;`来表示`和`的关系. 下面是一些根据tag选择的例子&lt;/p&gt;

&lt;p&gt;	#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;‘work’&lt;/p&gt;

&lt;p&gt;Select headlines tagged ‘:work:’.&lt;/p&gt;

&lt;p&gt;‘work&amp;boss’&lt;/p&gt;

&lt;p&gt;Select headlines tagged ‘:work:’ and ‘:boss:’.&lt;/p&gt;

&lt;p&gt;‘+work-boss’&lt;/p&gt;

&lt;p&gt;Select headlines tagged ‘:work:’, but discard those also tagged ‘:boss:’.&lt;/p&gt;

&lt;p&gt;‘work|laptop’&lt;/p&gt;

&lt;p&gt;Selects lines tagged ‘:work:’ or ‘:laptop:’.&lt;/p&gt;

&lt;p&gt;‘work|laptop+night’&lt;/p&gt;

&lt;p&gt;Like before, but require the ‘:laptop:’ lines to be tagged also ‘:night:’.&lt;/p&gt;

&lt;p&gt;	#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;	查询条件除了使用tag名外,还能在大括号中使用正则表达式. 例如`work+{^boss.*}`会匹配同时包含`:work:`标签和一个以上以`boss`开头的标签的headline&lt;/p&gt;

&lt;p&gt;	类似于正则表达式,group tag也会被扩展. 例如,假设`:work:`是`:work:lab:conf:`的group tag,则搜索`work`会扩展为`{\(?:work\|lab\|conf\)}` ,而`-work`会被扩展为`-{\(?:work\|lab\|conf\)}`&lt;/p&gt;

&lt;p&gt;	在匹配tag的同时,你还可以根据headline的属性值(property)来作匹配. 不仅可以对真正的property进行测试,还可以对一些特殊的property进行测试. 例如:`TODO`属性表示entry的TODO关键字,而`PRIORITY`属性表示entry的PRIORITY关键字.  目前暂不支持`ITEM`这个特殊的property&lt;/p&gt;

&lt;p&gt;	除了实际property和特殊peroperty外,还有另外一种peroperty:`LEVEL`,它用来指定搜索entry的级别. 也就是说以条件`+LEVEL=3+boss-TODO=&#34;DONE&#34;`会列出所有第三级别的,带有tag`boss`的,且TODO关键字为`DONE`的headline. 对于那些设置了`org-odd-levels-only`的buffer来说,`LEVEL`并不与标题前的*个数相匹配了,这时`LEVEL=2`对应3个*,`LEVEL=3`对应5个*,依次类推&lt;/p&gt;

&lt;p&gt;	下面是其他的一些例子:&lt;/p&gt;

&lt;p&gt;	`work+TODO=&#34;WAITING&#34;`&lt;/p&gt;

&lt;p&gt;	搜索带:work:标签,且TODO关键字为`WAITING`的事项&lt;/p&gt;

&lt;p&gt;	`work+TODO=&#34;WAITING&#34;|home+TODO=&#34;WAITING&#34;`&lt;/p&gt;

&lt;p&gt;	查询work/home中处于wating状态的任务&lt;/p&gt;

&lt;p&gt;	当对属性值进行匹配测试时,可以使用大量的操作符. 下面是一些更复杂的例子:&lt;/p&gt;

&lt;p&gt;	#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;+work-boss+PRIORITY=&#34;A&#34;+Coffee=&#34;unlimited&#34;+Effort&lt;2+With={Sarah\|Denny}+SCHEDULED&gt;=&#34;&lt;2008-10-11&gt;&#34;&lt;/p&gt;

&lt;p&gt;	#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;	不同的属性值有不同的比较符:&lt;/p&gt;

&lt;p&gt;	* 若属性值为数字,则可以使用数字比较符`&lt;`,&#39;=&#39;,&#39;&gt;&#39;,&#39;&lt;=&#39;,&#39;&gt;=&#39;,&#39;&lt;&gt;&#39;&lt;/p&gt;

&lt;p&gt;	* 若属性值包含在&#34;&#34;中,则属性值为字符串,可以使用字符串相关的比较符和操作符&lt;/p&gt;

&lt;p&gt;	* 若属性值包含在&#34;&lt;&gt;&#34;中(比如`DEADLINE&lt;=&#34;&lt; 2008-12-24 18:30&gt;&#34;`),则属性值被认为是日期/时间格式,可以使用与时间相关的比较符.&lt;/p&gt;

&lt;p&gt;	  还有一些特殊的属性值比如&#34;&lt;now&gt;&#34;表示当前的时间. &#34;&lt;today&gt;&#34;,&#34;&lt;tomorrow&gt;&#34;表示今天/明天的0:00时分. 还有&#34;&lt;+5d&gt;&#34;,&#34;&lt;-2m&gt;&#34;,&#34;&lt;+3y&gt;&#34;这样的写法&lt;/p&gt;

&lt;p&gt;	* 若属性值包含在{}中,则表示正则表达式,这时可以用`=`表示匹配正则表达式或&#34;&lt;&gt;&#34;表示不匹配正则表达式&lt;/p&gt;

&lt;p&gt;	一般来说,通过TODO,LEVEL和CATEGORY属性进行匹配的速度快,其他的属性进行匹配的速度慢. 但若你对某事项的一个属性进行了匹配操作,则对该事项的其他属性进行匹配会快速的多.&lt;/p&gt;

&lt;p&gt;	你可以配置Org mode,使之在搜索时开启属性继承的功能,但是要小心,这项功能会大幅度降低查询速度. 具体细节请查看&lt;a href=&#34;Property inheritance&#34; title=&#34;属性继承&#34;&gt;属性继承&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;	为了向下兼容,也为了方便输入搜索式,还存在另外一种方法来匹配TODO状态. 方法是,用`/`将搜索匹配表达式分成前后两部分,前一部分为搜索tag和property的表达式,后一部分用来专门匹配TODO状态. 后一部分的语法跟tag匹配的语法类似,但有一点要注意,用AND逻辑符组合多个必选的TODO关键字是没有意义的,而用AND逻辑符组合的多个排除的TODO关键字是有意义的. 若希望在匹配时搜索的范围局限于那些TODO关键字为未完成状态的事项,则使用C-c a M或者在搜索表达式的搜索TODO部分以`!`开头(这样可以提高搜索的速度). 例如&lt;/p&gt;

&lt;p&gt;	* `work/WAITING`&lt;/p&gt;

&lt;p&gt;	  与`work+TODO=&#34;WAITING&#34;`一个效果&lt;/p&gt;

&lt;p&gt;	* `work/!-WAITING-NEXT`&lt;/p&gt;

&lt;p&gt;	  搜索tag包含:work:,且TODO状态不为`WAITING`或`NEXT`的事项&lt;/p&gt;

&lt;p&gt;	* `work/!+WAITING|+NEXT`&lt;/p&gt;

&lt;p&gt;	  搜索tag包含:work:,且TODO状态为`WAITNG`或`NEXT`的事项&lt;/p&gt;

&lt;h3 id=&#34;timeline-对单个文件按时间排序事项&#34;&gt;Timeline&lt;/h3&gt;

&lt;p&gt;	timeline会收集某个Org文件中所有的带有时间戳的事项,并用time-sorted视图显示出来. 该命令的主要目的是提供某个项目的概览.&lt;/p&gt;

&lt;p&gt;	* C-c a L (org-timeline)&lt;/p&gt;

&lt;p&gt;	  在time-sorted视图中显示某Org文件中所有带有时间戳的事项. 若调用该命令时带了C-u前缀,则还会列出截止到当天还未完成的事项(不管该事项是否带有时间戳)&lt;/p&gt;

&lt;p&gt;	  timeline buffer中可用的命令,参见&lt;a href=&#34;Agenda commands&#34; title=&#34;Agenda commands&#34;&gt;Agenda commands&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;search-view-按text查询事项&#34;&gt;search view&lt;/h3&gt;

&lt;p&gt;	该视图只是对Org mode下的各事项进行文字匹配查询. 在查找笔记时特别有用.&lt;/p&gt;

&lt;p&gt;* C-c a s (org-search-view)&lt;/p&gt;

&lt;p&gt;	  该命令使你可用使用布尔逻辑运算符来匹配子字符串或整个单词的事项&lt;/p&gt;

&lt;p&gt;	例如搜索&#34;computer equipment&#34;会查找出子串包含`computer equipment`的事项. 另外它也匹配两个单词之间由多个空格或换行符分隔的字符串(??).&lt;/p&gt;

&lt;p&gt;	搜索时还可以使用逻辑运算符,例如`+computer +wifi -ethernet -{8\.11[bg]}`会搜索那些包含computer和wifi,但是不含`ethernet`也不匹配正则表达式`8\.11[bg]`的事项. 这里第一个`+`是必须的,它表示开启单词搜索模式(不能只是子串匹配),其他的`+`是可选的. 详见请看命令`org-search-view`的docstring&lt;/p&gt;

&lt;p&gt;	该命令也会搜索列在`org-agenda-text-search-extra-files`中的agenda file&lt;/p&gt;

&lt;h3 id=&#34;stuck-projects-搜索哪些你需要检查的项目&#34;&gt;stuck projects&lt;/h3&gt;

&lt;p&gt;	若你遵从类似David Allen的GTD这样的时间管理系统来组织你的工作,你应该知道有一项工作就是定期的回顾以确定所有的项目都在推进中. 所谓stuck project是指得那种没有定义下一步行动的project. 在作回顾时,你需要找到这些project并为它们制定下一步的行动&lt;/p&gt;

&lt;p&gt;	* C-c a # (org-agenda-list-stuck-project)&lt;/p&gt;

&lt;p&gt;	  列出所有的stuck project&lt;/p&gt;

&lt;p&gt;	* C-c a !&lt;/p&gt;

&lt;p&gt;	  自定义变量`org-stuck-projects`,该变量决定了什么是stuck project和如何寻找stuck project&lt;/p&gt;

&lt;p&gt;	  基本上你肯定会对该变量进行配置,以适应你的实际情况. 默认的值假设你的project处于第二级的headline,并且若该project拥有`TODO`,`NEXT`,`NEXTACTION`其中一种的TODO状态时,就不是stuck的.&lt;/p&gt;

&lt;p&gt;	  假设你定义带有`PROJECT` tag的事项为project, 然后你不考虑TODO关键字为MAYBE的事项. 再进一步,假设TODO状态为DONE表示project为已完结,NEXT和TODO表明该事项为project的下一步行动. 带标签@SHOP的事项即使没有NEXT标签也认为是下一步行动. 最后假设包含`IGNORE`的project也排除在考虑范围之外.&lt;/p&gt;

&lt;p&gt;	  在这种假设条件下,可用使用`+PROJECT/-MAYBE-DONE`来选择符合条件的事项为project. 然后根据project的子树是否包含TODO,NEXT,@SHOP和IGNORE的事项来决定该project是否为stuck的.&lt;/p&gt;

&lt;p&gt;	  正确的配置为:&lt;/p&gt;

&lt;p&gt;	  #+BEGIN_SRC elisp&lt;/p&gt;

&lt;p&gt;(setq org-stuck-projects&lt;/p&gt;

&lt;p&gt;&#39;(&#34;+PROJECT/-MAYBE-DONE&#34; (&#34;NEXT&#34; &#34;TODO&#34;) (&#34;@SHOP&#34;)&lt;/p&gt;

&lt;p&gt;&#34;\\&lt;IGNORE\\&gt;&#34;))&lt;/p&gt;

&lt;p&gt;	  #+END_SRC&lt;/p&gt;

&lt;p&gt;	  需要注意一点,一个project是非stuck的,Org还会去搜索它的子project是否为stuck的.&lt;/p&gt;

&lt;h2 id=&#34;presentation-and-sorting-事物在agenda中显示的方式&#34;&gt;Presentation and sorting&lt;/h2&gt;

&lt;p&gt;agenda view在显示事项前,Org mode会预先准备好要显示的事项,并对这些事项进行排序. 每个事项占据一行的位置. 每一行都以一个prefix信息开始,prefix信息中包含了该事项的分类信息以及其他重要信息(通过配置`org-agenda-tags-column`可以修改tag在那一列显示,修改`org-agenda-prefix-format`可以配置prefix信息内容).&lt;/p&gt;

&lt;h3 id=&#34;categories-不是所有的任务都是等价的&#34;&gt;Categories: 不是所有的任务都是等价的&lt;/h3&gt;

&lt;p&gt;	agenda显示事项时可以給每个事项分配一个分类标签. 默认情况下,该分类标签的值为事项所属的Org文件名称. 但是你也可以通过在buffer中使用特殊行来指定该分类. 像这样:&lt;/p&gt;

&lt;p&gt;	#+BEGIN_SRC org&lt;/p&gt;

&lt;p&gt;,#+CATEGORY: Thesis&lt;/p&gt;

&lt;p&gt;	#+END_SRC&lt;/p&gt;

&lt;p&gt;	若你要为某个事项或子树分配特定的分类,则需要使用`:CATEGORY:`属性.&lt;/p&gt;

&lt;p&gt;	一般来说,CATEGORY的值不要超过10个字符,这样在agenda中显示时比较好看&lt;/p&gt;

&lt;p&gt;	通过定义变量`org-agenda-category-icon-alist`可以为不同的category分配不同的图标.&lt;/p&gt;

&lt;h3 id=&#34;time-of-day-specifications-agenda是如何识别时间的&#34;&gt;Time-of-day specifications: agenda是如何识别时间的&lt;/h3&gt;

&lt;p&gt;	Org mode会检查每个agenda事项中的时间(time-of-day)说明. 这里的时间可以是显示在agenda中时间戳的一部分,像`&lt; 2005-05-10Tue 19:00&gt;`中的一部分. 时间段则由两个时间戳表示,例如`&lt; 2005-05-10 Tue 20:30&gt;--&lt; 2005-05-10 Tue 22:15&gt;`.&lt;/p&gt;

&lt;p&gt;	在事项的headline中也可以以纯文本的方式表示时间/时间段(例如`12:45`或`8:30-1pm`). 如果agenda与Emacs diary整合起来了(参见&lt;a href=&#34;Weekly/daily agenda&#34; title=&#34;Weekly/daily agenda&#34;&gt;Weekly/daily agenda&lt;/a&gt;),diary事项中指定的时间也会被识别出来.&lt;/p&gt;

&lt;p&gt;	在显示agenda时,Org mode会将事项中抽取出来的时间转换成标准的24小时格式并作为prefix的一部分显示出来. 下面是一个例子:&lt;/p&gt;

&lt;p&gt;	#+BEGIN_QUOTE&lt;/p&gt;

&lt;p&gt;	  8:30-13:00 Arthur Dent lies in front of the bulldozer&lt;/p&gt;

&lt;p&gt;12:45...... Ford Prefect arrives and takes Arthur to the pub&lt;/p&gt;

&lt;p&gt;19:00...... The Vogon reads his poem&lt;/p&gt;

&lt;p&gt;20:30-22:15 Marvin escorts the Hitchhikers to the bridge&lt;/p&gt;

&lt;p&gt;	#+END_QUOTE&lt;/p&gt;

&lt;p&gt;	若agenda处于single-day mode, 或只显示当天的事项时,按时间排序的事项被嵌入到时间格中,类似下面这样&lt;/p&gt;

&lt;p&gt;	#+BEGIN_QUOTE&lt;/p&gt;

&lt;p&gt;	    8:00...... ------------------&lt;/p&gt;

&lt;p&gt;8:30-13:00 Arthur Dent lies in front of the bulldozer&lt;/p&gt;

&lt;p&gt;10:00...... ------------------&lt;/p&gt;

&lt;p&gt;12:00...... ------------------&lt;/p&gt;

&lt;p&gt;12:45...... Ford Prefect arrives and takes Arthur to the pub&lt;/p&gt;

&lt;p&gt;14:00...... ------------------&lt;/p&gt;

&lt;p&gt;16:00...... ------------------&lt;/p&gt;

&lt;p&gt;18:00...... ------------------&lt;/p&gt;

&lt;p&gt;19:00...... The Vogon reads his poem&lt;/p&gt;

&lt;p&gt;20:00...... ------------------&lt;/p&gt;

&lt;p&gt;20:30-22:15 Marvin escorts the Hitchhikers to the bridge&lt;/p&gt;

&lt;p&gt;	#+END_QUOTE&lt;/p&gt;

&lt;p&gt;	时间格的开关由变量`org-agenda-use-time-grid`决定,它的样式由变量`org-agenda-time-grid`决定&lt;/p&gt;

&lt;h3 id=&#34;sorting-agenda-item-事项的展示顺序&#34;&gt;Sorting agenda item: 事项的展示顺序&lt;/h3&gt;

&lt;p&gt;	在显示到view前,Org mode会对各agenda事项进行排序,排序的规则依agenda view的种类不同而不同.&lt;/p&gt;

&lt;p&gt;	* daily/weekly agenda&lt;/p&gt;

&lt;p&gt;	  每天的事项都会被排序. 默认的顺序是,先搜集所有包含明确时间的事项. 这些事项会作为计划显示在列表的最开头部分.  然后事项依据category分组,各分组之间按照变量`org-agenda-files`的顺序排列.  各分组内部按照优先级(参见&lt;a href=&#34;Priorities&#34; title=&#34;Priorities&#34;&gt;Priorities&lt;/a&gt;)和超过schedued/deadline的程度来排序.&lt;/p&gt;

&lt;p&gt;	* TODO list&lt;/p&gt;

&lt;p&gt;	  事项按照各category的分类进行排序,在每个分类内部,按照优先级排序(参见&lt;a href=&#34;Priorities&#34; title=&#34;Priorities&#34;&gt;Priorities&lt;/a&gt;). 用于排序的优先级继承至priority cookie(什么意思??),此外他还跟事项到期天数有关&lt;/p&gt;

&lt;p&gt;	* tag matches&lt;/p&gt;

&lt;p&gt;	  事项根本不排序,只是按照找到的顺序列出而已.&lt;/p&gt;

&lt;p&gt;	配置变量`org-agenda-sorting-strategy`可以更改排序的方法&lt;/p&gt;

&lt;h3 id=&#34;filtering-limiting-agenda-items-动态缩减agenda的展示内容&#34;&gt;Filtering/limiting agenda items: 动态缩减agenda的展示内容&lt;/h3&gt;

&lt;h2 id=&#34;agenda-commands-远程编辑原org-tree&#34;&gt;Agenda commands&lt;/h2&gt;

&lt;h2 id=&#34;custom-agenda-views-自定义搜索规则和显示方法&#34;&gt;Custom agenda views&lt;/h2&gt;

&lt;h2 id=&#34;exporting-agenda-views-导出视图到文件中&#34;&gt;Exporting Agenda Views&lt;/h2&gt;

&lt;h2 id=&#34;agenda-column-view-使用column视图显示agenda中的事物&#34;&gt;Agenda column view&lt;/h2&gt;

&lt;h1 id=&#34;footnotes&#34;&gt;Footnotes&lt;/h1&gt;

&lt;p&gt;[fn:1] install-info的输出也是系统依赖的. 在特定的Debian及其衍生系统中使用两种不同版本的install-info程序.如果你看到&lt;/p&gt;

&lt;p&gt;#+BEGIN_EXAMPLE&lt;/p&gt;

&lt;p&gt;This is not dpkg install-info anymore, but GNU install-info&lt;/p&gt;

&lt;p&gt;See the man page for ginstall-info for command line arguments&lt;/p&gt;

&lt;p&gt;#+END_EXAMPLE&lt;/p&gt;

&lt;p&gt;只管忽略它就好.&lt;/p&gt;

&lt;p&gt;[fn:2] 如果你不想在全局范围使用font-lock,你可以用下面一句配置来只在Org-mode下打开font-lock选项&lt;/p&gt;

&lt;p&gt;#+BEGIN_SRC emacs-lisp&lt;/p&gt;

&lt;p&gt;(add-hook &#39;org-mode-hook &#39;turn-on-font-lock)&lt;/p&gt;

&lt;p&gt;#+END_SRC&lt;/p&gt;

&lt;p&gt;[fn:3] 请考虑订阅邮件列表，以减少工作邮件列表版主的工作量。&lt;/p&gt;

&lt;p&gt;[fn:4] 要配置C-a,C-e和标题环境中C-k的行为,参见参数&#39;org-special-ctrl-a/e&#39;, &#39;org-special-ctrl-k和&#39;org-ctrl-k-protect-subtree&#39;&lt;/p&gt;

&lt;p&gt;[fn:5] 参见org-cycle-emulate-tab选项&lt;/p&gt;

&lt;p&gt;[fn:6] 参见org-cycle-global-at-bob选项&lt;/p&gt;

&lt;p&gt;[fn:7] indirect buffer(关于indirect buffer的更多信息请查看Emacs手册)仅仅包含了原buffer中当前树的内容. 编辑这个indirect buffer也会修改原buffer,但是对原buffer的可见性不会有影响&lt;/p&gt;

&lt;p&gt;[fn:8] 如果你不想一行内容被分割,你需要定制变量&#39;org-M-RET-may-split-line&#39;&lt;/p&gt;

&lt;p&gt;[fn:9] 参见变量&#39;org-show-hierarchy-above&#39;,&#39;org-show-following-heading&#39;,&#39;org-show-siblings&#39;和&#39;org-show-entry-below&#39;,这些参数详细定义了每次匹配多少内容&lt;/p&gt;

&lt;p&gt;[fn:10] 这种行为依赖于&#39;org-remove-highlights-with-change&#39;选项&lt;/p&gt;

&lt;p&gt;[fn:11] 这种方法在Xemacs中是行不通的,because XEmacs uses selective display for outlining, not text properties.&lt;/p&gt;

&lt;p&gt;[fn:12] 当使用*作为列表项的标志时,这一行必须是有缩进的,否则它们会被认为是顶层的标题. 同样的道理,如果你为了得到一个干净的大纲视图而隐藏了前面的星星,那么以*开头的列表项和真正的标题之间会很难区分. 总之,即使支持&#39;*&#39;作为列表项标志,但最好还是不要用它.&lt;/p&gt;

&lt;p&gt;[fn:13] 你可以通过配置&#39;org-plain-list-ordered-item-terminator&#39;来过滤掉它们中的任何一个.&lt;/p&gt;

&lt;p&gt;[fn:14] 通过配置&#39;org-alphabetical-lists&#39;,你也可以用类似&#39;a.&#39;,&#39;A.&#39;,&#39;a)&#39;,&#39;A)&#39;作为列表项的标志. 为了最小化与普通文档的混淆,只准使用单个字符作为标志. 超过这个限制,列表项标志会自动变回数字.&lt;/p&gt;

&lt;p&gt;[fn:15] 如果列表项中包含有复选框,那么这种标志必须放在复选框的前面. 如果你激活了字母列表,你也可以使用类似[@b]这样的形式.&lt;/p&gt;

&lt;p&gt;[fn:16] 参见&#39;org-empty-line-terminates-plain-lists&#39;&lt;/p&gt;

&lt;p&gt;[fn:17] Org只会改变Emacs的filling设置,对于XEmacs,你应该是i用Kyle E.Jones的&#39;filladapt.el&#39;.为了启用这个包,在&#39;.emacs&#39;中添加&#39;(require &#39;filladapt)&#39;&lt;/p&gt;

&lt;p&gt;[fn:18] 如果你不想分割列表项,自定义变量&#39;org-M-RET-may-split-line&#39;&lt;/p&gt;

&lt;p&gt;[fn:19] 如果你想用这种方式遍历列表项,你可能需要自定义&#39;org-list-use-circular-motion&#39;&lt;/p&gt;

&lt;p&gt;[fn:20] 循环行为参见&#39;org-liste-use-circular-motion&#39;&lt;/p&gt;

&lt;p&gt;[fn:21] 欲了解列表项标志的更多规则,参见&#39;org-list-automatic-rules&#39;&lt;/p&gt;

&lt;p&gt;[fn:22] 你可以在每个文件中定义drawers,方法为添加一行类似&#39;#DRAWERS: HIDDEN PROPERTIES STATE&#39;这样的一行.&lt;/p&gt;

&lt;p&gt;[fn:23] 相应的in-buffer设置为: &#39;#+STARTUP: fninline&#39;或者&#39;#+STARTUP nofninline&#39;&lt;/p&gt;

&lt;p&gt;[fn:24] 相应的in-buffer设置为: &#39;fnadjust&#39; 和 &#39;nofnadjust&#39;.&lt;/p&gt;

&lt;p&gt;[fn:25] 要插入一个竖线到表格域中,使用\ vert(去掉空格)代替,若要插入竖线到单词中,则用\ vert{}(去掉空格)代替,例如abc\vert{}def.&lt;/p&gt;

&lt;p&gt;[fn:26] 这个特征在XEmacs上无效&lt;/p&gt;

&lt;p&gt;[fn:27] 诚然它在Emacs中是无效的,但是它在导出为HTML使却有效.&lt;/p&gt;

&lt;p&gt;[fn:28] Org能够识别用户使用&#39;B4&#39;这种写法,但是当Org提供公式来编辑时,不会采用这种引用的表示法. 你可以使用变量&#39;org-table-use-stand-references&#39;来定制这种行为.&lt;/p&gt;

&lt;p&gt;[fn:29] 为了向后兼容性,你可以使用特定的名称类似$LR5和$LR12,分别引用的是表格的倒数第5和倒数第12行. 然而,现在这种语法已经被弃用, 在新文档中不应该再使用这种语法了,现在使用@&gt;$代替.&lt;/p&gt;

&lt;p&gt;[fn:30] 这种操作所花时间的时间复杂度为O(N^2),因为表格FOO需要首先被解析一边这样每一行才能被拷贝过来.&lt;/p&gt;

&lt;p&gt;[fn:31] &#39;constants.el&#39;通过两种单位系统来提供常量值,分别是SI和cgs. 具体使用哪个单位系统取决于变量&#39;constants-unit-system&#39;的设置. 你也可以通过#+STARTUP选项中的constSI和constcgs来为某个文件设置该属性的值.&lt;/p&gt;

&lt;p&gt;[fn:32] 使用printf进行重新格式化时,精度的指定是收到限制的.这是因为,传给printf的值会自动被转换为integer或double类型. integer型数字被限制为包括符号位一共32bit,超过就会被截断. 而double型被限制为精度为64位其中保留16位小数(leaves approximately 16 significant decimal digits)&lt;/p&gt;

&lt;p&gt;[fn:33] 这里名字必须是以字母数字开头,并且只使用字母数字和下划线&lt;/p&gt;

&lt;p&gt;[fn:34] 注意:在第一个标题前的文本通常是不会导出的,因此第一个这种链接吊臂应该是在第一个标题之后的,或者在第一个标题前但是与第一个标题是同一行的位置.&lt;/p&gt;

&lt;p&gt;[fn:35] 当要插入一个连接到标题的链接时,可以使用in-buffer补完功能. 只需要输入一个星号(*)随后跟着几个可选的字母,然后按下M-&lt;TAB&gt;, 当前buffer中所有的标题都会作为补完的选项显示出来.&lt;/p&gt;

&lt;p&gt;[fn:36] 搜索的实际行为依赖于变量&#39;org-link-search-must-match-exact-headline&#39;的值. 如果该值为nil则执行模糊查询. 如果该值为t,则精确匹配标题. 如果该值为&#39;query-to-create&#39;则精确匹配标题,但若匹配不到,则创建一个新标题.&lt;/p&gt;

&lt;p&gt;[fn:37] 如果标题中含有时间戳,时间戳部分不会包含在链接中,从而导致一个错误的链接,因此,最好不要在标题中放置时间戳&lt;/p&gt;

&lt;p&gt;[fn:38] 你不是一定要用这个命令才能插入链接. Org中的链接其实只是个纯文本而已, 你可以直接在buffer中输入或者复制这些文本. 使用这个命令,链接自动被双方括号括住,随后你需要输入可选的描述信息&lt;/p&gt;

&lt;p&gt;[fn:39] 把存储的链接插入buffer之后,这个链接会从存储链接的列表中移走. 如果你希望插入链接之后,链接还保存在列表中,你可以使用`c-u c-u c-u c-c c-l`或者配置选项`org-keep-stored-link-after-insertion`&lt;/p&gt;

&lt;p&gt;[fn:40] 这是通过`org-PREFIX-complete-link`这个函数来实现的&lt;/p&gt;

&lt;p&gt;[fn:41] 参见变量`org-display-internal-link-with-indirect-buffer`&lt;/p&gt;

&lt;p&gt;[fn:42] 对应#+STARTUP中的关键字`inlineimages`&lt;/p&gt;

&lt;p&gt;[fn:43] 为了向后兼容,当附加信息为行号时,也可以使用单冒号(:)&lt;/p&gt;

&lt;p&gt;[fn:44] 当然,你可以创建一个只包含TODO事项列表的文档,但这并不是必须的&lt;/p&gt;

&lt;p&gt;[fn:45] 改变这个变量之后,需要重启Org mode才能生效&lt;/p&gt;

&lt;p&gt;[fn:46] 这一点对于timeline和agenda缓存区中的t命令也适合&lt;/p&gt;

&lt;p&gt;[fn:47] 如果你不想区分tag和todo状态的话,通过配置变量`org-fast-tag-selection-include-todo`可以让你在改变tag的时候自动改变TODO状态(参见章节&lt;a href=&#34;#Setting tags&#34; title=&#34;设置tag&#34;&gt;设置tag&lt;/a&gt;).注意,这意味着你需要为两组关键字分配相同的快捷键&lt;/p&gt;

&lt;p&gt;[fn:48] Org-mode只在读入文件的时候才会去解析这些配置行. 在以`#+`开头的行按下`C-c C-c`的作用是为当前buffer重启一次Org-mode&lt;/p&gt;

&lt;p&gt;[fn:49] 对应的文件内设置是#+STARTUP: logdone&lt;/p&gt;

&lt;p&gt;[fn:50] 对应的文件内设置是#+STARTUP: lognotedone&lt;/p&gt;

&lt;p&gt;[fn:51] 参见变量`org-log-states-order-reversed`&lt;/p&gt;

&lt;p&gt;[fn:52] 当你设置了STARTUP参数`org-log-done`,同时又为状态设置了记录动作的时候,就有可能出现连续记录了两次时间戳的情况. 然而,即使你两边都配置了记录附加信息的动作,org也不会提示你输入两次附加信息.为状态单独设置的记录动作会优先执行.&lt;/p&gt;

&lt;p&gt;[fn:53] 另见选项`org-priority-start-cycle-with-default`&lt;/p&gt;

&lt;p&gt;[fn:54] 如果你希望全局的TODO列表中不现实子任务,参见`org-agenda-todo-list-sublevels`&lt;/p&gt;

&lt;p&gt;[fn:55] 默认不包括描述列表在内. 但是通过修改`org-list-automatic-rules`你也可以允许描述列表成为checkbox&lt;/p&gt;

&lt;p&gt;[fn:56] 如果你希望统计的时候统计所有层次的下级checkbox而不仅仅是直接子checkbox,那你需要修改变量`org-hierarchical-checkbox-statistics`&lt;/p&gt;

&lt;p&gt;[fn:57] 如果在列表的第一行使用`C-u C-c C-c`,而刚好这一行事项没有checkbox标识. 则会给该列表所有事项都加上checkbox的标识&lt;/p&gt;

&lt;p&gt;[fn:58] 就跟其他文件内设置一样,按`C-c C-c`使这行设置生效&lt;/p&gt;

&lt;p&gt;[fn:59] 只有在搜索不涉及到包括属性在内的复杂匹配模式的情况下才成立&lt;/p&gt;

&lt;p&gt;[fn:60] 如果tag没有明确配置快捷键,那么org会自动給它们分配快捷键&lt;/p&gt;

&lt;p&gt;[fn:61] 注意,在定义COLUMN格式时,必须写在同一行中&lt;/p&gt;

&lt;p&gt;[fn:62] 也就是说它不属于Emacs内置的一部分(访问http://orgmode.org)&lt;/p&gt;

&lt;p&gt;[fn:63] 当你手工输入时间戳时,星期不是必须的. 但若你是用Org命令来修改或插入时间戳,则会自动插入星期,这样更方便一些&lt;/p&gt;

&lt;p&gt;[fn:64] 这里准照的是ISO8601日期/时间规范. 若要采用其他规范,参见&lt;a href=&#34;Custom time format&#34; title=&#34;定制时间规范&#34;&gt;定制时间规范&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[fn:65] 当使用这种diary风格的类lisp表达式时,你需要非常小心检查这些参数的调用顺序. 这种顺序严重依赖于变量`calendar-date-style`(对旧版本的Emacs来说是`european-calendar-style`). 例如要指定日期`2005年12月12日`,根据不同的设置分别可以用`(diary-date 12 1 2005)`,`(diary-date 1 12 2005)`,`(diary-date 2005 12 1)`来表示. 这常常让人很疑惑. 用户可以求助于某些特定函数,例如`org-date`或`org-anniversary`. 这些函数跟那些以`diary-`打头的diary函数功能上差不多,但他们的参数使用的是固定的ISO顺序(年,月,日的顺序)而与`calendar-date-style`的值无关&lt;/p&gt;

&lt;p&gt;[fn:66] 参见变量`org-read-date-prefer-future`. 你可以通过设置该值为符号`time`(也就是`&#39;time`),这样之后可以让Org-mode当前时间之前的时间说明当成是明天的时间.&lt;/p&gt;

&lt;p&gt;[fn:67] 如果你不想要calendar出现,配置变量`org-popup-calendar-for-date-prompt`&lt;/p&gt;

&lt;p&gt;[fn:68] 如果你觉得这会让你分心,通过配置`org-read-date-display-live`来打开/关闭这种显示&lt;/p&gt;

&lt;p&gt;[fn:69] 它会一直显示,即使本标记为完成状态还是会显示. 如果你不想这样,设置变量`org-agenda-skip-scheduled-if-done`&lt;/p&gt;

&lt;p&gt;[fn:70] 最后期限和规划日期放置的为止需要紧跟在表示任务的标题行之下. 不要在中间插入任何其他内容.&lt;/p&gt;

&lt;p&gt;[fn:71] 相对应的#+STARTUP关键字有logredeadline, lognoteredeadline, 和 nologredeadline&lt;/p&gt;

&lt;p&gt;[fn:72] 相对应的#+STARTUP关键字有logreschedule, lognotereschedule, 和 nologreschedule&lt;/p&gt;

&lt;p&gt;[fn:73] 事实上任务变回的目标状态由一下流程决定:先取属性`REPEAT_TO_STATE`的值,然后取变量` org-todo-repeat-to-state`的值,若都取不到,则默认为TODO状态序列的第一个状态&lt;/p&gt;

&lt;p&gt;[fn:74] 你可以通过更改变量`org-log-repeat`的值来更改这种行为模式,或者设置#+STARTUP选项为logrepeat,lognoterepeat和nologrepeat中的其中一个. 若设置为lognoterepeat,则你会被提示输入记录内容.&lt;/p&gt;

&lt;p&gt;[fn:75] 若希望Emacs假设你在这段时间内依然是在做这项任务,使用配置(setq org-clock-persist t)&lt;/p&gt;

&lt;p&gt;[fn:76] 要实现自动进行工作量评估,为`org-clock-in-prepare-hook`增加hook函数来实现工作量评估&lt;/p&gt;

&lt;p&gt;[fn:77] 该时间同时由属性`LAST_REPEAT`持有&lt;/p&gt;

&lt;p&gt;[fn:78] 参见变量`org-clock-modeline-total`&lt;/p&gt;

&lt;p&gt;[fn:79] 对应的单文件设置为` #+STARTUP: lognoteclock-out `&lt;/p&gt;

&lt;p&gt;[fn:80] 可以通过变量`org-clock-clocktable-language-setup`来设置language item&lt;/p&gt;

&lt;p&gt;[fn:81] 需要注意的是,所有的参数必须写在同一行,这里之所以分行只是为了好看&lt;/p&gt;

&lt;p&gt;[fn:82] 对于安装Mac OS X的计算机,所谓的空闲时间指的是用户未操作电脑的时间而不仅仅是不操作Emacs的时间. 对于X11的系统,你可以安装一个辅助程序`x11idle.c`来实现这样的功能,该程序可以在org git分发包的UTILITIES目录下找到. 对于其他系统,空闲时间只是指的没有操作Emacs的时间&lt;/p&gt;

&lt;p&gt;[fn:83] 可以通过变量`org-effort-property`来改变属性的值&lt;/p&gt;

&lt;p&gt;[fn:84] Please note the pitfalls of summing hierarchical data in a flat list (参见章节&lt;a href=&#34;# Using column view in the agenda&#34; title=&#34; Using column view in the agenda&#34;&gt; Using column view in the agenda&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;[fn:85] 这里C-c c可以换成你想要的任何键序列&lt;/p&gt;

&lt;p&gt;[fn:86] 使用\%来输入%&lt;/p&gt;

&lt;p&gt;[fn:87] 若你自定义自己的link type(参见&lt;a href=&#34; Adding hyperlink types&#34; title=&#34; Adding hyperlink types&#34;&gt; Adding hyperlink types&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;[fn:88] This will always be the other, not the user. See the variable org-from-is-user-regexp.&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>我的博客演进之路(06)--添加文章列表分页显示</title>
            <link>http://yanwushuang.github.io/2016/05/08/my-blog-add-pagination</link>
            <pubDate>Sun, 08 May 2016 11:24:43 HKT</pubDate>
            <author>Mospan</author>
            <guid>http://yanwushuang.github.io/2016/05/08/my-blog-add-pagination</guid>
            <description>

&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;

&lt;p&gt;由于原来的主页显示是完全平铺，当文章数量较多时， 下拉进度条太长不方便阅读。因此，通过添加文章列表分页显示功能
可以更好的显示与阅读， 每页设计显示10篇刚好也比较好统计。&lt;/p&gt;

&lt;h1 id=&#34;实现&#34;&gt;实现&lt;/h1&gt;

&lt;h2 id=&#34;编写pagination模板代码&#34;&gt;编写pagination模板代码&lt;/h2&gt;

&lt;p&gt;首先， 编写分页显示的golang模板实现代码，代码见如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ $baseurl := .Site.BaseURL }}
{{ $pag := .Paginator }}
{{ if gt $pag.TotalPages 1 }}
&amp;lt;a aria-label=&amp;quot;First&amp;quot; href=&amp;quot;{{ $baseurl }}{{ $pag.First.URL }}&amp;quot;&amp;gt;
  &amp;lt;span aria-hidden=&amp;quot;true&amp;quot;&amp;gt;««&amp;lt;/span&amp;gt;
&amp;lt;/a&amp;gt;

&amp;lt;a{{ if not $pag.HasPrev }} class=&amp;quot;disabled&amp;quot;{{ end }} aria-label=&amp;quot;Previous&amp;quot; href=&amp;quot;{{ if $pag.HasPrev }}{{ $baseurl }}{{ $pag.Prev.URL }}{{ else }}#{{ end }}&amp;quot;&amp;gt;
  &amp;lt;span aria-hidden=&amp;quot;true&amp;quot;&amp;gt;«&amp;lt;/span&amp;gt;
&amp;lt;/a&amp;gt;

{{ range $pag.Pagers }}
&amp;lt;a{{ if eq . $pag }} class=&amp;quot;active&amp;quot;{{ end }} href=&amp;quot;{{ $baseurl }}{{ .URL }}&amp;quot;&amp;gt;
  {{ .PageNumber }}
&amp;lt;/a&amp;gt;
{{ end }}

&amp;lt;a{{ if not $pag.HasNext }} class=&amp;quot;disabled&amp;quot;{{ end }} aria-label=&amp;quot;Next&amp;quot; href=&amp;quot;{{ if $pag.HasNext }}{{ $baseurl }}{{ $pag.Next.URL }}{{ else }}#{{ end }}&amp;quot;&amp;gt;
  &amp;lt;span aria-hidden=&amp;quot;true&amp;quot;&amp;gt;»&amp;lt;/span&amp;gt;
&amp;lt;/a&amp;gt;

&amp;lt;a aria-label=&amp;quot;Last&amp;quot; href=&amp;quot;{{ $baseurl }}{{ $pag.Last.URL }}&amp;quot;&amp;gt;
  &amp;lt;span aria-hidden=&amp;quot;true&amp;quot;&amp;gt;»»&amp;lt;/span&amp;gt;
&amp;lt;/a&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;显示处调用&#34;&gt;显示处调用&lt;/h2&gt;

&lt;p&gt;在需要显示处调用pageination.html，并控制好输入参数， 例如： homepages上的修改为根据文章索引$index与10的除数来进行控制。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;
   {{ $pag := .Paginator }}
   {{ range $index,$data := .Data.Pages }}
   {{ if ge $data.Date.Year .Now.Year }}
   {{ if eq (add (div $index 10) 1) $pag.PageNumber }}
   {{ partial &amp;quot;article.html&amp;quot; $data }}
   {{ end }}{{ end }}{{ end }}
   &amp;lt;nav id=&amp;quot;page-nav&amp;quot; class=&amp;quot;clearfix&amp;quot;&amp;gt;
       {{ partial &amp;quot;pagination.html&amp;quot; . }}
   &amp;lt;/nav&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;显示效果&#34;&gt;显示效果&lt;/h1&gt;

&lt;p&gt;显示如下图红色框内显示：
&lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/my-blog-add-pagination.png&#34; alt=&#34;文章列表分页显示&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>怎样才能拥有个人独立域名邮箱？</title>
            <link>http://yanwushuang.github.io/2016/03/31/independent-mailbox/</link>
            <pubDate>Thu, 31 Mar 2016 21:11:24 HKT</pubDate>
            <author>Mospan</author>
            <guid>http://yanwushuang.github.io/2016/03/31/independent-mailbox/</guid>
            <description>

&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;

&lt;p&gt;在创建开源项目或小团队创业初期，由于没有精力或财力自己搭建内部邮件服务器，为了使大家沟通更顺畅更一致，也为了与客户沟通显得更加专业一些，拥有一致的独立域名邮箱显得也挺重要的。
那么可以借助于网上成熟的免费企业邮箱来配置自己的独立域名邮箱也可以达到效果，只不过私密邮件的安全问题自己掂量好就行。&lt;/p&gt;

&lt;h1 id=&#34;前提条件&#34;&gt;前提条件&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;先拥有自己的域名，申请方式从略。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其次把自己的域名托管到授权DNS服务器上，例如: &lt;a href=&#34;www.dnspod.cn&#34;&gt;DNSPod&lt;/a&gt;, &lt;a href=&#34;http://www.cloudxns.net/&#34;&gt;CloudXNS&lt;/a&gt;等等。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;申请配置步骤&#34;&gt;申请配置步骤&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;打开&lt;a href=&#34;http://ym.163.com/&#34;&gt;网易免费企业邮&lt;/a&gt;按照提示说明进行注册与登陆。&lt;/li&gt;
&lt;li&gt;登陆到自己域名托管商网站进行域名配置：

&lt;ul&gt;
&lt;li&gt;配置MX记录指向mx.ym.163.com.&lt;/li&gt;
&lt;li&gt;配置TXT记录为&amp;rdquo;v=spf1 include:spf.163.com ~all&amp;rdquo;, 这一条是为防止其他的邮件服务器把该地址列为垃圾邮件处理。
配置界面大致如下：
&lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/mospan-mailbox-dns-setting.png&#34; alt=&#34;个人邮箱DNS配置界面&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;使用说明&#34;&gt;使用说明&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;这里管理页面，可以增加新的账号，同时可以注销企业邮箱。
 &lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/mospan-mail-inbox.png&#34; alt=&#34;管理页面&#34; /&gt;&lt;/li&gt;
&lt;li&gt;成员列表界面可以对该域名下的所有邮箱进行管理。
 &lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/mospan-mailbox-members.png&#34; alt=&#34;成员列表界面&#34; /&gt;&lt;/li&gt;
&lt;li&gt;邮件组界面可以对各个成员进行分组管理，以便好统一发送接收邮件。
 &lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/mospan-mailbox-group.png&#34; alt=&#34;邮件组管理界面&#34; /&gt;&lt;/li&gt;
&lt;li&gt;邮箱页面，很简洁，也很方便，网易做了那么多年的邮箱也是可以放心的，很棒。
 &lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/mospan-mail-inbox.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;结语&#34;&gt;结语&lt;/h1&gt;

&lt;p&gt;通过上述的步骤就可以像那么回事的使用个人独立域名邮箱了。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>基于DPDK开发高性能DNS服务器实践总结</title>
            <link>http://yanwushuang.github.io/2016/03/14/xns-on-dpdk/</link>
            <pubDate>Mon, 14 Mar 2016 22:02:57 HKT</pubDate>
            <author>Mospan</author>
            <guid>http://yanwushuang.github.io/2016/03/14/xns-on-dpdk/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/china-DPDK-summit-2015-main-page.png&#34; alt=&#34;中国2015DPDK开发者大会主页&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;简述&#34;&gt;简述&lt;/h1&gt;

&lt;p&gt;有幸全程参与了基于DPDK&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;下一代高性能&lt;a href=&#34;http://www.cloudxns.net/&#34;&gt;CloudXNS&lt;/a&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;服务器开发，从未知到慢慢熟悉，其中也走了些弯路也
    踩过一些坑，一路走来有些感受与心得体会，在此进行梳理下，以对这一阶段做下些小的总结，也可以与同僚们进行交流学习。&lt;/p&gt;

&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;

&lt;p&gt;上一代XNS服务器是基于Linux内核进行开发，单机性能达到数百万级别QPS&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;，相对于BIND&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;来说已经高了很多,平常处理正常毫无压力，但在
    受大量DDOS攻击时服务质量大大降低,虽然我们采用了远端清洗与近地防御的安措施，与受攻击时调度其他应急服务器来抗，但增加了服务器与
    人工干预成本。为了更好的抗DDOS攻击与服务更多的用户，需求单机处理千万级别的替代方案呼之欲出。&lt;/p&gt;

&lt;h1 id=&#34;目标设定&#34;&gt;目标设定&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;单机处理能力千万级别。&lt;/li&gt;
&lt;li&gt;性能，性能，性能。(重要的事重复三遍)&lt;/li&gt;
&lt;li&gt;稳定压倒一切。(此话不是我说的)&lt;/li&gt;
&lt;li&gt;社区活跃，已有商用案例。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;需求调研&#34;&gt;需求调研&lt;/h1&gt;

&lt;p&gt;　　按照上述的目标设定需求，要达到单机处理千万级别的只能采用轮询而非中断方式，在市面上的可实现技术方案有DPDK/pf_ring/netmap等.
    其中DPDK为Intel公司主推，并有BAT之类的大型公司进行商用，而且也比较适合处理UDP类型协议。经过权衡之下，我们决定采用DPDK进行
    下一代XNS的替代方案。&lt;/p&gt;

&lt;h2 id=&#34;优点&#34;&gt;优点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;性能高&lt;/li&gt;
&lt;li&gt;用户态开发&lt;/li&gt;
&lt;li&gt;死后易重启&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;缺点&#34;&gt;缺点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;无网络协议栈&lt;/li&gt;
&lt;li&gt;开发困难，周期长&lt;/li&gt;
&lt;li&gt;参考资料相对还匮乏&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;dpdk核心思想&#34;&gt;DPDK核心思想&lt;/h1&gt;

&lt;h2 id=&#34;组织结构&#34;&gt;组织结构&lt;/h2&gt;

&lt;p&gt;　　DPDK 的组成架构如下图所示,相关技术原理概述如下:
   &lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/DPDK-archite.png&#34; alt=&#34;DPDK组织架构图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　在最底部的内核态(Linux Kernel)DPDK 有两个模块:KNI 与 IGB_UIO。
   其中,KNI 提供给用户一个使用 Linux 内核态的协议栈,以及传统的 Linux 网络工具(如ethtool, ifconfig)。IGB_UIO(igb_uio.ko 和
   kni.ko. IGB_UIO)则借助了 UIO 技术,在初始化过程中将网卡硬件寄存器映射到用户态。&lt;/p&gt;

&lt;p&gt;　　DPDK 的上层用户态由很多库组成,主要包括核心部件库(Core Libraries)、平台相关模块(Platform)、网卡轮询模式驱动模块(PMD-Natives&amp;amp;
   Virtual)、QoS 库、报文转发分类算法(Classify)等几大类,用户应用程序可以使用这些库进行二次开发.&lt;/p&gt;

&lt;h2 id=&#34;用户态模式下的pmd-driver&#34;&gt;用户态模式下的PMD Driver&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;去除了中断影响，减少了操作系统内核的开销，消除了IO吞吐瓶颈；&lt;/li&gt;
&lt;li&gt;避免了内核态和用户态的报文拷贝；用户态下软件崩溃，不会影响系统的稳定性；&lt;/li&gt;
&lt;li&gt;Intel提供的PMD驱动，充分利用指令和网卡的性能；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hugepage和m-buf管理&#34;&gt;HugePage和m_buf管理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;提供2M和1G的巨页，减少了TLB Miss，TLB Miss严重影响报文转发性能；&lt;/li&gt;
&lt;li&gt;高效的m_buf管理，能够灵活的组织报文，包括多buffer接收，分片/重组，都能够轻松应对；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ring&#34;&gt;Ring&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;无锁化的消息队列，实际验证，性能充足；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;82599-sr-iov-nic&#34;&gt;82599 SR-IOV NIC&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;实现虚拟化下高速吞吐；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vector-instance-向量指令&#34;&gt;Vector Instance /向量指令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;明显的降低内存等待开销，提升CPU的流水线效率。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;项目规划&#34;&gt;项目规划&lt;/h1&gt;

&lt;p&gt;　　为了使DPDK更好的在我司使用与发扬光大，我大致规划了初期、中期与长期三步走策略实现目标。&lt;/p&gt;

&lt;h2 id=&#34;初期目标&#34;&gt;初期目标&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;实现一个最简单的DNS demo.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;网络可达。&lt;/li&gt;
&lt;li&gt;Dig示例域名可正确响应。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;中期目标&#34;&gt;中期目标&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;实现一个高性能高并发的DNS服务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需求:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单机性能提高5倍以上。&lt;/li&gt;
&lt;li&gt;形成完整DNS产品服务(XNS、public DNS)。&lt;/li&gt;
&lt;li&gt;平台与服务逻辑分离。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;长期目标&#34;&gt;长期目标&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;实现高性能高并发的网络加速平台与应用体系&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;平台具有可移植性。&lt;/li&gt;
&lt;li&gt;可透明承载多种业务(UDP/TCP)服务。&lt;/li&gt;
&lt;li&gt;平台与服务物理分离。&lt;/li&gt;
&lt;li&gt;可承载其他高级语言与虚拟化。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;开发初试&#34;&gt;开发初试&lt;/h1&gt;

&lt;p&gt;　　为了验证其的可行性，我们对它进行了最小原型开发，实现了一个最简单的DNS服务程序，使其网络可达，dig能正确响应。&lt;/p&gt;

&lt;p&gt;　　由于刚开始对DPDK一无所知，为了网络可达首先要面对的问题是服务器IP在哪儿配置的问题(这也许是一些初学者会面对的幼稚问题)，还好已有前辈
   在QQ大致网上了解一些原理与其源码示例，采用其源码examples目录下l3fwd为基础进行最小原型开发demo。&lt;/p&gt;

&lt;p&gt;　　为了使网络可达，我们做了如下开发：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;先在simpleDNS服务端中临时配置一个服务IP进行过滤.&lt;/li&gt;
&lt;li&gt;在DNS客户端通过手工配置ARP表使得客户端ping/dig操作的请求包可达服务端，&lt;/li&gt;
&lt;li&gt;在simpleDNS服务端做解析请求包，如果是DNS请求构造响应包，其他类型如ARP/ICMP请求则通过KNI入接口ingress()重入Linux内核由
其来处理后再通过KNI的egress()接口响应给客户端。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;经过上述编码调试后，最简单的原型验证通过了，为下面的全面开发提供了参考依据。&lt;/p&gt;

&lt;h1 id=&#34;架构设计&#34;&gt;架构设计&lt;/h1&gt;

&lt;p&gt;　　由于此项目是在基于DPDK进行二次开发，我一般对开源项目的使用原则是：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;应使开源项目融入到项目工程中，而不是项目工程融入到开源项目中&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因此我对它们进行分3层设计与实现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内核层
主要为Linux内核本身与插入igb_uio.ko与rte_kni.ko.&lt;/li&gt;
&lt;li&gt;平台层

&lt;ul&gt;
&lt;li&gt;分为DPDK原生库与fastNP扩展库，分别在不同目录进行隔离。&lt;/li&gt;
&lt;li&gt;DPDK源码树本身，没有任务的修改，是为了更好的升级、开发与维护。&lt;/li&gt;
&lt;li&gt;对DPDK某些接口进行二次封装与业务所需的公共库，一般各种业务应用调用。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;业务层
业务应用的各种实现，可直接调用fastNP平台层与DPDK原生层的API。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;全面开发&#34;&gt;全面开发&lt;/h1&gt;

&lt;h2 id=&#34;源码组织管理&#34;&gt;源码组织管理&lt;/h2&gt;

&lt;p&gt;为了所有源码可以一键编译、一键打包，编写一套符合所需的Makefile进行源码管理。&lt;/p&gt;

&lt;h2 id=&#34;fastnp扩展库开发&#34;&gt;fastNP扩展库开发&lt;/h2&gt;

&lt;p&gt;　　扩展库源码不在DPDK源码目录中，需要很好的理解DPDK下面mk/目录下的各种Makefile原理，
   使其的各种编译选项与属性能够传递到扩展库中。&lt;/p&gt;

&lt;p&gt;扩展库主要实现如下部分功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;基础数据结构库。
  如：高效双链表、用户态RCU接口等。&lt;/li&gt;
&lt;li&gt;轻量级用户态协议栈
  目前主要实现轻量级简易型UDP协议栈，以实现二三层转发为主。&lt;/li&gt;
&lt;li&gt;HOOK挂载与处理机制
  仿造了Linux netfilter框架实现5个点钩子挂载与处理。&lt;/li&gt;
&lt;li&gt;高性能日志库
  参考了目录主流高性能日志与线程安全，实现了一个数百万行打印的高性能日志系统。
等等&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;业务层开发&#34;&gt;业务层开发&lt;/h2&gt;

&lt;p&gt;第一个应用主要是把原有内核版本的KANS源码移植到用户态的SANSD中。&lt;/p&gt;

&lt;h2 id=&#34;控制查看命令开发&#34;&gt;控制查看命令开发&lt;/h2&gt;

&lt;p&gt;为了方便对平台与业务层的查看与控制，我们基于Libcmdline库开发了sansctl命令，可支持命令补全等。&lt;/p&gt;

&lt;h2 id=&#34;发包工具开发&#34;&gt;发包工具开发&lt;/h2&gt;

&lt;p&gt;为了能进行千万级别的高性能测试，基于pktgen-dpdk进行开发使其可以构造DNS请求与控制发送速率功能的spktgen，主界面如下图：
   &lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/spktgen_main_page.jpg&#34; alt=&#34;spktgen发包主界面&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;抓包工具开发&#34;&gt;抓包工具开发&lt;/h2&gt;

&lt;p&gt;由于现有tcpdump不能抓取DPDK接管的网卡数据，也在其基础上开发可在DPDK下抓包的spktdump，以便调试与定位。&lt;/p&gt;

&lt;h2 id=&#34;其他开发&#34;&gt;其他开发&lt;/h2&gt;

&lt;p&gt;从略。&lt;/p&gt;

&lt;h1 id=&#34;踩过的坑&#34;&gt;踩过的坑&lt;/h1&gt;

&lt;h2 id=&#34;架构模式选择&#34;&gt;架构模式选择&lt;/h2&gt;

&lt;p&gt;　　DPDK提供了两种模式可供选择：Run-to-completion与pipeline模式。在官网文档与DPDK开发者大会中都提到了这两种模式，
   但都没说哪种模式更好，要看场景而定。我们在最初设计时，不仅考虑DNS服务器还考虑以后负载均衡设备的使用，选择了
   可支持这两种模式。&lt;/p&gt;

&lt;p&gt;在测试性能时，发现某种情况下不同模式都有优缺点，经常在这两种模式中来回切换测试，造成了一些干扰与浪费了点时间。&lt;/p&gt;

&lt;h2 id=&#34;编译选项一致&#34;&gt;编译选项一致&lt;/h2&gt;

&lt;p&gt;在测试性能时一定使用-O3选项并且编译选项需与DPDK本身app编译选项一致。否则会影响很大的性能。&lt;/p&gt;

&lt;p&gt;DPDK本身app编译选项可以在编译目录下的.XXX.o.cmd文件查看到。&lt;/p&gt;

&lt;h2 id=&#34;变量percore化&#34;&gt;变量percore化&lt;/h2&gt;

&lt;p&gt;　　所用的全局变量尽量percore化，这样可以防止cache miss。例如统计部分要用percore化，计算或显示时再把他们加到一起，
   这个也影响不小的性能。&lt;/p&gt;

&lt;h2 id=&#34;代码逻辑简化&#34;&gt;代码逻辑简化&lt;/h2&gt;

&lt;p&gt;　　由于业务层代码是从内核版本中移植过来的，老早功能就通过了，但性能一直上不来，后来经过代码review发现很多影响性能点，
   又重新优化或精简了下代码逻辑，去掉了不少冗余代码。&lt;/p&gt;

&lt;h2 id=&#34;rcu锁占用性能&#34;&gt;RCU锁占用性能&lt;/h2&gt;

&lt;p&gt;扩大RCU临界区&lt;/p&gt;

&lt;h2 id=&#34;域名压缩占用性能&#34;&gt;域名压缩占用性能&lt;/h2&gt;

&lt;p&gt;应答区中的域名不压缩。&lt;/p&gt;

&lt;h2 id=&#34;master-lcore不要作为收发处理&#34;&gt;master lcore不要作为收发处理&lt;/h2&gt;

&lt;p&gt;如果master lcore作为收发处理，如有数据下方或打印统计时将严重丢包，大大影响收发性能。&lt;/p&gt;

&lt;h1 id=&#34;有待完善&#34;&gt;有待完善&lt;/h1&gt;

&lt;h2 id=&#34;dpdk&#34;&gt;DPDK&lt;/h2&gt;

&lt;h3 id=&#34;缺少配置文件&#34;&gt;缺少配置文件&lt;/h3&gt;

&lt;p&gt;　　现在DPDK代码与核数越来越多,依然使用命令行参数的方式进行启动，可配置与阅读性比较差，应该有自己的配置文件进行解析即可。
   尤其是网卡、队列、逻辑核配置序列太难配置了，尤其是使用核数比较多的情况。&lt;/p&gt;

&lt;p&gt;例如：(0,0,2),(0,1,4),(0,2,6),(0,3,8),(0,4,10),(0,5,12),(0,6,14),(0,7,16),(0,8,18),(0,9,20),(0,10,22),(0,11,24),(0,12,26),(0,13,28)&lt;/p&gt;

&lt;p&gt;不知道各位同学知不道有什么国际规范的缩写方式配置,请麻烦告知一下，OK？&lt;/p&gt;

&lt;h3 id=&#34;pktgen-dpdk驱动bug&#34;&gt;pktgen-dpdk驱动bug&lt;/h3&gt;

&lt;p&gt;　　当使用pktgen-dpdk进行测试时，频繁的启停可能会使万兆光纤网卡处于DOWN状态，重启命令或reboot系统都不管用，必须对服务器
    进行冷重启才行，这对测试比较浪费时间或者远程调试操作堪忧。&lt;/p&gt;

&lt;h3 id=&#34;examples下编码质量参差不齐&#34;&gt;examples下编码质量参差不齐&lt;/h3&gt;

&lt;p&gt;　　DPDK库本身的编码质量还是比较规范统一的，而其examples下的示例代码编码质量参差不齐。&lt;/p&gt;

&lt;h3 id=&#34;fastnp本身&#34;&gt;fastNP本身&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;BOND与多网卡有待支持。&lt;/li&gt;
&lt;li&gt;邻居发现与路由功能有待支持。&lt;/li&gt;
&lt;li&gt;TCP协议栈有待支持。&lt;/li&gt;
&lt;li&gt;虚拟化功能有待支持。&lt;/li&gt;
&lt;li&gt;更高级语言功能有待支持。&lt;/li&gt;
&lt;li&gt;Libc与系统调用劫持功能有待支持。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;经过这一段时间的开发，使得我对DPDK、内存、CPU、用户态网卡驱动有了更深的了解，使得性能达到了万兆网卡线速水平，单机抗攻击能力为1300万QPS，收发平衡能力为1000万QPS的预期目标，
   总之DPDK框架代码写得还是挺不错的，值得仔细研究，现在我只是对它怎么使用与部分源码有了一定的认识，很多精华部分有待深入剖析。&lt;/p&gt;

&lt;h1 id=&#34;footnotes&#34;&gt;Footnotes&lt;/h1&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;DPDK: intel dpdk(Data Plane Development Kit,数据面开发套件)是 intel 公司发布的一款数据包转发处理套件；
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;CloudXNS: 面向云计算的权威智能DNS。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;QPS: 每秒查询率(Query Per Second).
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;BIND: Bind是一款开放源码的DNS服务器软件,Bind由美国加州大学Berkeley分校开发和维护的,全名为Berkeley Internet Name Domain, 它是目前世界上使用最为广泛的DNS服务器软件.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
        
        <item>
            <title>我的博客演进之路(05)--添加访问统计</title>
            <link>http://yanwushuang.github.io/2016/02/21/my-blog-add-visit-counter/</link>
            <pubDate>Sun, 21 Feb 2016 09:52:16 HKT</pubDate>
            <author>Mospan</author>
            <guid>http://yanwushuang.github.io/2016/02/21/my-blog-add-visit-counter/</guid>
            <description>

&lt;h1 id=&#34;申请&#34;&gt;申请&lt;/h1&gt;

&lt;h2 id=&#34;注册&#34;&gt;注册&lt;/h2&gt;

&lt;p&gt;登陆到&lt;a href=&#34;http://www.amazingcounters.com/&#34;&gt;amazingcounters&lt;/a&gt;进行账号注册。&lt;/p&gt;

&lt;h2 id=&#34;申请-1&#34;&gt;申请&lt;/h2&gt;

&lt;p&gt;大致原理为通过注册把自己的域名与统计网站关联后，生成一段html代码拷贝到自己网站上相应显示位置即可。申请步骤如下：&lt;/p&gt;

&lt;p&gt;1.点击“创建” 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/my-blog-add-visit-counter_1.png&#34; alt=&#34;开始创建&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2.选择统计显示样式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/my-blog-add-visit-counter_2.png&#34; alt=&#34;选择显示样式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;3.选择完进入下一步&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/my-blog-add-visit-counter_3.png&#34; alt=&#34;显示样式后下一步&#34; /&gt;&lt;/p&gt;

&lt;p&gt;4.填写网站关联信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/my-blog-add-visit-counter_4.png&#34; alt=&#34;填写网站关联信息&#34; /&gt;&lt;/p&gt;

&lt;p&gt;5.生成关联html并拷贝下来&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/my-blog-add-visit-counter_5.png&#34; alt=&#34;生成关联html&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;使用&#34;&gt;使用&lt;/h1&gt;

&lt;p&gt;首先，在本博客源码新建文件：themes/rapid/layouts/partials/visit.counter.html,内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;  &amp;lt;!-- 添加访问统计--&amp;gt;
  &amp;lt;div align=&amp;quot;center&amp;quot; &amp;gt;
   &amp;lt;p&amp;gt;访问人数:  
    &amp;lt;a href=&amp;quot;http://www.amazingcounters.com&amp;quot;&amp;gt;
     &amp;lt;img border=&amp;quot;0&amp;quot; src=&amp;quot;http://cc.amazingcounters.com/counter.php?i=xxxxxx&amp;amp;c=xxxxx&amp;quot; alt=&amp;quot;UV&amp;quot; title=&amp;quot;访问人数&amp;quot;&amp;gt;
    &amp;lt;/a&amp;gt;
   &amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div align=&amp;quot;center&amp;quot;&amp;gt;
   &amp;lt;p&amp;gt;总访问量:
    &amp;lt;a href=&amp;quot;http://www.amazingcounters.com&amp;quot;&amp;gt;
     &amp;lt;img border=&amp;quot;0&amp;quot; src=&amp;quot;http://cc.amazingcounters.com/counter.php?i=xxxxx&amp;amp;c=xxxxx&amp;quot; alt=&amp;quot;PV&amp;quot; title=&amp;quot;总访问量&amp;quot;&amp;gt;
    &amp;lt;/a&amp;gt;
   &amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其次，在该显示的html文件(themes/rapid/layouts/partials/sidebarLeft.html与themes/rapid/layouts/partials/sidebarLeftCategories.html)调用如上文件即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;    {{ partial &amp;quot;visit.counter.html&amp;quot; . }}
    {{ partial &amp;quot;wechat.html&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;效果&#34;&gt;效果&lt;/h1&gt;

&lt;p&gt;显示效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/my-blog-add-visit-counter-result.png&#34; alt=&#34;访问统计显示效果&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>我的博客演进之路(04)--调整文章版面显示大小</title>
            <link>http://yanwushuang.github.io/2016/02/20/my-blog-modify-container-size/</link>
            <pubDate>Sat, 20 Feb 2016 10:56:35 HKT</pubDate>
            <author>Mospan</author>
            <guid>http://yanwushuang.github.io/2016/02/20/my-blog-modify-container-size/</guid>
            <description>&lt;p&gt;由于原来的版面显示有点过小，在现在的宽屏面前有些浪费。于是为了更好的进行阅读显示，特做了如下修改：&lt;/p&gt;

&lt;p&gt;打开文件./themes/rapid/static/wp-content/themes/hueman/style.css，把&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;  .container { padding: 0 20px; }
  .container-inner { max-width: 1380px; min-width: 1380px; width: 100%; margin: 0 auto; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;  .container { padding: 0 0px; }
  .container-inner { min-width: 1380px; width: 100%; margin: 0 auto; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示效果如下, 修改前：
  &lt;div align=&#34;center&#34;&gt;
    &lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/my-blog-modify-container-size-before.png?imageView2/1/w/1024/h/768/q/75|watermark/2/text/YmxvZy5tb3NwYW4uY24=/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10&#34; alt=&#34;我的博客主页修改前&#34; title=&#34;我的博客主页修改前&#34; width=&#34;800&#34;/&gt;
  &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;修改后：&lt;/p&gt;

&lt;p&gt;&lt;div align=&#34;center&#34;&gt;
    &lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/my-blog-modify-container-size-after.png?imageView2/1/w/1024/h/768/q/75|watermark/2/text/YmxvZy5tb3NwYW4uY24=/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10&#34; alt=&#34;我的博客主页修改后&#34; title=&#34;我的博客主页修改后&#34; width=&#34;800&#34;/&gt;
  &lt;/div&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>pango设计与实现(02)--快速开始</title>
            <link>http://yanwushuang.github.io/2016/02/14/pango-development-quick-start/</link>
            <pubDate>Sun, 14 Feb 2016 16:57:25 HKT</pubDate>
            <author>Mospan</author>
            <guid>http://yanwushuang.github.io/2016/02/14/pango-development-quick-start/</guid>
            <description>

&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;

&lt;h2 id=&#34;安装前准备&#34;&gt;安装前准备&lt;/h2&gt;

&lt;p&gt;确保你的本地环境已经安装好如下软件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git.&lt;/li&gt;
&lt;li&gt;Go 1.4+&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;源码安装&#34;&gt;源码安装&lt;/h2&gt;

&lt;h3 id=&#34;下载源码到本地&#34;&gt;下载源码到本地&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;   git clone https://github.com/yanwushuang/pango.git
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;设置好环境变量&#34;&gt;设置好环境变量&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;   cd pango
   export GOPATH=`pwd`
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;编译&#34;&gt;编译&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;   make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果编译成功，将在当前目录下生成目标可执行二进制程序：pango&lt;/p&gt;

&lt;h3 id=&#34;安装-1&#34;&gt;安装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;   make install
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>pango设计与实现(01)--介绍</title>
            <link>http://yanwushuang.github.io/2016/02/14/pango-development-introduce/</link>
            <pubDate>Sun, 14 Feb 2016 12:22:12 HKT</pubDate>
            <author>Mospan</author>
            <guid>http://yanwushuang.github.io/2016/02/14/pango-development-introduce/</guid>
            <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/yanwushuang/pango&#34;&gt;pango&lt;/a&gt;我个人发起的基于&lt;a href=&#34;http://gohugo.io/&#34;&gt;hugo&lt;/a&gt;的变种开源项目，是一个快速与灵活的静态网页生成器，使用GO语言开发。&lt;/p&gt;

&lt;p&gt;主要基于如下目的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;巩固学习web前后端相关知识。&lt;/li&gt;
&lt;li&gt;巩固学习GO语言并解决实际问题。&lt;/li&gt;
&lt;li&gt;满足我个人博客所需的私人定制要求。&lt;/li&gt;
&lt;li&gt;加入hugo开源项目, 发现并解决bug，希望能贡献一点微薄之力。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;开发特性&#34;&gt;开发特性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;使pango即能支持mardown语法格式又能支持org-mode语法格式。&lt;/li&gt;
&lt;li&gt;编写mardown与org-mode相互转换器。&lt;/li&gt;
&lt;li&gt;发现并解决hugo上的bug。&lt;/li&gt;
&lt;li&gt;目前能想到这些，其他以后补充，现在从略。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;开发计划&#34;&gt;开发计划&lt;/h1&gt;

&lt;p&gt;本项目只利用我个人业余时间进行开发，上班路途远，下班还得做家务与看孩子，能所利用时间不多，我尽量多做些开发，具体时间不便衡量，hugo上修改也会定期同步到本项目。&lt;/p&gt;

&lt;p&gt;开发步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;先学习使用与进行源码分析。&lt;/li&gt;
&lt;li&gt;开发一些满足私人定制的小功能。&lt;/li&gt;
&lt;li&gt;支持org-mode语法格式。&lt;/li&gt;
&lt;li&gt;编写md2org与org2md转换器。&lt;/li&gt;
&lt;li&gt;其他待定。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;小结&#34;&gt;小结&lt;/h1&gt;

&lt;p&gt;希望通过本项目的学习与开发，使本人能学到一些开源技术知识，也希望能认识一些朋友和贡献出一点绵薄之力。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>在Linux下我常用的软件工具</title>
            <link>http://yanwushuang.github.io/2016/02/09/my-linux-common-tools/</link>
            <pubDate>Tue, 09 Feb 2016 19:09:11 HKT</pubDate>
            <author>Mospan</author>
            <guid>http://yanwushuang.github.io/2016/02/09/my-linux-common-tools/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/linux-freedom.png?imageView2/1/w/1024/h/768/q/75|watermark/2/text/YmxvZy5tb3NwYW4uY24=/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10&#34; alt=&#34;linux-freedom.png&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;编程编辑&#34;&gt;编程编辑&lt;/h1&gt;

&lt;h2 id=&#34;emacs&#34;&gt;emacs&lt;/h2&gt;

&lt;p&gt;emacs是我最为常用的工具，大部分工作都在它下面完成，差不多是“开机&amp;ndash;&amp;gt;emacs&amp;ndash;&amp;gt;关机”, 我的emacs也集成了evil插件，综合了emacs与vim两大编辑器的特长，是我更加觉得顺心应手, 更加热爱我的职业。&lt;/p&gt;

&lt;p&gt;我在emacs中常用的插件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bitbucket.org/lyro/evil/wiki/Home&#34;&gt;evil&lt;/a&gt;: 一个实现了vim键位模拟器，将emacs变为vim。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://orgmode.org/&#34;&gt;org&lt;/a&gt;: org-mode,全能的笔记、GTD、文字编辑排版的所思即所得工具。&lt;/li&gt;
&lt;li&gt;xcscope: 阅读源码的跳转工具。&lt;/li&gt;
&lt;li&gt;doxymacs: 快速生成符合标准注释与生成注释文档的插件。&lt;/li&gt;
&lt;li&gt;pylookup: python的阅读查找插件。&lt;/li&gt;
&lt;li&gt;flymake: 语法词法错误的检查工具。&lt;/li&gt;
&lt;li&gt;gud: gdb调试功能。&lt;/li&gt;
&lt;li&gt;unicad: 自动编码识别。&lt;/li&gt;
&lt;li&gt;tramp: 远程登陆编辑调试工具。&lt;/li&gt;
&lt;li&gt;ediff: 比较比较工具&lt;/li&gt;
&lt;li&gt;w3m: 终端下浏览器。&lt;/li&gt;
&lt;li&gt;graphviz: 终端画图软件。&lt;/li&gt;
&lt;li&gt;zencoding/multi-web-mode: web开发插件（支持html/css/javascript）功能。&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vim&#34;&gt;vim&lt;/h2&gt;

&lt;p&gt;Linux下标准配置的编辑器，我一般用来修改配置文件等。&lt;/p&gt;

&lt;h2 id=&#34;使用感受&#34;&gt;使用感受&lt;/h2&gt;

&lt;p&gt;如下是我个人的使用感受，不完全正常，也不想引起编辑器之争。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;emacs功能要比vim多出一个数量级。&lt;/li&gt;
&lt;li&gt;vim的优势击键快速，容易噼里啪啦的肌肉满足感。&lt;/li&gt;
&lt;li&gt;emacs觉得比较优雅更像一个魔术师。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;浏览器&#34;&gt;浏览器&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;chromium web browser&lt;/li&gt;
&lt;li&gt;firefox browser&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;虚拟机&#34;&gt;虚拟机&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;virtualbox&lt;/li&gt;
&lt;li&gt;Virtual Machine Manager&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;聊天工具&#34;&gt;聊天工具&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;QQ网页版&lt;/li&gt;
&lt;li&gt;微信网页版&lt;/li&gt;
&lt;li&gt;脉脉网页版&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;词典工具&#34;&gt;词典工具&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;stardict&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;截图工具&#34;&gt;截图工具&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Shutter&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ftp上传工具&#34;&gt;ftp上传工具&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;filezilla&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;文本比对工具&#34;&gt;文本比对工具&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Meld diff viewer&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;图片处理工具&#34;&gt;图片处理工具&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;GIMP&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;画图工具&#34;&gt;画图工具&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;yEd&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;网络分析工具&#34;&gt;网络分析工具&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;wireshark&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;邮件客户端&#34;&gt;邮件客户端&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Thunderbird Mail&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;办公软件&#34;&gt;办公软件&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;WPS&lt;/li&gt;
&lt;li&gt;open LibreOffice&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;科学上网&#34;&gt;科学上网&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/getlantern/lantern&#34;&gt;lantern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;附上我的ubuntu桌面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xqi7h.com1.z0.glb.clouddn.com/my-ubuntu-desktop.png?imageView2/1/w/1024/h/768/q/75|watermark/2/text/YmxvZy5tb3NwYW4uY24=/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10&#34; alt=&#34;我的ubuntu桌面&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
