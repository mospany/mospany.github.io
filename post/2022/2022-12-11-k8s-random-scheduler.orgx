+++
#+OPTIONS: \n:t
categories = ["技术文章"]
date = "2022-12-11T11:51:52+08:00"
description = ""
keywords = ["K8S","项目实践"]
tags = ["K8S","项目实践"]
title = "K8S项目实践(03): 随机调度器"
url = "/2022/12/11/k8s-random-scheduler/"

+++

* 简介
** POD创建过程
   1、 由kubectl解析创建pod的yaml，发送创建pod请求到APIServer。
   2、 APIServer首先做权限认证，然后检查信息并把数据存储到ETCD里，创建deployment资源初始化。
   3、 kube-controller通过list-watch机制，检查发现新的deployment，将资源加入到内部工作队列，检查到资源没有关联pod和replicaset,然后创建rs资源，rs controller监听到rs创建事件后再创建pod资源。
   4、 scheduler 监听到pod创建事件，执行调度算法，将pod绑定到合适节点，然后告知APIServer更新pod的spec.nodeName
   5、 kubelet 每隔一段时间通过其所在节点的NodeName向APIServer拉取绑定到它的pod清单，并更新本地缓存。
   6、 kubelet发现新的pod属于自己，调用容器API来创建容器，并向APIService上报pod状态。
   7、 Kub-proxy为新创建的pod注册动态DNS到CoreOS。为Service添加iptables/ipvs规则，用于服务发现和负载均衡。
   8、 deploy controller对比pod的当前状态和期望来修正状态。

   [[http://blog.mospan.cn/post/img/k8s/schedulewr/pod-life-cycle.png]]

** 调度器介绍
   从上述流程中，我们能大概清楚kube-scheduler的主要工作，负责整个k8s中pod选择和绑定node的工作，这个选择的过程就是应用调度策略，包括NodeAffinity、PodAffinity、节点资源筛选、调度优先级、公平调度等等，而绑定便就是将pod资源定义里的nodeName进行更新。

* 设计
  kube-scheduler的设计有两个历史阶段版本：

  - 基于谓词（predicate）和优先级（priority）的筛选。
  - 基于调度框架的调度器，新版本已经把所有的旧的设计都改造成扩展点插件形式(1.19+)。

  所谓的谓词和优先级都是对调度算法的分类，在scheduler里，谓词调度算法是来选择出一组能够绑定pod的node，而优先级算法则是在这群node中进行打分，得出一个最高分的node。

  而调度框架的设计相比之前则更复杂一点，但确更加灵活和便于扩展，关于调度框架的设计细节可以查看官方文档——624-scheduling-framework，当然我也有一遍文章对其做了翻译还加了一些便于理解的补充——KEP: 624-scheduling-framework。总结来说调度框架的出现是为了解决以前webhooks扩展器的局限性，一个是扩展点只有：筛选、打分、抢占、绑定，而调度框架则在这之上又细分了11个扩展点；另一个则是通过http调用扩展进程的方式其实效率不高，调度框架的设计用的是静态编译的方式将扩展的程序代码和scheduler源码一起编译成新的scheduler，然后通过scheduler配置文件启用需要的插件，在进程内就能通过函数调用的方式执行插件。

   [[http://blog.mospan.cn/post/img/k8s/schedulewr/pod-life-cycle.png]]

   上面是一个简略版的调度器处理pod流程：

   首先scheduler会启动一个client-go的Informer来监听Pod事件（不只Pod其实还有Node等资源变更事件），这时候注册的Informer回调事件会区分Pod是否已经被调度（spec.nodeName），已经调度过的Pod则只是更新调度器缓存，而未被调度的Pod会加入到调度队列，然后经过调度框架执行注册的插件，在绑定周期前会进行Pod的假定动作，从而更新调度器缓存中该Pod状态，最后在绑定周期执行完向ApiServer发起BindAPI，从而完成了一次调度过程。
 
* 实现
   

   

* 参考资料
  [01] [[https://www.cnblogs.com/z-gh/p/15409763.html][k8s调度器介绍（调度框架版本）]] 
  [02] [[https://zhuanlan.zhihu.com/p/400351590][client-go功能详解]]
  [03] [[https://www.jb51.net/article/253965.htm][一篇文章搞懂Go语言中的Context]]]
