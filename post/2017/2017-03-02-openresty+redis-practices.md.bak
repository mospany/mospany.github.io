+++
categories = ["技术文章"]
date = "2017-03-02T11:14:08+08:00"
description = ""
keywords = ["openresty", "redis"]
tags = ["openresty", "redis"]
title = "openresty与redis实践"
url = "/2017/03/02/openresty-redis-practices/"

+++

# 安装<a id="sec-1" name="sec-1"></a>

## openresty安装<a id="sec-1-1" name="sec-1-1"></a>

详见 [openresty安装](https://openresty.org/cn/installation.html)

## redis安装<a id="sec-1-2" name="sec-1-2"></a>

执行如下命令：

    sudo apt-get update  
    sudo apt-get install redis-server

详见 [Ubuntu安装配置Redis](http://www.jianshu.com/p/c8723b677304)

# 编写API<a id="sec-2" name="sec-2"></a>

根据项目要求编写openresty+lua的增删改查API接口。

# 测试<a id="sec-3" name="sec-3"></a>

## 发送请求<a id="sec-3-1" name="sec-3-1"></a>

使用curl命令发送http json请求:

1.  先写请求json

> root@bj94:~/dr302client# cat add.json
> {
> 
> "www.example.com": {
> 
>         "sub\_domain": "@",
>         "record\_type": "CNAME",
>         "record\_line": "all",
>         "record\_line\_id": "00000000",
>         "value": "all.china.qiniu.qnydns.com",
>         "mx": 1,
>         "ttl": 86400,
>         "status": "enable",
>         "weight": 100
>     }
> }

1.  执行命令：

    curl -i -H 'content-type: application/json' -X POST -d @add.json http://dev.mgrconfig.api.qiniudns.com/qiniu/dr302/records/add

## 回复响应<a id="sec-3-2" name="sec-3-2"></a>

根据不同返回码表示操作结果。

> root@bj94:~/dr302client# curl -i -H 'content-type: application/json' -X POST -d @addA.json <http://dev.mgrconfig.api.qiniudns.com/qiniu/dr302/records/add>
> 
> HTTP/1.1 200 OK
> Date: Thu, 09 Mar 2017 03:01:17 GMT
> Content-Type: text/plain
> Transfer-Encoding: chunked
> Connection: keep-alive
> Server: DR302-MGR
> 
> {
>     "status":{
>                "created\_at":"2017-03-09 11:01:17",
>                "code":0,
>                "message":"success"
>              },
>     "record":{
>                "status":"enable",
>                "key":"www.example.com#all",
>                "name":"@"
>              }
> }

## 查看存储<a id="sec-3-3" name="sec-3-3"></a>

执行命令:

    (echo  "select 10"; echo "hgetall www.example.com#all") | redis-cli -a cdnfusion -p 7648"

避免中文乱码，加&#x2013;raw选项：

    (echo  "select 10"; echo "hgetall www.example.com#all") | redis-cli -a cdnfusion -p 7648 --raw

显示如下:

> root@bj94:~/dr302client# (echo  "select 10"; echo "hgetall www.example.com#all") | redis-cli -a cdnfusion -p 7648
> OK
> 1.  "weight"
> 2.  "20"
> 3.  "record\_type"
> 4.  "A"
> 5.  "record\_line"
> 6.  "all"
> 7.  "status"
> 8.  "enable"
> 9.  "mx"
> 10. "1"
> 11. "value"
> 12. "1.1.1.1#10|2.2.2.2#20"
> 13. "ttl"
> 14. "86400"
> 15. "record\_line\_id"
> 16. "00000000"
> 17. "sub\_domain"
> 18. "@"

## 踩过的坑<a id="sec-3-4" name="sec-3-4"></a>

### table的深度与浅度拷贝<a id="sec-3-4-1" name="sec-3-4-1"></a>

1.  现象

    当通过API批量获取配置列表时，发现不同的key获取的值是一样的， 但通过redis-cli获取是不一样且正确的。

2.  分析

    redis存储是正确的，很有可能是中间临时存储存在覆盖的问题， 如果table每次赋值都相当于内存拷贝那样Lua的性能就会大大降低，会不会table之间赋值就像C语言一样只赋值地址或指针。经网上查找发现table存在深度与浅度拷贝的区别。详见:[Lua实现深度拷贝](https://my.oschina.net/hqc17/blog/748709) 

3.  解决措施

    把中间的临时table变量放入当前语句块中并加local标识，猜测在当前语句块临时table可能会随时被释放掉，因此它赋值给其他作用域更大的变量时使用深拷贝。

### hgetall结果与Lua table转换<a id="sec-3-4-2" name="sec-3-4-2"></a>

使用hgetall获取redis的内容需经转换后才能被Lua table使用。
转换关键代码如下:

     1  local v = red:hgetall(innerk) 
     2  if v == nil then
     3      log(ERR, "get redis empty key: ", innerk)
     4      return nil
     5  end
     6  for key,val in pairs(v) do
     7     if key%2 ~= 0 then
     8        result[v[key]] = v[key+1];
     9     end
    10  end

### nginx worker权限问题<a id="sec-3-4-3" name="sec-3-4-3"></a>

1.  现象

    当使用init\_worker\_by\_lua\_file进行定时器任务时，发现不能打开或写入/usr/local/openresty/子目录下的文件， 而init\_by\_lua\_file调用则正常。

2.  分析

    当把路径改为/tmp/目录下则运行都正常，经定位发现nginx master以root身份运行， 而nginx worker以nobody身份运行。
    查看需要读写的文件路径， 发现只有root权限才能写。

3.  解决措施

    1） 发现代码以"r+"(更新模式,保存之前的数据)模式进行读文件，需改成"r"只读模式。
    2） 把要写的文件路径改成其他可写，例如: chmod 777 data
